
LLM Name: o3-2025-04-16
Input:
You are an AI code reviewer validating production-ready experiment code for research papers.

Analyze the provided experiment code and determine if it meets all requirements for immediate execution in research experiments.

# Instructions

## Core Validation Criteria
Check if the generated experiment code meets ALL of the following requirements:

1. **Complete Implementation**:
   - Every component is fully functional, production-ready, publication-worthy code
   - No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
   - All functions and classes are completely implemented
   - No truncated code sections or incomplete implementations

2. **Hydra Integration**:
   - Uses Hydra to manage all experiment configurations from `config/run/*.yaml` files
   - All parameters are loaded from run configs dynamically
   - Proper configuration structure with run_id, method, model, dataset, training, and optuna sections
   - CLI interface matches:
     * Training: `uv run python -u -m src.main run={run_id} results_dir={path}`
     * Evaluation: `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'` (independent execution)
   - Supports trial_mode=true flag for lightweight validation runs (automatically disables WandB)

3. **Complete Data Pipeline**:
   - Full data loading and preprocessing implementation
   - Dataset-specific preprocessing is properly implemented
   - No placeholder dataset loading code
   - Proper error handling for data operations
   - Uses `.cache/` as the cache directory for all datasets and models

4. **Model Implementation**:
   - Complete model architectures for all methods (proposed and comparative methods)
   - No placeholders (TODO, PLACEHOLDER, pass, or incomplete implementations)
   - When External Resources specify HuggingFace models: properly use and customize them (acceptable to wrap AutoModel, add adapters, etc.)
   - When no external models specified: implement architectures from scratch using PyTorch primitives
   - Model-specific configurations correctly applied
   - Proper PyTorch usage throughout

5. **File Structure Compliance**:
   - Contains EXACTLY these required files (and NO other files):
     * `src/train.py`
     * `src/evaluate.py`
     * `src/preprocess.py`
     * `src/model.py`
     * `src/main.py`
     * `pyproject.toml`
     * `config/config.yaml`
   - NO additional files (e.g., NO `src/__init__.py`, NO `setup.py`, NO other Python files)
   - No missing files from the structure
   - All functionality contained within specified files

6. **WandB Integration**:
   - train.py initializes WandB and logs ALL metrics using `wandb.log()`
   - trial_mode automatically disables WandB (sets wandb.mode=disabled)
   - NO results.json or stdout JSON dumps in train.py
   - config/config.yaml contains mandatory WandB settings (entity/project)

7. **Configuration Files**:
   - The generated code properly references config files via Hydra
   - NOTE: config/run/{run_id}.yaml files are provided separately (not in ExperimentCode)
   - All run configurations match the experiment_runs provided
   - Optuna search spaces are properly defined if applicable

8. **Evaluation Script Independence**:
   - evaluate.py is executed independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
   - Accepts `run_ids` parameter as JSON string list (parse with `json.loads(args.run_ids)`)
   - main.py DOES NOT call evaluate.py
   - evaluate.py retrieves ALL data from WandB API using `wandb.Api()` (not from local files)
   - **STEP 1: Per-Run Processing** (for each run_id):
     * Export run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
     * Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
     * Each run should have its own subdirectory with its metrics and figures
   - **STEP 2: Aggregated Analysis** (after processing all runs):
     * Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
     * Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
     * Generate comparison figures to: `{results_dir}/comparison/`
     * Cross-run comparison charts (bar charts, box plots)
     * Performance metrics tables
     * Statistical significance tests
   - Proper figure quality: legends, annotations, tight_layout
   - Follows naming convention: `<figure_topic>[_<condition>][_pairN].pdf`
   - train.py and main.py generate NO figures
   - evaluate.py cannot run in trial_mode (no WandB data available when WandB disabled)

9. **Trial Mode Implementation**:
   - trial_mode=true flag properly reduces computational load
   - Training: epochs=1, batches limited to 1-2, Optuna disabled (n_trials=0), small evaluation subset
   - WandB automatically disabled in trial_mode (wandb.mode=disabled)
   - Purpose: Fast validation that code runs without errors

## Output Format
Respond with a JSON object containing:
- `is_code_ready`: boolean - true if ALL criteria are met, false otherwise
- `code_issue`: string - specific issues found if any criteria are not met, focusing on what needs to be fixed

# Current Research Method
{
    "Open Problems": "Most popular test-time adaptation (TTA) methods such as TENT adapt only BatchNorm affine parameters by minimizing prediction entropy on the incoming test stream. Although very effective, they often require 3-10 gradient steps for each incoming mini-batch to reach their best performance. The slow convergence mainly comes from noisy gradients produced by low-confidence (high-entropy) samples that dominate early in adaptation. A simple mechanism to down-weight these uncertain samples during optimization is missing.",
    "Methods": "Confidence-Weighted Entropy Minimization (CW-TENT).\n1. Keep the original TENT objective L = Σ_i H(p_i) where H is entropy.\n2. Introduce a scalar weight per sample w_i = 1 – H(p_i)/log(C)  (ranges in [0,1]; C = #classes).\n3. Replace the loss with the weighted variant  L_w = Σ_i w_i · H(p_i) / Σ_i w_i.\n4. Use the same SGD update of BatchNorm affine parameters, but with a single gradient step per mini-batch (optionally with momentum=0.9).\nTheoretical intuition: high-confidence samples (low entropy) are already close to the target domain optimum and provide reliable gradients; amplifying their contribution yields a cleaner gradient direction, allowing larger learning rate or fewer steps, hence faster convergence.",
    "Experimental Setup": "Dataset: CIFAR-10-C with 15 corruption types, severity 5 (standard TTA benchmark).\nModel: Pre-trained ResNet-18.\nBaselines: 1) Source model (no adaptation). 2) Original TENT (default 10 inner steps). 3) CW-TENT (1 inner step).\nMetric: Top-1 accuracy after processing the full test stream; also accuracy after first K (e.g., 1, 3) adaptation steps to measure convergence speed.",
    "Experimental Code": "import torch, torch.nn.functional as F\n\ndef entropy(p):\n    return -(p * p.log()).sum(1)\n\nclass CWTentAdapter:\n    def __init__(self, model, lr=1e-3, momentum=0.9):\n        self.model = model.eval()\n        self.model.requires_grad_(False)\n        # enable gradients for affine BN params only\n        for m in model.modules():\n            if isinstance(m, torch.nn.BatchNorm2d):\n                m.weight.requires_grad_(True)\n                m.bias.requires_grad_(True)\n        self.optimizer = torch.optim.SGD(filter(lambda p: p.requires_grad, model.parameters()), lr=lr, momentum=momentum)\n\n    @torch.no_grad()\n    def predict(self, x):\n        return self.model(x).softmax(1)\n\n    def adapt(self, x):\n        self.model.train()        # BN uses batch statistics\n        self.optimizer.zero_grad()\n        logits = self.model(x)\n        probs = logits.softmax(1)\n        H = entropy(probs)\n        w = 1 - H / torch.log(torch.tensor(probs.size(1), device=x.device))\n        loss = (w * H).sum() / w.sum()\n        loss.backward()\n        self.optimizer.step()\n        self.model.eval()\n        return probs.detach()\n",
    "Expected Result": "With only one gradient step per mini-batch, CW-TENT is expected to match or surpass the accuracy of TENT that uses 5–10 steps. For example on CIFAR-10-C severity 5: Source 58.7%, TENT (10 steps) 71.0%, CW-TENT (1 step) ≈71.5%. Convergence plot should show CW-TENT reaching peak accuracy after the first step, whereas TENT needs several.",
    "Expected Conclusion": "A tiny modification—confidence-weighted entropy—suppresses noisy gradients from uncertain samples and lets TENT converge in a single step. The change is trivial to implement (four extra lines) yet meaningfully cuts computation and latency at test time, making TTA more practical for real-time deployment."
}

# Experimental Design
- Strategy: The experiment demonstrates that Confidence-Weighted TENT (CW-TENT) enables fast, one-step test-time adaptation by down-weighting high-entropy (low-confidence) samples in the classic entropy-minimisation objective used by TENT. A pre-trained ResNet-18 is sequentially exposed to the CIFAR-10-C corruption stream (severity-5). At every incoming mini-batch the model first produces predictions, then performs one SGD update on BatchNorm affine parameters using the confidence-weighted entropy loss. Performance is evaluated as the stream proceeds and compared against: (1) the frozen source model (no adaptation) and (2) the original TENT that applies 10 inner optimisation steps. All runs share identical data order, initial weights and hardware (8×H200, 144 GB each). Hyper-parameter sweeps on learning-rate, momentum and weight-decay are carried out with random search (30 trials) on a held-out corruption set to obtain fair settings for both CW-TENT and the baseline.
- Proposed Method: Confidence-Weighted Entropy Minimisation (CW-TENT)
Objective: Accelerate, stabilise and computationally lighten test-time adaptation by re-weighting each sample’s entropy according to its prediction confidence.
Theoretical intuition: Samples with low entropy are nearer to the target optimum and thus deliver cleaner gradient signals. Emphasising them suppresses noise from uncertain samples appearing early in the stream, allowing convergence in a single step.
Algorithm:
1. Observation x → logits z = f_θ(x) (θ frozen except BN γ,β).
2. Compute probabilities p = softmax(z) and entropy H_i = −Σ_c p_{ic} log p_{ic}.
3. Compute weight w_i = 1 − H_i / log C (C = number of classes). Range [0,1].
4. Weighted loss: L_w = Σ_i w_i H_i / Σ_i w_i.
5. Perform one SGD step on BN affine parameters only (lr≈1e-3, momentum≈0.9).
6. Switch model back to eval mode and continue streaming.
Implementation additions over TENT:
• 3 lines to calculate w_i and replace loss.
• Inner-loop steps fixed to 1, cutting compute 10×.
Complexities: O(B) extra operations per batch for weight computation – negligible compared with forward/backward passes.
- Evaluation Metrics: ['Top-1 Accuracy', 'Average Accuracy After First Adaptation Step']

# Experiment Runs

- Run ID: proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: proposed
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  
  Config Content:
  ```yaml
  run_id: "proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)"
method: proposed
model:
  name: ResNet-18
  provider: timm
  checkpoint: resnet18.a1_in1k
  num_parameters: 11700000
  pretrained: true
  trainable_parameters:
    - BatchNorm2d.weight
    - BatchNorm2d.bias
dataset:
  name: CIFAR-10-C
  severity: 5
  corruption_types: all            # 15 standard corruptions
  normalization:
    mean: [0.4914, 0.4822, 0.4465]
    std:  [0.2470, 0.2435, 0.2616]
  batch_size: 64
training:
  adaptation: true                 # test-time adaptation instead of full training
  inner_steps: 1                   # CW-TENT uses a single gradient step
  loss: confidence_weighted_entropy
  optimizer: sgd
  learning_rate: 0.001
  momentum: 0.9
  weight_decay: 0.0
  epochs: 1                        # one pass over the test stream
  lr_schedule: constant
optuna:
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
    batch_size:
      type: categorical
      choices: [32, 64, 128]

  ```
  

- Run ID: comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: comparative-1
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  
  Config Content:
  ```yaml
  run_id: "comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)"
method: comparative-1      # Original TENT baseline
model:
  name: ResNet-18
  provider: timm
  checkpoint: resnet18.a1_in1k
  num_parameters: 11700000
  pretrained: true
  trainable_parameters:
    - BatchNorm2d.weight
    - BatchNorm2d.bias
dataset:
  name: CIFAR-10-C
  severity: 5
  corruption_types: all
  normalization:
    mean: [0.4914, 0.4822, 0.4465]
    std:  [0.2470, 0.2435, 0.2616]
  batch_size: 64
training:
  adaptation: true
  inner_steps: 10                  # classic TENT uses 10 inner optimisation steps
  loss: entropy
  optimizer: sgd
  learning_rate: 0.001
  momentum: 0.9
  weight_decay: 0.0
  epochs: 1
  lr_schedule: constant
optuna:
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
    batch_size:
      type: categorical
      choices: [32, 64, 128]

  ```
  


# Generated Experiment Code (To be validated)
{"config_yaml": "defaults:\n  - _self_\n\n# Global switches -------------------------------------------------------------\ntrial_mode: false         # set to true via CLI for CI / light validation\nresults_dir: ./results    # can be overridden from CLI\n\n# WandB configuration ---------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online            # automatically set to \"disabled\" in trial_mode\n\n# Placeholders to satisfy OmegaConf access if user forgets run=\u2026 override\nrun: {}\nmodel: {}\ndataset: {}\ntraining: {}\noptuna:\n  n_trials: 0\n  direction: maximize\n  search_space: {}\n  metric: top1_accuracy\n", "evaluate_py": "# src/evaluate.py\n\"\"\"Independent evaluation \u0026 visualisation script.\nPulls metrics from WandB for given run_ids, generates per-run artefacts\n(learning curves + confusion matrix) and an aggregated comparison including\nstatistical significance tests.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport json\nfrom pathlib import Path\nfrom typing import List, Dict, Tuple\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport yaml\nimport wandb\nfrom scipy import stats\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\n\nsns.set(style=\"whitegrid\")\n\n###############################################################################\n# Helper functions                                                             #\n###############################################################################\n\ndef save_learning_curve(df: pd.DataFrame, out_path: Path, metric: str = \"top1_batch_acc\") -\u003e None:\n    if metric not in df.columns:\n        return\n    plt.figure(figsize=(6, 4))\n    sns.lineplot(x=df.index, y=df[metric])\n    if df[metric].notna().any():\n        best_idx = df[metric].idxmax()\n        best_val = df[metric].max()\n        plt.scatter(best_idx, best_val, color=\"red\")\n        plt.text(best_idx, best_val, f\"{best_val:.2f}\")\n    plt.xlabel(\"Step\")\n    plt.ylabel(metric.replace(\"_\", \" \"))\n    plt.title(f\"{metric} over steps\")\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\ndef save_confusion(y_true: List[int], y_pred: List[int], out_path: Path, classes: List[str]):\n    if len(y_true) == 0:\n        return\n    cm = confusion_matrix(y_true, y_pred, labels=range(len(classes)))\n    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=classes)\n    fig, ax = plt.subplots(figsize=(6, 6))\n    disp.plot(ax=ax, cmap=\"Blues\", colorbar=False)\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    fig.savefig(out_path)\n    plt.close(fig)\n\n\ndef mcnemar_significance(y_true: List[int], preds_a: List[int], preds_b: List[int]) -\u003e float:\n    \"\"\"McNemar test between model A (baseline) and model B.\n    Returns p-value (two-sided).\n    \"\"\"\n    if len(y_true) == 0:\n        return 1.0\n    correct_a = np.array(preds_a) == np.array(y_true)\n    correct_b = np.array(preds_b) == np.array(y_true)\n    # Contingency table counts\n    n01 = np.logical_and(correct_a, ~correct_b).sum()  # A correct, B wrong\n    n10 = np.logical_and(~correct_a, correct_b).sum()  # A wrong, B correct\n    if (n01 + n10) == 0:\n        return 1.0  # identical predictions \u2013 not significant\n    stat = (abs(n01 - n10) - 1) ** 2 / (n01 + n10)\n    p = stats.chi2.sf(stat, df=1)\n    return float(p)\n\n\ndef announce(collected: List[str], path: Path):\n    collected.append(str(path))\n    print(str(path))\n\n###############################################################################\n# Main                                                                         #\n###############################################################################\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Evaluate CW-TENT experiments via WandB logs.\")\n    parser.add_argument(\"results_dir\", type=str, help=\"Directory to save evaluation artefacts\")\n    parser.add_argument(\"run_ids\", type=str, help=\"JSON-encoded list of run IDs\")\n    args = parser.parse_args()\n\n    results_root = Path(args.results_dir).expanduser()\n    results_root.mkdir(parents=True, exist_ok=True)\n\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    # Load global cfg (contains WandB credentials)\n    cfg_path = results_root / \"config.yaml\"\n    if not cfg_path.exists():\n        raise FileNotFoundError(f\"{cfg_path} not found. Did you pass the correct results_dir?\")\n    with open(cfg_path, \"r\") as f:\n        global_cfg = yaml.safe_load(f)\n    entity = global_cfg[\"wandb\"][\"entity\"]\n    project = global_cfg[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n\n    aggregated: Dict[str, Dict[str, float]] = {}\n    generated_files: List[str] = []\n    predictions_cache: Dict[str, Tuple[List[int], List[int]]] = {}\n\n    # ------------------ PER-RUN PROCESSING ---------------------------------\n    for run_id in run_ids:\n        print(f\"\\n[Eval] Processing run: {run_id}\")\n        run_subdir = results_root / run_id\n        run_subdir.mkdir(parents=True, exist_ok=True)\n\n        try:\n            run = api.run(f\"{entity}/{project}/{run_id}\")\n        except wandb.errors.CommError:\n            print(f\"  [WARN] Run {run_id} not found \u2011 skipping.\")\n            continue\n\n        # Fetch history (learning curve)\n        history_df = run.history(samples=100_000)\n        metrics_json = run_subdir / \"metrics.json\"\n        history_df.to_json(metrics_json, orient=\"records\", indent=2)\n        announce(generated_files, metrics_json)\n\n        # Learning curve\n        lc_path = run_subdir / \"learning_curve_top1_batch_acc.pdf\"\n        save_learning_curve(history_df, lc_path, metric=\"top1_batch_acc\")\n        announce(generated_files, lc_path)\n\n        # Retrieve predictions / labels (stored in summary by train.py)\n        y_true = run.summary.get(\"y_true\", [])\n        y_pred = run.summary.get(\"y_pred\", [])\n        # Fallback to history columns if necessary\n        if (not y_true) and (\"y_true\" in history_df.columns and \"y_pred\" in history_df.columns):\n            y_true = history_df[\"y_true\"].dropna().astype(int).tolist()\n            y_pred = history_df[\"y_pred\"].dropna().astype(int).tolist()\n\n        predictions_cache[run_id] = (y_true, y_pred)\n\n        # Confusion matrix\n        cm_path = run_subdir / \"confusion_matrix.pdf\"\n        if y_true and y_pred:\n            num_classes = max(max(y_true), max(y_pred)) + 1\n            classes = [str(i) for i in range(num_classes)]\n            save_confusion(y_true, y_pred, cm_path, classes)\n            announce(generated_files, cm_path)\n\n        # Final accuracy\n        if y_true and y_pred:\n            final_acc = 100.0 * (np.array(y_true) == np.array(y_pred)).mean()\n        else:\n            final_acc = float(run.summary.get(\"top1_accuracy\", np.nan))\n        aggregated[run_id] = {\"top1_accuracy\": float(final_acc)}\n\n    # ------------------ AGGREGATED COMPARISON ------------------------------\n    comparison_dir = results_root / \"comparison\"\n    comparison_dir.mkdir(exist_ok=True)\n\n    # Detect baseline (the first run in list)\n    baseline_id = run_ids[0] if run_ids else None\n    baseline_acc = aggregated.get(baseline_id, {}).get(\"top1_accuracy\", np.nan)\n\n    # Derived metrics\n    for rid, metrics in aggregated.items():\n        if baseline_id and rid != baseline_id and not np.isnan(baseline_acc):\n            metrics[\"improvement_rate\"] = (\n                (metrics[\"top1_accuracy\"] - baseline_acc) / baseline_acc\n            )\n        else:\n            metrics[\"improvement_rate\"] = 0.0\n\n        # Significance (McNemar) if predictions available\n        if baseline_id and rid != baseline_id and baseline_id in predictions_cache and rid in predictions_cache:\n            y_true_base, y_pred_base = predictions_cache[baseline_id]\n            y_true_other, y_pred_other = predictions_cache[rid]\n            if y_true_base and y_true_other:  # make sure both are non-empty\n                p_val = mcnemar_significance(\n                    y_true_base,\n                    y_pred_base,\n                    y_pred_other,\n                )\n                metrics[\"p_value_vs_baseline\"] = p_val\n            else:\n                metrics[\"p_value_vs_baseline\"] = np.nan\n        else:\n            metrics[\"p_value_vs_baseline\"] = np.nan\n\n    # Save aggregated metrics JSON\n    agg_json = comparison_dir / \"aggregated_metrics.json\"\n    with open(agg_json, \"w\") as f:\n        json.dump(aggregated, f, indent=2)\n    announce(generated_files, agg_json)\n\n    # Bar chart of accuracies + significance stars\n    labels = list(aggregated.keys())\n    accuracies = [aggregated[k][\"top1_accuracy\"] for k in labels]\n    plt.figure(figsize=(8, 4))\n    ax = sns.barplot(x=labels, y=accuracies)\n    for p, acc, rid in zip(ax.patches, accuracies, labels):\n        ax.annotate(f\"{acc:.2f}\", (p.get_x() + p.get_width() / 2, acc),\n                    ha=\"center\", va=\"bottom\")\n        if rid != baseline_id:\n            p_val = aggregated[rid].get(\"p_value_vs_baseline\", np.nan)\n            if not np.isnan(p_val) and p_val \u003c 0.05:\n                ax.annotate(\"*\", (p.get_x() + p.get_width() / 2, acc + 1.5),\n                            ha=\"center\", va=\"bottom\", fontsize=14, color=\"red\")\n    plt.ylabel(\"Top-1 Accuracy (%)\")\n    plt.title(\"Accuracy comparison ( * : p \u003c 0.05 vs baseline )\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    bar_path = comparison_dir / \"top1_accuracy_comparison.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    announce(generated_files, bar_path)\n\n    # Improvement rate plot\n    if len(aggregated) \u003e= 2:\n        imp_labels = [l for l in labels if l != baseline_id]\n        improvement_rates = [aggregated[l][\"improvement_rate\"] * 100 for l in imp_labels]\n        plt.figure(figsize=(8, 4))\n        ax2 = sns.barplot(x=imp_labels, y=improvement_rates, color=\"skyblue\")\n        for p, imp in zip(ax2.patches, improvement_rates):\n            ax2.annotate(f\"{imp:.2f}%\", (p.get_x() + p.get_width() / 2, imp),\n                         ha=\"center\", va=\"bottom\")\n        plt.ylabel(\"Improvement over Baseline (%)\")\n        plt.title(\"Relative improvement vs baseline\")\n        plt.xticks(rotation=45, ha=\"right\")\n        plt.tight_layout()\n        imp_path = comparison_dir / \"improvement_rates.pdf\"\n        plt.savefig(imp_path)\n        plt.close()\n        announce(generated_files, imp_path)\n\n    # ------------------ Summary -------------------------------------------\n    print(\"\\n[Evaluation] Generated artefacts:\")\n    for p in generated_files:\n        print(p)\n\n\nif __name__ == \"__main__\":\n    main()\n", "main_py": "# src/main.py\n\"\"\"Main orchestrator \u2013 launches a single experiment run in a subprocess.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport shlex\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nfrom hydra.core.hydra_config import HydraConfig\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import OmegaConf\n\n###############################################################################\n# Hydra entry-point                                                            #\n###############################################################################\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg):\n    original_cwd = Path(get_original_cwd())\n\n    # Save overall configuration once so evaluate.py can read WandB creds\n    results_dir = Path(cfg.results_dir)\n    results_dir.mkdir(parents=True, exist_ok=True)\n    cfg_path = results_dir / \"config.yaml\"\n    if not cfg_path.exists():\n        OmegaConf.save(config=cfg, f=str(cfg_path))\n\n    # Collect CLI overrides passed to this run (so that they propagate)\n    task_overrides: List[str] = list(HydraConfig.get().overrides.task)\n\n    # Trial mode automatic overrides\n    if cfg.get(\"trial_mode\", False):\n        if \"wandb.mode=disabled\" not in task_overrides:\n            task_overrides.append(\"wandb.mode=disabled\")\n        if \"optuna.n_trials=0\" not in task_overrides:\n            task_overrides.append(\"optuna.n_trials=0\")\n\n    # Ensure results_dir is forwarded\n    if f\"results_dir={cfg.results_dir}\" not in task_overrides:\n        task_overrides.append(f\"results_dir={cfg.results_dir}\")\n\n    launch_cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", *task_overrides]\n\n    env = os.environ.copy()\n    env[\"PYTHONPATH\"] = f\"{original_cwd}:{env.get(\u0027PYTHONPATH\u0027, \u0027\u0027)}\"\n\n    print(\"\\n[Launcher] Executing:\\n  \", \" \".join(map(shlex.quote, launch_cmd)))\n    subprocess.check_call(launch_cmd, env=env)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "# src/model.py\n\"\"\"Model definitions \u0026 utilities.\nAll pre-trained weights are cached under .cache/torch via TORCH_HOME.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# -----------------------------------------------------------------------------\n# Make sure timm / torch.hub use local cache\n# -----------------------------------------------------------------------------\nos.environ.setdefault(\"TORCH_HOME\", \".cache/torch\")\nPath(os.environ[\"TORCH_HOME\"]).mkdir(parents=True, exist_ok=True)\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport timm\n\n###############################################################################\n# Model factory                                                                 \n###############################################################################\n\ndef build_model(model_cfg):\n    \"\"\"Return a pre-trained classification model from timm with correct #classes.\"\"\"\n    model_name = getattr(model_cfg, \"checkpoint\", model_cfg.name)\n    model = timm.create_model(model_name, pretrained=model_cfg.pretrained, num_classes=10)\n    return model\n\n###############################################################################\n# Adaptation utilities                                                         #\n###############################################################################\n\ndef freeze_non_bn_parameters(model: nn.Module):\n    \"\"\"Freeze all parameters except affine parts of BatchNorm layers.\"\"\"\n    for p in model.parameters():\n        p.requires_grad = False\n    for m in model.modules():\n        if isinstance(m, (nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d)):\n            if m.weight is not None:\n                m.weight.requires_grad_(True)\n            if m.bias is not None:\n                m.bias.requires_grad_(True)\n\n\ndef initialize_bn_adaptation(model: nn.Module):\n    \"\"\"Put BN layers in train mode \u0026 disable running-stat tracking (TENT style).\"\"\"\n    for m in model.modules():\n        if isinstance(m, (nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d)):\n            m.train()\n            m.track_running_stats = False\n\n###############################################################################\n# Loss definitions                                                             #\n###############################################################################\n\nclass EntropyLoss(nn.Module):\n    \"\"\"Mean prediction entropy.\"\"\"\n\n    def forward(self, logits: torch.Tensor) -\u003e torch.Tensor:  # noqa: D401\n        probs = F.softmax(logits, dim=1)\n        ent = -(probs * torch.clamp(probs, min=1e-12).log()).sum(dim=1)\n        return ent.mean()\n\n\nclass ConfidenceWeightedEntropyLoss(nn.Module):\n    \"\"\"Confidence-weighted entropy loss (CW-TENT).\"\"\"\n\n    def forward(self, logits: torch.Tensor) -\u003e torch.Tensor:  # noqa: D401\n        probs = F.softmax(logits, dim=1)\n        ent = -(probs * torch.clamp(probs, min=1e-12).log()).sum(dim=1)\n        num_classes = logits.size(1)\n        weights = 1.0 - ent / torch.log(torch.tensor(num_classes, device=logits.device, dtype=ent.dtype))\n        return (weights * ent).sum() / torch.clamp(weights.sum(), min=1e-12)\n", "preprocess_py": "# src/preprocess.py\n\"\"\"Data loading \u0026 preprocessing pipeline for CIFAR-10-C.\"\"\"\n\nfrom __future__ import annotations\n\nimport tarfile\nfrom pathlib import Path\nfrom typing import List, Tuple, Union\n\nimport numpy as np\nimport requests\nfrom PIL import Image\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nfrom torchvision import transforms\n\n###############################################################################\n# Constants                                                                    #\n###############################################################################\n\nCIFAR10C_URL = \"https://zenodo.org/record/3555552/files/CIFAR-10-C.tar?download=1\"\nCORRUPTIONS = [\n    \"gaussian_noise\",\n    \"shot_noise\",\n    \"impulse_noise\",\n    \"defocus_blur\",\n    \"glass_blur\",\n    \"motion_blur\",\n    \"zoom_blur\",\n    \"snow\",\n    \"frost\",\n    \"fog\",\n    \"brightness\",\n    \"contrast\",\n    \"elastic_transform\",\n    \"pixelate\",\n    \"jpeg_compression\",\n]\n\n###############################################################################\n# Low-level utilities                                                          #\n###############################################################################\n\ndef _download(url: str, dst: Path):\n    dst.parent.mkdir(parents=True, exist_ok=True)\n    with requests.get(url, stream=True) as r:\n        r.raise_for_status()\n        total = int(r.headers.get(\"content-length\", 0))\n        with open(dst, \"wb\") as f, tqdm(total=total, unit=\"iB\", unit_scale=True, desc=\"CIFAR-10-C\") as bar:\n            for chunk in r.iter_content(chunk_size=1024 * 1024):\n                if chunk:\n                    f.write(chunk)\n                    bar.update(len(chunk))\n\n\ndef _download_and_extract(url: str, cache_dir: Path) -\u003e Path:\n    tar_path = cache_dir / \"CIFAR-10-C.tar\"\n    extract_dir = cache_dir / \"CIFAR-10-C\"\n    if not extract_dir.exists():\n        if not tar_path.exists():\n            print(f\"Downloading CIFAR-10-C to {tar_path} \u2026\")\n            _download(url, tar_path)\n        print(f\"Extracting {tar_path} \u2026\")\n        with tarfile.open(tar_path) as tar:\n            tar.extractall(path=cache_dir)\n    return extract_dir\n\n###############################################################################\n# Dataset wrapper                                                              #\n###############################################################################\n\nclass NumpyArrayDataset(Dataset):\n    \"\"\"Thin Dataset around CIFAR-10-C numpy arrays.\"\"\"\n\n    def __init__(self, images: np.ndarray, labels: np.ndarray, transform=None):\n        assert len(images) == len(labels)\n        self.images = images\n        self.labels = labels.astype(np.int64)\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.images)\n\n    def __getitem__(self, idx):\n        img = Image.fromarray(self.images[idx])\n        label = int(self.labels[idx])\n        if self.transform is not None:\n            img = self.transform(img)\n        return img, label\n\n###############################################################################\n# Public API                                                                   #\n###############################################################################\n\ndef load_cifar10c(\n    *,\n    severity: int = 5,\n    corruption_types: Union[str, List[str]] = \"all\",\n    cache_dir: Path = Path(\".cache/datasets/cifar10_c\"),\n) -\u003e Tuple[np.ndarray, np.ndarray]:\n    if not 1 \u003c= severity \u003c= 5:\n        raise ValueError(\"Severity must be within [1,5]\")\n\n    extract_dir = _download_and_extract(CIFAR10C_URL, cache_dir)\n\n    if corruption_types == \"all\":\n        corruption_types = CORRUPTIONS\n\n    images_list = []\n    labels_base = np.load(extract_dir / \"labels.npy\")\n    start = (severity - 1) * 10_000\n    end = severity * 10_000\n\n    for corr in corruption_types:\n        corr_arr = np.load(extract_dir / f\"{corr}.npy\")\n        images_list.append(corr_arr[start:end])\n    images = np.concatenate(images_list, axis=0)\n    labels_full = np.tile(labels_base[start:end], len(corruption_types))\n    return images, labels_full\n\n\ndef build_dataloader(dataset_cfg, *, split: str = \"test\", cache_dir: str = \".cache/\") -\u003e DataLoader:\n    cache_path = Path(cache_dir)\n\n    if dataset_cfg.name.lower() == \"cifar-10-c\":\n        imgs, lbls = load_cifar10c(\n            severity=dataset_cfg.severity,\n            corruption_types=dataset_cfg.corruption_types,\n            cache_dir=cache_path / \"cifar10_c\",\n        )\n        transform = transforms.Compose(\n            [\n                transforms.ToTensor(),\n                transforms.Normalize(mean=dataset_cfg.normalization.mean, std=dataset_cfg.normalization.std),\n            ]\n        )\n        ds = NumpyArrayDataset(imgs, lbls, transform)\n        return DataLoader(ds, batch_size=dataset_cfg.batch_size, shuffle=False, num_workers=4, pin_memory=True)\n\n    raise ValueError(f\"Unsupported dataset: {dataset_cfg.name}\")\n", "pyproject_toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cw_tent_experiments\"\nversion = \"0.1.0\"\ndescription = \"Confidence-Weighted TENT experiments with Hydra \u0026 WandB\"\nauthors = [\n  {name = \"AI Autogenerated\", email = \"noreply@example.com\"}\n]\nrequires-python = \"\u003e=3.8\"\n\n[project.dependencies]\n# Core deep-learning stack\ntorch = \"*\"\ntorchvision = \"*\"\ntimm = \"*\"\n\n# Experiment management\nhydra-core = \"*\"\noptuna = \"*\"\nwandb = \"*\"\n\n# Data \u0026 plotting\nnumpy = \"*\"\npandas = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nscikit-learn = \"*\"\nscipy = \"*\"\nPillow = \"*\"\nrequests = \"*\"\nPyYAML = \"*\"\ntqdm = \"*\"\n", "train_py": "# src/train.py\n\"\"\"Training script executed as a subprocess by main.py\nFully\u2013featured CW-TENT / baseline TENT implementation with Optuna HPO\nand exhaustive WandB logging.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom typing import Dict, Any, List\n\n# ----------------------------------------------------------------------------\n# Enforce local caching *before* loading any library that might download data\n# ----------------------------------------------------------------------------\nos.environ.setdefault(\"TORCH_HOME\", \".cache/torch\")\n\nimport copy\nimport hydra\nimport optuna\nimport torch\nimport torch.nn.functional as F\nimport wandb\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import OmegaConf\n\nfrom src.model import (\n    build_model,\n    freeze_non_bn_parameters,\n    initialize_bn_adaptation,\n    EntropyLoss,\n    ConfidenceWeightedEntropyLoss,\n)\nfrom src.preprocess import build_dataloader\n\n###############################################################################\n# Metrics helpers                                                              #\n###############################################################################\n\ndef topk_acc(output: torch.Tensor, target: torch.Tensor, k: int = 1) -\u003e float:  # noqa: D401\n    \"\"\"Compute Top-k accuracy (%) for a single batch.\"\"\"\n    with torch.no_grad():\n        maxk = k\n        batch_size = target.size(0)\n        _, pred = output.topk(maxk, 1, True, True)\n        pred = pred.t()\n        correct_k = pred.eq(target.view(1, -1).expand_as(pred))[:k].reshape(-1)\n        return float(correct_k.float().sum().item()) * 100.0 / batch_size\n\n\n###############################################################################\n# Core adaptation routine                                                      #\n###############################################################################\n\ndef run_single(cfg, *, enable_wandb: bool = True) -\u003e float:  # noqa: C901\n    \"\"\"Run a single test-time adaptation pass and return final accuracy.\"\"\"\n\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ----------------- WandB initialisation --------------------------------\n    if enable_wandb and cfg.wandb.mode != \"disabled\":\n        wandb_run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            config=OmegaConf.to_container(cfg, resolve=True),\n            resume=\"allow\",\n            reinit=True,\n        )\n        print(f\"[WandB] Run URL: {wandb_run.url}\")\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n        wandb_run = None\n\n    # ----------------- Data -------------------------------------------------\n    dataloader = build_dataloader(cfg.dataset, split=\"test\", cache_dir=\".cache/\")\n\n    # ----------------- Model \u0026 optimiser -----------------------------------\n    model = build_model(cfg.model).to(device)\n    model.eval()\n    freeze_non_bn_parameters(model)\n    initialize_bn_adaptation(model)\n\n    params_to_opt = filter(lambda p: p.requires_grad, model.parameters())\n\n    opt_name = cfg.training.optimizer.lower()\n    if opt_name == \"sgd\":\n        optimizer = torch.optim.SGD(\n            params_to_opt,\n            lr=cfg.training.learning_rate,\n            momentum=cfg.training.momentum,\n            weight_decay=cfg.training.weight_decay,\n        )\n    elif opt_name == \"adam\":\n        optimizer = torch.optim.Adam(\n            params_to_opt,\n            lr=cfg.training.learning_rate,\n            weight_decay=cfg.training.weight_decay,\n        )\n    else:\n        raise ValueError(f\"Unsupported optimizer {opt_name}\")\n\n    if cfg.training.loss == \"entropy\":\n        criterion = EntropyLoss()\n    elif cfg.training.loss == \"confidence_weighted_entropy\":\n        criterion = ConfidenceWeightedEntropyLoss()\n    else:\n        raise ValueError(f\"Unsupported loss {cfg.training.loss}\")\n\n    # ----------------- Adaptation loop -------------------------------------\n    global_step = 0\n    all_preds: List[int] = []\n    all_targets: List[int] = []\n\n    trial_mode: bool = bool(cfg.get(\"trial_mode\", False))\n\n    for epoch in range(cfg.training.epochs):\n        for batch_idx, (images, targets) in enumerate(dataloader):\n            if trial_mode and batch_idx \u003e= 2:  # speed-up CI check\n                break\n\n            images = images.to(device, non_blocking=True)\n            targets = targets.to(device, non_blocking=True)\n\n            # === Inner optimisation steps (TENT/TENT-CW) ===\n            model.train()\n            for _ in range(cfg.training.inner_steps):\n                optimizer.zero_grad(set_to_none=True)\n                logits_in = model(images)\n                loss = criterion(logits_in)\n                loss.backward()\n                optimizer.step()\n            model.eval()\n\n            # Predictions AFTER adaptation step (this is what users care about)\n            with torch.no_grad():\n                logits_out = model(images)\n            preds = logits_out.argmax(dim=1)\n            acc1 = topk_acc(logits_out, targets, k=1)\n\n            # Accumulate for confusion matrix \u0026 significance tests\n            all_preds.extend(preds.cpu().tolist())\n            all_targets.extend(targets.cpu().tolist())\n\n            if wandb_run is not None:\n                wandb.log(\n                    {\n                        \"train_loss\": float(loss.item()),\n                        \"top1_batch_acc\": float(acc1),\n                        \"epoch\": epoch,\n                    },\n                    step=global_step,\n                )\n            global_step += 1\n\n    all_preds_t = torch.tensor(all_preds)\n    all_targets_t = torch.tensor(all_targets)\n    final_acc = 100.0 * (all_preds_t == all_targets_t).float().mean().item()\n    print(f\"[RESULT] Run {cfg.run.run_id} \u2014 final Top-1 Acc: {final_acc:.2f}%\")\n\n    if wandb_run is not None:\n        # Store aggregate results + full prediction arrays\n        wandb_run.summary[\"top1_accuracy\"] = float(final_acc)\n        wandb_run.summary[\"y_true\"] = all_targets  # lists of ints\n        wandb_run.summary[\"y_pred\"] = all_preds\n        wandb_run.finish()\n\n    return float(final_acc)\n\n\n###############################################################################\n# Optuna utilities                                                             #\n###############################################################################\n\ndef _suggest_from_space(trial: optuna.Trial, space: Dict[str, Dict[str, Any]]):\n    params = {}\n    for name, spec in space.items():\n        if spec[\"type\"] == \"loguniform\":\n            params[name] = trial.suggest_float(name, spec[\"low\"], spec[\"high\"], log=True)\n        elif spec[\"type\"] == \"uniform\":\n            params[name] = trial.suggest_float(name, spec[\"low\"], spec[\"high\"], log=False)\n        elif spec[\"type\"] == \"categorical\":\n            params[name] = trial.suggest_categorical(name, spec[\"choices\"])\n        else:\n            raise ValueError(f\"Unsupported Optuna param type {spec[\u0027type\u0027]}\")\n    return params\n\n\ndef _apply_trial_params(cfg, params: Dict[str, Any]):\n    for k, v in params.items():\n        if hasattr(cfg.training, k):\n            setattr(cfg.training, k, v)\n        elif hasattr(cfg.dataset, k):\n            setattr(cfg.dataset, k, v)\n\n\n###############################################################################\n# Hydra entry-point                                                            #\n###############################################################################\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg):  # noqa: C901\n    # ---------------- Trial-mode overrides ---------------------------------\n    if bool(cfg.get(\"trial_mode\", False)):\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.training.epochs = 1\n\n    # Make sure cache folders exist\n    Path(\".cache/torch\").mkdir(parents=True, exist_ok=True)\n    Path(\".cache/datasets\").mkdir(parents=True, exist_ok=True)\n\n    # ---------------- Hyper-parameter optimisation -------------------------\n    if cfg.optuna.n_trials \u003e 0:\n        print(f\"[Optuna] Running {cfg.optuna.n_trials} trials \u2026\")\n\n        def objective(trial: optuna.Trial) -\u003e float:\n            cfg_trial = OmegaConf.create(OmegaConf.to_container(cfg, resolve=True))\n            params = _suggest_from_space(trial, cfg_trial.optuna.search_space)\n            _apply_trial_params(cfg_trial, params)\n            cfg_trial.wandb.mode = \"disabled\"  # no WandB during search\n            return run_single(cfg_trial, enable_wandb=False)\n\n        study = optuna.create_study(direction=cfg.optuna.direction)\n        study.optimize(objective, n_trials=cfg.optuna.n_trials)\n        print(f\"[Optuna] Best value = {study.best_value:.4f}\\n[Optuna] Best params = {study.best_params}\")\n        _apply_trial_params(cfg, study.best_params)\n\n    # ---------------- Final run -------------------------------------------\n    run_single(cfg, enable_wandb=(cfg.wandb.mode != \"disabled\"))\n\n\nif __name__ == \"__main__\":\n    main()\n"}

Analyze the experiment code thoroughly. Ensure it is complete, executable, and ready for publication-quality research experiments.
Output:
{
    "is_code_ready": false,
    "code_issue": "Hydra integration is incorrect – config/config.yaml defines `run: {}` (and likewise for model, dataset, training, optuna), therefore the override syntax required by the CLI (`run={run_id}`) will NOT load the corresponding file from config/run/*.yaml; instead it will try to assign the string value to an existing dict node and crash. A proper Hydra config group must be declared in defaults, e.g. `- run: ???`, and the placeholder keys removed. Until the defaults list exposes the run (and other) config groups, `src.main` and `src.train` cannot be executed with the specified command. All other criteria appear satisfied, but this issue blocks immediate execution."
}
