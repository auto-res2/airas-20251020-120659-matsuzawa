
LLM Name: o3-2025-04-16
Input:
You are an AI code reviewer validating production-ready experiment code for research papers.

Analyze the provided experiment code and determine if it meets all requirements for immediate execution in research experiments.

# Instructions

## Core Validation Criteria
Check if the generated experiment code meets ALL of the following requirements:

1. **Complete Implementation**:
   - Every component is fully functional, production-ready, publication-worthy code
   - No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
   - All functions and classes are completely implemented
   - No truncated code sections or incomplete implementations

2. **Hydra Integration**:
   - Uses Hydra to manage all experiment configurations from `config/run/*.yaml` files
   - All parameters are loaded from run configs dynamically
   - Proper configuration structure with run_id, method, model, dataset, training, and optuna sections
   - CLI interface matches:
     * Training: `uv run python -u -m src.main run={run_id} results_dir={path}`
     * Evaluation: `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'` (independent execution)
   - Supports trial_mode=true flag for lightweight validation runs (automatically disables WandB)

3. **Complete Data Pipeline**:
   - Full data loading and preprocessing implementation
   - Dataset-specific preprocessing is properly implemented
   - No placeholder dataset loading code
   - Proper error handling for data operations
   - Uses `.cache/` as the cache directory for all datasets and models

4. **Model Implementation**:
   - Complete model architectures for all methods (proposed and comparative methods)
   - No placeholders (TODO, PLACEHOLDER, pass, or incomplete implementations)
   - When External Resources specify HuggingFace models: properly use and customize them (acceptable to wrap AutoModel, add adapters, etc.)
   - When no external models specified: implement architectures from scratch using PyTorch primitives
   - Model-specific configurations correctly applied
   - Proper PyTorch usage throughout

5. **File Structure Compliance**:
   - Contains EXACTLY these required files (and NO other files):
     * `src/train.py`
     * `src/evaluate.py`
     * `src/preprocess.py`
     * `src/model.py`
     * `src/main.py`
     * `pyproject.toml`
     * `config/config.yaml`
   - NO additional files (e.g., NO `src/__init__.py`, NO `setup.py`, NO other Python files)
   - No missing files from the structure
   - All functionality contained within specified files

6. **WandB Integration**:
   - train.py initializes WandB and logs ALL metrics using `wandb.log()`
   - trial_mode automatically disables WandB (sets wandb.mode=disabled)
   - NO results.json or stdout JSON dumps in train.py
   - config/config.yaml contains mandatory WandB settings (entity/project)

7. **Configuration Files**:
   - The generated code properly references config files via Hydra
   - NOTE: config/run/{run_id}.yaml files are provided separately (not in ExperimentCode)
   - All run configurations match the experiment_runs provided
   - Optuna search spaces are properly defined if applicable

8. **Evaluation Script Independence**:
   - evaluate.py is executed independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
   - Accepts `run_ids` parameter as JSON string list (parse with `json.loads(args.run_ids)`)
   - main.py DOES NOT call evaluate.py
   - evaluate.py retrieves ALL data from WandB API using `wandb.Api()` (not from local files)
   - **STEP 1: Per-Run Processing** (for each run_id):
     * Export run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
     * Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
     * Each run should have its own subdirectory with its metrics and figures
   - **STEP 2: Aggregated Analysis** (after processing all runs):
     * Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
     * Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
     * Generate comparison figures to: `{results_dir}/comparison/`
     * Cross-run comparison charts (bar charts, box plots)
     * Performance metrics tables
     * Statistical significance tests
   - Proper figure quality: legends, annotations, tight_layout
   - Follows naming convention: `<figure_topic>[_<condition>][_pairN].pdf`
   - train.py and main.py generate NO figures
   - evaluate.py cannot run in trial_mode (no WandB data available when WandB disabled)

9. **Trial Mode Implementation**:
   - trial_mode=true flag properly reduces computational load
   - Training: epochs=1, batches limited to 1-2, Optuna disabled (n_trials=0), small evaluation subset
   - WandB automatically disabled in trial_mode (wandb.mode=disabled)
   - Purpose: Fast validation that code runs without errors

## Output Format
Respond with a JSON object containing:
- `is_code_ready`: boolean - true if ALL criteria are met, false otherwise
- `code_issue`: string - specific issues found if any criteria are not met, focusing on what needs to be fixed

# Current Research Method
{
    "Open Problems": "Most popular test-time adaptation (TTA) methods such as TENT adapt only BatchNorm affine parameters by minimizing prediction entropy on the incoming test stream. Although very effective, they often require 3-10 gradient steps for each incoming mini-batch to reach their best performance. The slow convergence mainly comes from noisy gradients produced by low-confidence (high-entropy) samples that dominate early in adaptation. A simple mechanism to down-weight these uncertain samples during optimization is missing.",
    "Methods": "Confidence-Weighted Entropy Minimization (CW-TENT).\n1. Keep the original TENT objective L = Σ_i H(p_i) where H is entropy.\n2. Introduce a scalar weight per sample w_i = 1 – H(p_i)/log(C)  (ranges in [0,1]; C = #classes).\n3. Replace the loss with the weighted variant  L_w = Σ_i w_i · H(p_i) / Σ_i w_i.\n4. Use the same SGD update of BatchNorm affine parameters, but with a single gradient step per mini-batch (optionally with momentum=0.9).\nTheoretical intuition: high-confidence samples (low entropy) are already close to the target domain optimum and provide reliable gradients; amplifying their contribution yields a cleaner gradient direction, allowing larger learning rate or fewer steps, hence faster convergence.",
    "Experimental Setup": "Dataset: CIFAR-10-C with 15 corruption types, severity 5 (standard TTA benchmark).\nModel: Pre-trained ResNet-18.\nBaselines: 1) Source model (no adaptation). 2) Original TENT (default 10 inner steps). 3) CW-TENT (1 inner step).\nMetric: Top-1 accuracy after processing the full test stream; also accuracy after first K (e.g., 1, 3) adaptation steps to measure convergence speed.",
    "Experimental Code": "import torch, torch.nn.functional as F\n\ndef entropy(p):\n    return -(p * p.log()).sum(1)\n\nclass CWTentAdapter:\n    def __init__(self, model, lr=1e-3, momentum=0.9):\n        self.model = model.eval()\n        self.model.requires_grad_(False)\n        # enable gradients for affine BN params only\n        for m in model.modules():\n            if isinstance(m, torch.nn.BatchNorm2d):\n                m.weight.requires_grad_(True)\n                m.bias.requires_grad_(True)\n        self.optimizer = torch.optim.SGD(filter(lambda p: p.requires_grad, model.parameters()), lr=lr, momentum=momentum)\n\n    @torch.no_grad()\n    def predict(self, x):\n        return self.model(x).softmax(1)\n\n    def adapt(self, x):\n        self.model.train()        # BN uses batch statistics\n        self.optimizer.zero_grad()\n        logits = self.model(x)\n        probs = logits.softmax(1)\n        H = entropy(probs)\n        w = 1 - H / torch.log(torch.tensor(probs.size(1), device=x.device))\n        loss = (w * H).sum() / w.sum()\n        loss.backward()\n        self.optimizer.step()\n        self.model.eval()\n        return probs.detach()\n",
    "Expected Result": "With only one gradient step per mini-batch, CW-TENT is expected to match or surpass the accuracy of TENT that uses 5–10 steps. For example on CIFAR-10-C severity 5: Source 58.7%, TENT (10 steps) 71.0%, CW-TENT (1 step) ≈71.5%. Convergence plot should show CW-TENT reaching peak accuracy after the first step, whereas TENT needs several.",
    "Expected Conclusion": "A tiny modification—confidence-weighted entropy—suppresses noisy gradients from uncertain samples and lets TENT converge in a single step. The change is trivial to implement (four extra lines) yet meaningfully cuts computation and latency at test time, making TTA more practical for real-time deployment."
}

# Experimental Design
- Strategy: The experiment demonstrates that Confidence-Weighted TENT (CW-TENT) enables fast, one-step test-time adaptation by down-weighting high-entropy (low-confidence) samples in the classic entropy-minimisation objective used by TENT. A pre-trained ResNet-18 is sequentially exposed to the CIFAR-10-C corruption stream (severity-5). At every incoming mini-batch the model first produces predictions, then performs one SGD update on BatchNorm affine parameters using the confidence-weighted entropy loss. Performance is evaluated as the stream proceeds and compared against: (1) the frozen source model (no adaptation) and (2) the original TENT that applies 10 inner optimisation steps. All runs share identical data order, initial weights and hardware (8×H200, 144 GB each). Hyper-parameter sweeps on learning-rate, momentum and weight-decay are carried out with random search (30 trials) on a held-out corruption set to obtain fair settings for both CW-TENT and the baseline.
- Proposed Method: Confidence-Weighted Entropy Minimisation (CW-TENT)
Objective: Accelerate, stabilise and computationally lighten test-time adaptation by re-weighting each sample’s entropy according to its prediction confidence.
Theoretical intuition: Samples with low entropy are nearer to the target optimum and thus deliver cleaner gradient signals. Emphasising them suppresses noise from uncertain samples appearing early in the stream, allowing convergence in a single step.
Algorithm:
1. Observation x → logits z = f_θ(x) (θ frozen except BN γ,β).
2. Compute probabilities p = softmax(z) and entropy H_i = −Σ_c p_{ic} log p_{ic}.
3. Compute weight w_i = 1 − H_i / log C (C = number of classes). Range [0,1].
4. Weighted loss: L_w = Σ_i w_i H_i / Σ_i w_i.
5. Perform one SGD step on BN affine parameters only (lr≈1e-3, momentum≈0.9).
6. Switch model back to eval mode and continue streaming.
Implementation additions over TENT:
• 3 lines to calculate w_i and replace loss.
• Inner-loop steps fixed to 1, cutting compute 10×.
Complexities: O(B) extra operations per batch for weight computation – negligible compared with forward/backward passes.
- Evaluation Metrics: ['Top-1 Accuracy', 'Average Accuracy After First Adaptation Step']

# Experiment Runs

- Run ID: proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: proposed
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  
  Config Content:
  ```yaml
  run_id: 'proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)'
method: cw-tent
model:
  name: resnet18
  pretrained_checkpoint: timm/resnet18.a1_in1k
  num_parameters_m: 11.7
  num_classes: 10
  freeze_except:
    - BatchNorm.weight
    - BatchNorm.bias
dataset:
  name: cifar10c
  root: /datasets/CIFAR-10-C
  corruption_severity: 5
  corruption_types: all
  split: test
  batch_size: 64
  num_workers: 8
  preprocessing:
    normalize:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2023, 0.1994, 0.2010]
training:
  adaptation: true
  objective: confidence_weighted_entropy
  inner_steps: 1
  learning_rate: 0.001
  momentum: 0.9
  weight_decay: 0.0
  optimizer: sgd
  epochs: 1
  scheduler: none
  gradient_clip: null
  stream_mode: sequential
  log_interval: 50
optuna:
  enabled: true
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
hardware:
  gpus: 8
  gpu_type: NVIDIA H200
  vram_per_gpu_gb: 144
  mixed_precision: true
seed: 42

  ```
  

- Run ID: comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: comparative-1
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  
  Config Content:
  ```yaml
  run_id: 'comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)'
method: tent
model:
  name: resnet18
  pretrained_checkpoint: timm/resnet18.a1_in1k
  num_parameters_m: 11.7
  num_classes: 10
  freeze_except:
    - BatchNorm.weight
    - BatchNorm.bias
dataset:
  name: cifar10c
  root: /datasets/CIFAR-10-C
  corruption_severity: 5
  corruption_types: all
  split: test
  batch_size: 64
  num_workers: 8
  preprocessing:
    normalize:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2023, 0.1994, 0.2010]
training:
  adaptation: true
  objective: entropy
  inner_steps: 10
  learning_rate: 0.0005
  momentum: 0.9
  weight_decay: 0.0
  optimizer: sgd
  epochs: 1
  scheduler: none
  gradient_clip: null
  stream_mode: sequential
  log_interval: 50
optuna:
  enabled: true
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
    inner_steps:
      type: categorical
      choices: [1, 3, 5, 10]
hardware:
  gpus: 8
  gpu_type: NVIDIA H200
  vram_per_gpu_gb: 144
  mixed_precision: true
seed: 42

  ```
  


# Generated Experiment Code (To be validated)
{"config_yaml": "# config/config.yaml\n# -----------------------------------------------------------------------------\n# Global defaults (can be overridden from CLI or run/*.yaml) -------------------\n# -----------------------------------------------------------------------------\n\ndefaults:\n  - _self_\n  - run: default  # placeholder \u2013 must be overridden e.g. run=proposed-ResNet\n\nseed: 42\ntrial_mode: false\nresults_dir: ./results  # path is resolved relative to repo root by main.py\n\n# -----------------------------------------------------------------------------\n# Weights \u0026 Biases -------------------------------------------------------------\n# -----------------------------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online  # automatically switched to \"disabled\" in trial_mode\n\n# -----------------------------------------------------------------------------\n# Hardware settings ------------------------------------------------------------\n# -----------------------------------------------------------------------------\nhardware:\n  gpus: 1\n  mixed_precision: true\n\n# -----------------------------------------------------------------------------\n# Placeholder dataset group (overridden by run configs) ------------------------\n# -----------------------------------------------------------------------------\ndataset:\n  name: cifar10c\n  root: /path/to/cifar10c\n  corruption_severity: 5\n  corruption_types: all\n  batch_size: 64\n  num_workers: 4\n  preprocessing:\n    normalize:\n      mean: [0.4914, 0.4822, 0.4465]\n      std:  [0.2023, 0.1994, 0.2010]\n\n# -----------------------------------------------------------------------------\n# Generic training hyper-parameters (may be overridden) -----------------------\n# -----------------------------------------------------------------------------\ntraining:\n  adaptation: false\n  objective: entropy\n  inner_steps: 1\n  learning_rate: 0.001\n  optimizer: sgd\n  momentum: 0.9\n  weight_decay: 0.0\n  epochs: 1\n  gradient_clip: null\n  log_interval: 50\n\n# -----------------------------------------------------------------------------\n# Placeholder optuna group -----------------------------------------------------\n# -----------------------------------------------------------------------------\noptuna:\n  enabled: false\n  n_trials: 0\n  direction: maximize\n  metric: top1_accuracy\n\n# -----------------------------------------------------------------------------\n# Run-specific placeholder -----------------------------------------------------\n# -----------------------------------------------------------------------------\nrun:\n  run_id: default\n  method: baseline\n  model:\n    name: resnet18\n    num_classes: 10\n    freeze_except: [\"bn\", \"BatchNorm.weight\", \"BatchNorm.bias\"]\n\n", "evaluate_py": "# src/evaluate.py\n\"\"\"Independent evaluation / visualisation script.\n\nExample CLI:\n    uv run python -m src.evaluate results_dir=./results run_ids=\u0027[\"run-1\", \"run-2\"]\u0027\n\nThis script is *NOT* called from `src.main`.  It fetches metrics for each run\nfrom the WandB API, stores per-run artefacts and produces cross-run comparison\nfigures including statistical significance tests.\n\"\"\"\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy import stats\n\n# -----------------------------------------------------------------------------\n# CLI parsing (key=value style because Hydra-like invocation is required) ------\n# -----------------------------------------------------------------------------\n\ndef _parse_kv_cli() -\u003e Dict[str, str]:\n    \"\"\"Return a dict mapping `key` -\u003e `value` for CLI args like `key=value`.\"\"\"\n    cli_kv = {}\n    for arg in sys.argv[1:]:\n        if \"=\" not in arg:\n            raise ValueError(\n                f\"Unexpected argument format: \u0027{arg}\u0027. Expected key=value pairs.\")\n        k, v = arg.split(\"=\", 1)\n        cli_kv[k] = v\n    required = {\"results_dir\", \"run_ids\"}\n    missing = required - cli_kv.keys()\n    if missing:\n        raise ValueError(f\"Missing required CLI keys: {missing}\")\n    return cli_kv\n\n# -----------------------------------------------------------------------------\n# WandB helpers ----------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef _load_wandb_config(results_dir: Path) -\u003e Dict:\n    cfg_path = results_dir / \"config.yaml\"\n    if not cfg_path.exists():\n        raise FileNotFoundError(\n            f\"Expected {cfg_path} (copied by main.py) but file does not exist.\")\n    with cfg_path.open(\"r\") as f:\n        return yaml.safe_load(f)\n\n# -----------------------------------------------------------------------------\n# Per-run processing -----------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef _export_metrics(df: pd.DataFrame, out_file: Path) -\u003e None:\n    df.to_json(out_file, orient=\"records\", lines=True)\n\n\ndef _plot_learning_curves(df: pd.DataFrame, run_id: str, out_dir: Path) -\u003e List[Path]:\n    figs = []\n    metrics_to_plot = [c for c in [\"batch_accuracy\", \"adapt_loss\", \"top1_accuracy\"] if c in df.columns]\n    for metric in metrics_to_plot:\n        plt.figure(figsize=(6, 4))\n        sns.lineplot(data=df, x=df.index, y=metric)\n        plt.title(f\"{run_id} \u2013 {metric}\")\n        plt.xlabel(\"Step\")\n        plt.ylabel(metric)\n        if df[metric].dropna().size:\n            final_val = df[metric].dropna().iloc[-1]\n            plt.annotate(f\"{final_val:.4f}\", xy=(df.index[-1], final_val), xytext=(-40, 10), textcoords=\"offset points\")\n        plt.tight_layout()\n        fig_path = out_dir / f\"learning_curve_{metric}.pdf\"\n        plt.savefig(fig_path)\n        plt.close()\n        figs.append(fig_path)\n    return figs\n\n\ndef _plot_confusion_matrix(conf_mat: np.ndarray, class_names: List[str], title: str, out_path: Path) -\u003e None:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(conf_mat, annot=True, fmt=\"d\", cmap=\"Blues\", xticklabels=class_names, yticklabels=class_names)\n    plt.ylabel(\"True label\")\n    plt.xlabel(\"Predicted label\")\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\ndef per_run_processing(api: wandb.Api, entity: str, project: str, run_id: str, run_dir: Path, class_names: List[str]) -\u003e Dict:\n    run = api.run(f\"{entity}/{project}/{run_id}\")\n    history_df = run.history(pandas=True)\n\n    # --- Save raw metrics -------------------------------------------------\n    _export_metrics(history_df, run_dir / \"metrics.json\")\n\n    # --- Plots ------------------------------------------------------------\n    fig_paths = _plot_learning_curves(history_df, run_id, run_dir)\n\n    # Confusion matrix: prefer run.summary, fall back to local NPY ----------\n    conf_mat = None\n    if \"conf_mat\" in run.summary:\n        conf_mat = np.array(run.summary[\"conf_mat\"], dtype=int)\n    else:\n        local_conf = run_dir / \"confusion_matrix.npy\"\n        if local_conf.exists():\n            conf_mat = np.load(local_conf)\n    if conf_mat is not None:\n        cm_path = run_dir / \"confusion_matrix.pdf\"\n        _plot_confusion_matrix(conf_mat, class_names, f\"{run_id} \u2013 Confusion Matrix\", cm_path)\n        fig_paths.append(cm_path)\n\n    # --- Collect aggregate stats -----------------------------------------\n    final_acc = history_df.get(\"top1_accuracy\", pd.Series(dtype=float)).dropna()\n    final_acc_value = float(final_acc.iloc[-1]) if not final_acc.empty else None\n    best_acc_value = float(final_acc.max()) if not final_acc.empty else None\n\n    print(f\"[Per-run] generated files for {run_id}:\")\n    for p in fig_paths:\n        print(\"  \u2022\", p)\n\n    return {\n        \"run_id\": run_id,\n        \"final_accuracy\": final_acc_value,\n        \"best_accuracy\": best_acc_value,\n        \"num_steps\": len(history_df),\n    }\n\n# -----------------------------------------------------------------------------\n# Aggregated analysis ---------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef aggregated_analysis(per_run_stats: List[Dict], api: wandb.Api, entity: str, project: str, results_dir: Path, run_ids: List[str]) -\u003e None:\n    comp_dir = results_dir / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    # --- Save table -------------------------------------------------------\n    agg_path = comp_dir / \"aggregated_metrics.json\"\n    with agg_path.open(\"w\") as f:\n        json.dump(per_run_stats, f, indent=2)\n    print(\"Aggregated metrics saved to\", agg_path)\n\n    # --- Bar chart of final accuracies -----------------------------------\n    df = pd.DataFrame(per_run_stats)\n    plt.figure(figsize=(8, 4))\n    sns.barplot(data=df, x=\"run_id\", y=\"final_accuracy\", palette=\"viridis\")\n    plt.xticks(rotation=45, ha=\"right\")\n    for idx, row in df.iterrows():\n        plt.text(idx, row[\"final_accuracy\"] + 0.2, f\"{row[\u0027final_accuracy\u0027]:.2f}\", ha=\"center\")\n    plt.ylabel(\"Final Top-1 Accuracy\")\n    plt.title(\"Final Accuracy across Runs\")\n    plt.tight_layout()\n    bar_path = comp_dir / \"final_accuracy_comparison.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    print(\"Created\", bar_path)\n\n    # --- Statistical significance tests (paired per-batch accuracy) -------\n    # Retrieve per-batch accuracy history for the first two runs (if \u003e=2)\n    if len(run_ids) \u003e= 2:\n        histories = []\n        for rid in run_ids[:2]:\n            run = api.run(f\"{entity}/{project}/{rid}\")\n            df_hist = run.history(pandas=True)\n            histories.append(df_hist.get(\"batch_accuracy\", pd.Series(dtype=float)).dropna().values)\n        min_len = min(len(h) for h in histories)\n        a, b = histories[0][:min_len], histories[1][:min_len]\n        t_stat, t_p = stats.ttest_rel(a, b)\n        w_stat, w_p = stats.wilcoxon(a, b)\n        stats_dict = {\n            \"paired_ttest\": {\"t_stat\": float(t_stat), \"p_value\": float(t_p)},\n            \"wilcoxon\": {\"stat\": float(w_stat), \"p_value\": float(w_p)},\n        }\n        stats_path = comp_dir / \"significance_tests.json\"\n        with stats_path.open(\"w\") as f:\n            json.dump(stats_dict, f, indent=2)\n        print(\"Statistical tests saved to\", stats_path)\n\n    print(\"[Comparison] outputs written to\", comp_dir)\n\n# -----------------------------------------------------------------------------\n# Main ------------------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef main() -\u003e None:\n    cli_kv = _parse_kv_cli()\n    results_dir = Path(cli_kv[\"results_dir\"]).expanduser().resolve()\n    run_ids = json.loads(cli_kv[\"run_ids\"])  # list-of-str\n\n    wandb_cfg = _load_wandb_config(results_dir)\n    entity = wandb_cfg[\"wandb\"][\"entity\"]\n    project = wandb_cfg[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n    class_names = [str(i) for i in range(10)]  # CIFAR-10 default\n\n    per_run_stats = []\n    for run_id in run_ids:\n        run_dir = results_dir / run_id\n        run_dir.mkdir(parents=True, exist_ok=True)\n        stats = per_run_processing(api, entity, project, run_id, run_dir, class_names)\n        per_run_stats.append(stats)\n\n    aggregated_analysis(per_run_stats, api, entity, project, results_dir, run_ids)\n\n\nif __name__ == \"__main__\":\n    main()", "main_py": "# src/main.py\n\"\"\"Main orchestrator.\nReceives run_id via CLI override, saves the full Hydra config under the chosen\nresults directory *outside* Hydra\u0027s job-specific working directory, then launches\n`src.train` as a subprocess while forwarding all original overrides.\n\"\"\"\nfrom __future__ import annotations\n\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport hydra\nimport yaml\nfrom hydra.core.hydra_config import HydraConfig\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg):\n    # ---------------------------------------------------------------------\n    # Absolute results directory (outside Hydra outputs/) ------------------\n    # ---------------------------------------------------------------------\n    orig_cwd = Path(get_original_cwd()).resolve()\n    results_dir_cfg = Path(cfg.results_dir)\n    results_dir_abs = results_dir_cfg if results_dir_cfg.is_absolute() else (orig_cwd / results_dir_cfg).resolve()\n    results_dir_abs.mkdir(parents=True, exist_ok=True)\n\n    # Persist resolved config for the evaluation workflow ------------------\n    with (results_dir_abs / \"config.yaml\").open(\"w\") as f:\n        yaml.safe_dump(OmegaConf.to_container(cfg, resolve=True), f)\n\n    # ---------------------------------------------------------------------\n    # Prepare overrides for subprocess ------------------------------------\n    # ---------------------------------------------------------------------\n    overrides: list[str] = [ov for ov in HydraConfig.get().overrides.task if not ov.startswith(\"results_dir=\")]\n    overrides.append(f\"results_dir={results_dir_abs}\")\n\n    # Ensure wandb disabled is forwarded in trial_mode ---------------------\n    if cfg.trial_mode and not any(ov.startswith(\"wandb.mode=\") for ov in overrides):\n        overrides.append(\"wandb.mode=disabled\")\n\n    # Launch train.py ------------------------------------------------------\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\"] + overrides\n    print(\"Executing:\", \" \".join(cmd))\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()", "model_py": "# src/model.py\n\"\"\"Model builder utilities.\nFocuses on ResNet-18 (or any timm model) with BatchNorm affine parameter\nadaptation as required by TENT / CW-TENT.\n\"\"\"\nfrom __future__ import annotations\n\nimport os\nfrom typing import List\n\nimport timm\nimport torch\nfrom omegaconf import DictConfig\n\n# Make sure models / HF weights are cached under .cache/\nos.environ.setdefault(\"HF_HOME\", \".cache/\")\nos.environ.setdefault(\"TORCH_HOME\", \".cache/\")\n\n# -----------------------------------------------------------------------------\n# Helper functions -------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef _freeze_all(model: torch.nn.Module):\n    for p in model.parameters():\n        p.requires_grad_(False)\n\n\ndef _unfreeze_matching(model: torch.nn.Module, patterns: List[str] | None):\n    if patterns is None:\n        return\n    for name, param in model.named_parameters():\n        if any(pat in name for pat in patterns):\n            param.requires_grad_(True)\n\n# -----------------------------------------------------------------------------\n# Public API -------------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef create_model(cfg: DictConfig) -\u003e torch.nn.Module:\n    \"\"\"Instantiate a timm model as specified in the Hydra cfg.\"\"\"\n    model_name = cfg.model.name\n    num_classes = cfg.model.num_classes\n    checkpoint = cfg.model.get(\"pretrained_checkpoint\", None)\n\n    # timm supports HF-Hub models via the \"hf_hub:\" prefix.\n    if checkpoint is not None:\n        if checkpoint.startswith(\"hf_hub:\"):\n            model = timm.create_model(checkpoint, pretrained=True, num_classes=num_classes)\n        else:\n            model = timm.create_model(f\"hf_hub:{checkpoint}\", pretrained=True, num_classes=num_classes)\n    else:\n        model = timm.create_model(model_name, pretrained=True, num_classes=num_classes)\n\n    # Freeze everything then enable only specified parameters (usually BN affine)\n    _freeze_all(model)\n    _unfreeze_matching(model, cfg.model.get(\"freeze_except\", None))\n\n    return model", "preprocess_py": "# src/preprocess.py\n\"\"\"Data loading \u0026 preprocessing utilities for CIFAR-10-C.\"\"\"\nfrom __future__ import annotations\n\nimport numpy as np\nimport torchvision.transforms as T\nfrom omegaconf import DictConfig\nfrom pathlib import Path\nfrom torch.utils.data import DataLoader, Dataset\n\n# -----------------------------------------------------------------------------\n# CIFAR-10-C dataset wrapper ---------------------------------------------------\n# -----------------------------------------------------------------------------\n\nCIFAR10C_TYPES = [\n    \"gaussian_noise\", \"shot_noise\", \"impulse_noise\",\n    \"defocus_blur\", \"glass_blur\", \"motion_blur\", \"zoom_blur\",\n    \"snow\", \"frost\", \"fog\", \"brightness\", \"contrast\",\n    \"elastic_transform\", \"pixelate\", \"jpeg_compression\",\n]\n\n\nclass CIFAR10CDataset(Dataset):\n    \"\"\"Subset of CIFAR-10-C at a given corruption severity.\"\"\"\n\n    def __init__(self, root: str | Path, corruption_types: str | list[str], severity: int, transform=None):\n        super().__init__()\n        self.transform = transform\n        root = Path(root)\n        if isinstance(corruption_types, str):\n            types = CIFAR10C_TYPES if corruption_types == \"all\" else [corruption_types]\n        else:\n            types = corruption_types\n\n        images_col, labels_col = [], []\n        labels_np = np.load(root / \"labels.npy\")\n        for c_type in types:\n            data = np.load(root / f\"{c_type}.npy\")  # (50_000, 32, 32, 3)\n            start, end = (severity - 1) * 10_000, severity * 10_000\n            images_col.append(data[start:end])\n            labels_col.append(labels_np[start:end])\n        self.data = np.concatenate(images_col, axis=0)\n        self.targets = np.concatenate(labels_col, axis=0)\n\n    # ---------------------------------------------------------------------\n    def __len__(self):\n        return len(self.targets)\n\n    def __getitem__(self, idx: int):\n        img = self.data[idx].astype(np.uint8)\n        label = int(self.targets[idx])\n        img = T.functional.to_pil_image(img)\n        if self.transform:\n            img = self.transform(img)\n        return img, label\n\n# -----------------------------------------------------------------------------\n# Transform helpers ------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef _build_transforms(pre_cfg: DictConfig | None):\n    transforms = [T.ToTensor()]\n    if pre_cfg and pre_cfg.get(\"normalize\") is not None:\n        mean = pre_cfg.normalize.mean\n        std = pre_cfg.normalize.std\n        transforms.append(T.Normalize(mean=mean, std=std))\n    return T.Compose(transforms)\n\n# -----------------------------------------------------------------------------\n# Public API -------------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef get_dataloader(cfg: DictConfig, *, split: str = \"test\") -\u003e DataLoader:\n    \"\"\"Return a DataLoader based on the global Hydra cfg.\"\"\"\n    assert cfg.dataset.name.lower() == \"cifar10c\", \"Only CIFAR-10-C supported currently.\"\n    transform = _build_transforms(cfg.dataset.get(\"preprocessing\", None))\n    dataset = CIFAR10CDataset(\n        root=cfg.dataset.root,\n        corruption_types=cfg.dataset.corruption_types,\n        severity=cfg.dataset.corruption_severity,\n        transform=transform,\n    )\n    return DataLoader(\n        dataset,\n        batch_size=cfg.dataset.batch_size,\n        shuffle=False,  # sequential stream for TTA\n        num_workers=cfg.dataset.num_workers,\n        pin_memory=True,\n    )", "pyproject_toml": "[build-system]\nrequires = [\"setuptools\u003e=42\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cw-tent-experiment\"\nversion = \"0.2.0\"\ndescription = \"Hydra-driven experiments for Confidence-Weighted TENT\"\nreadme = \"README.md\"\nrequires-python = \"\u003e=3.9\"\n\n[project.dependencies]\ntorch = \"*\"\ntorchvision = \"*\"\ntimm = \"*\"\nwandb = \"*\"\nhydra-core = \"*\"\noptuna = \"*\"\nscikit-learn = \"*\"\nscipy = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nPyYAML = \"*\"\n", "train_py": "# src/train.py\n\"\"\"Single experiment run executor.\nThis script performs the actual training / adaptation loop using Hydra for\nconfiguration management and logs every metric to Weights \u0026 Biases (wandb).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport os\nimport random\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nimport wandb\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.metrics import confusion_matrix\n\nfrom src.model import create_model\nfrom src.preprocess import get_dataloader\n\n# -----------------------------------------------------------------------------\n# Environment settings (cache directories) ------------------------------------\n# -----------------------------------------------------------------------------\nos.environ.setdefault(\"HF_HOME\", \".cache/\")\nos.environ.setdefault(\"TORCH_HOME\", \".cache/\")\n\n# -----------------------------------------------------------------------------\n# Utility functions -----------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndef set_seed(seed: int) -\u003e None:\n    \"\"\"Set random seeds for full reproducibility as far as possible.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef entropy(probs: torch.Tensor) -\u003e torch.Tensor:\n    \"\"\"Compute sample-wise entropy given softmax probabilities.\"\"\"\n    return -(probs * (probs + 1e-8).log()).sum(1)\n\n# -----------------------------------------------------------------------------\n# Training / adaptation loop --------------------------------------------------\n# -----------------------------------------------------------------------------\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef train(cfg: DictConfig) -\u003e None:  # noqa: C901 \u2013 complex but self-contained\n    \"\"\"Hydra entry-point for a single run (source, TENT, CW-TENT, \u2026).\"\"\"\n\n    # ---------------------------------------------------------------------\n    # Resolve absolute results directory (independent of Hydra run dir) ----\n    # ---------------------------------------------------------------------\n    original_cwd = Path(get_original_cwd()).resolve()\n    results_dir_cfg = Path(cfg.results_dir)\n    results_dir_abs = results_dir_cfg if results_dir_cfg.is_absolute() else (original_cwd / results_dir_cfg).resolve()\n    run_output_dir: Path = results_dir_abs / cfg.run.run_id\n    run_output_dir.mkdir(parents=True, exist_ok=True)\n\n    # ---------------------------------------------------------------------\n    # Trial-mode adjustments ----------------------------------------------\n    # ---------------------------------------------------------------------\n    if cfg.trial_mode:\n        cfg.wandb.mode = \"disabled\"  # turn off external logging\n        if \"optuna\" in cfg and hasattr(cfg.optuna, \"enabled\"):\n            cfg.optuna.enabled = False\n        cfg.training.epochs = 1\n        cfg.training.inner_steps = 1\n        cfg.dataset.batch_size = min(cfg.dataset.batch_size, 2)\n        cfg.training.log_interval = 1\n\n    # ---------------------------------------------------------------------\n    # Initialise random seed \u0026 device -------------------------------------\n    # ---------------------------------------------------------------------\n    set_seed(cfg.seed)\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ---------------------------------------------------------------------\n    # Initialise Weights \u0026 Biases -----------------------------------------\n    # ---------------------------------------------------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            resume=\"allow\",\n            config=OmegaConf.to_container(cfg, resolve=True),\n            mode=cfg.wandb.mode,\n            dir=str(run_output_dir),\n        )\n        print(f\"WandB dashboard URL: {wandb.run.get_url()}\")\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n\n    # ---------------------------------------------------------------------\n    # Data pipeline --------------------------------------------------------\n    # ---------------------------------------------------------------------\n    dataloader = get_dataloader(cfg, split=cfg.dataset.get(\"split\", \"test\"))\n\n    # ---------------------------------------------------------------------\n    # Model \u0026 optimiser ----------------------------------------------------\n    # ---------------------------------------------------------------------\n    model = create_model(cfg).to(device)\n    model.eval()  # important: evaluation mode for BN running stats\n\n    trainable_params: List[torch.nn.Parameter] = [p for p in model.parameters() if p.requires_grad]\n    if cfg.training.adaptation and len(trainable_params) == 0:\n        raise RuntimeError(\"Adaptation requested but no trainable parameters found.\")\n\n    optim_cls = {\"sgd\": torch.optim.SGD, \"adam\": torch.optim.Adam}[cfg.training.optimizer]\n    optimizer = optim_cls(\n        trainable_params,\n        lr=cfg.training.learning_rate,\n        momentum=getattr(cfg.training, \"momentum\", 0.0),\n        weight_decay=cfg.training.weight_decay,\n    )\n\n    scaler = torch.cuda.amp.GradScaler(enabled=cfg.hardware.mixed_precision)\n\n    # ---------------------------------------------------------------------\n    # Adaptation loop ------------------------------------------------------\n    # ---------------------------------------------------------------------\n    global_step = 0\n    preds_all, targets_all = [], []\n    accum_loss, accum_correct, accum_samples = 0.0, 0, 0\n\n    for epoch in range(cfg.training.epochs):\n        for batch_idx, (inputs, targets) in enumerate(dataloader):\n            inputs = inputs.to(device, non_blocking=True)\n            targets = targets.to(device, non_blocking=True)\n            batch_size = targets.size(0)\n            accum_samples += batch_size\n\n            # Forward before adaptation -------------------------------------------------\n            with torch.no_grad():\n                logits = model(inputs)\n                probs = F.softmax(logits, dim=1)\n                pred_labels = probs.argmax(1)\n                correct = pred_labels.eq(targets).sum().item()\n                batch_acc = correct / batch_size\n                accum_correct += correct\n\n            # Perform adaptation step (if enabled) --------------------------------------\n            if cfg.training.adaptation:\n                model.train()  # BN layers use batch statistics\n                for _ in range(cfg.training.inner_steps):\n                    optimizer.zero_grad(set_to_none=True)\n                    with torch.cuda.amp.autocast(enabled=cfg.hardware.mixed_precision):\n                        logits_adapt = model(inputs)\n                        probs_adapt = F.softmax(logits_adapt, dim=1)\n                        H = entropy(probs_adapt)\n                        if cfg.training.objective == \"entropy\":\n                            loss = H.mean()\n                        elif cfg.training.objective == \"confidence_weighted_entropy\":\n                            w = 1.0 - H / np.log(probs_adapt.size(1))\n                            loss = (w * H).sum() / w.sum()\n                        else:\n                            raise ValueError(f\"Unknown objective {cfg.training.objective}\")\n                    scaler.scale(loss).backward()\n                    if cfg.training.gradient_clip is not None:\n                        scaler.unscale_(optimizer)\n                        torch.nn.utils.clip_grad_norm_(trainable_params, cfg.training.gradient_clip)\n                    scaler.step(optimizer)\n                    scaler.update()\n                model.eval()\n                loss_value = loss.detach().item()\n            else:\n                loss_value = 0.0\n\n            accum_loss += loss_value * batch_size\n\n            # Forward after adaptation ---------------------------------------------------\n            with torch.no_grad():\n                logits_final = model(inputs)\n                probs_final = F.softmax(logits_final, dim=1)\n                preds_final = probs_final.argmax(1)\n\n            preds_all.append(preds_final.cpu())\n            targets_all.append(targets.cpu())\n\n            # Logging to WandB ------------------------------------------------------------\n            if cfg.wandb.mode != \"disabled\" and (batch_idx % cfg.training.log_interval == 0):\n                wandb.log({\n                    \"batch_accuracy\": batch_acc,\n                    \"adapt_loss\": loss_value,\n                    \"seen_samples\": accum_samples,\n                    \"epoch\": epoch,\n                }, step=global_step)\n\n            global_step += 1\n\n            # Short-circuit for trial-mode ----------------------------------------------\n            if cfg.trial_mode and batch_idx \u003e= 1:\n                break  # only two batches\n\n    # ---------------------------------------------------------------------\n    # Aggregate metrics ----------------------------------------------------\n    # ---------------------------------------------------------------------\n    preds_all_tensor = torch.cat(preds_all)\n    targets_all_tensor = torch.cat(targets_all)\n    final_top1 = preds_all_tensor.eq(targets_all_tensor).float().mean().item()\n    avg_adapt_loss = accum_loss / max(accum_samples, 1)\n    conf_mat = confusion_matrix(targets_all_tensor.numpy(), preds_all_tensor.numpy())\n\n    # Save confusion matrix locally for evaluation script ------------------\n    np.save(run_output_dir / \"confusion_matrix.npy\", conf_mat.astype(np.int32))\n\n    # Final WandB logging --------------------------------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb.log({\n            \"top1_accuracy\": final_top1,\n            \"avg_adapt_loss\": avg_adapt_loss,\n            \"conf_mat\": conf_mat.tolist(),\n        })\n        wandb.finish()\n\n    print(json.dumps({\n        \"run_id\": cfg.run.run_id,\n        \"top1_accuracy\": final_top1,\n        \"avg_adapt_loss\": avg_adapt_loss,\n        \"results_dir\": str(run_output_dir),\n    }, indent=2))\n\n\nif __name__ == \"__main__\":\n    train()"}

Analyze the experiment code thoroughly. Ensure it is complete, executable, and ready for publication-quality research experiments.
Output:
{
    "is_code_ready": false,
    "code_issue": "The package still violates several mandatory requirements:\n\n1. WandB / stdout rule (Core requirement 6): src/train.py prints a JSON summary to stdout at the end of the run.  The guidelines explicitly forbid *any* stdout JSON dumps or results.json generation inside train.py.\n\n2. Missing dependency: evaluate.py relies on pandas but pyproject.toml does not list a pandas requirement, causing an import error in a clean environment.\n\n3. Optuna section present in configs but never handled in code (no optimisation loop / optuna.study).  Either remove the section or implement full Optuna support as per configuration.\n\nUntil these issues are fixed the code cannot be considered production-ready for immediate execution."
}
