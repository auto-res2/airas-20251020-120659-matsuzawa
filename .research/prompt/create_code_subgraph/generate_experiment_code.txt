
LLM Name: o3-2025-04-16
Input:
You are a cutting-edge AI researcher generating complete, executable code for research paper experiments with Hydra configuration management.

Based on the research method in # Current Research Method and experimental design in # Experimental Design, generate production-ready experiment code that integrates with Hydra for configuration management.

# Instructions: Complete Experiment Code Generation

## Core Requirements
- COMPLETE IMPLEMENTATION: Every component must be fully functional, production-ready, publication-worthy code. No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
- PYTORCH EXCLUSIVELY: Use PyTorch as the deep learning framework
- HYDRA INTEGRATION: Use Hydra to manage all experiment configurations from `config/run/*.yaml` files. Use `config_path="../config"` in all @hydra.main decorators
- COMPLETE DATA PIPELINE: Full data loading and preprocessing implementation. Use `.cache/` as the cache directory for all datasets and models (e.g., for HuggingFace, set `cache_dir=".cache/"`)
- WANDB REQUIRED: WandB is mandatory for metrics logging (except trial_mode validation)

## Hydra Configuration Structure
Each run config file (`config/run/{run_id}.yaml`) contains:
- run_id: Unique identifier for this run
- method: The method name (baseline, proposed, ablation, etc.)
- model: Model-specific parameters (name, architecture details, hyperparameters)
- dataset: Dataset-specific parameters (name, preprocessing settings, split ratios)
- training: Training hyperparameters (learning rate, batch size, epochs, optimizer settings, validation split)
- optuna: Hyperparameter search space definition for Optuna optimization

## Command Line Interface
The generated code must support the following CLI:

**Training (main.py):**
```bash
# Full experiment with WandB logging
uv run python -u -m src.main run={run_id} results_dir={path}

# Trial mode (validation only, WandB disabled)
uv run python -u -m src.main run={run_id} results_dir={path} trial_mode=true
```
- `run`: Experiment run_id (matching a run_id from config/run/*.yaml)
- `results_dir`: Output directory (passed from GitHub Actions workflow)
- `trial_mode=true` (optional): Lightweight execution for validation (epochs=1, batches limited to 1-2, disable Optuna n_trials=0, **WandB disabled**)

**Evaluation (evaluate.py, independent execution):**
```bash
uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'
```
- `results_dir`: Directory containing experiment metadata and where outputs will be saved
- `run_ids`: JSON string list of run IDs to evaluate (e.g., '["run-1-proposed-bert-glue", "run-2-baseline-bert-glue"]')
- Executed as a separate workflow after all training runs complete
- **NOT called from main.py**

## Script Structure (ExperimentCode format)
Generate complete code for these files ONLY. Do not create any additional files beyond this structure:

**`src/train.py`**: Single experiment run executor
- Uses Hydra config to load all parameters
- Called as subprocess by main.py
- Responsibilities:
  * Train model with given configuration
  * Initialize WandB: `wandb.init(entity=cfg.wandb.entity, project=cfg.wandb.project, id=cfg.run.run_id, config=OmegaConf.to_container(cfg, resolve=True), resume="allow")`
  * Skip `wandb.init()` if `cfg.wandb.mode == "disabled"` (trial_mode)
  * Log ALL metrics to WandB: `wandb.log({"train_loss": 0.5, "val_acc": 0.85, "epoch": 1, ...})`
  * Print WandB run URL to stdout
- **NO results.json, no stdout JSON output, no figure generation**

**`src/evaluate.py`**: Independent evaluation and visualization script
- **Execution**: Run independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
- **NOT called from main.py** - executes as separate workflow after all training completes
- **Responsibilities**:
  * Parse command line arguments:
    - `results_dir`: Output directory path
    - `run_ids`: JSON string list of run IDs (parse with `json.loads(args.run_ids)`)
  * Load WandB config from `{results_dir}/config.yaml`
  * Retrieve experimental data from WandB API for specified run_ids:
    ```python
    import json
    api = wandb.Api()
    run_ids = json.loads(args.run_ids)  # Parse JSON string to list
    for run_id in run_ids:
        run = api.run(f"{entity}/{project}/{run_id}")
        metrics_df = run.history()  # pandas DataFrame with all logged metrics
    ```
  * **STEP 1: Per-Run Processing** (for each run_id):
    - Export run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
    - Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
    - Each run should have its own subdirectory with its metrics and figures
  * **STEP 2: Aggregated Analysis** (after processing all runs):
    - Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
    - Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
    - Generate comparison figures to: `{results_dir}/comparison/`:
      * Cross-run comparison charts (bar charts, box plots)
      * Performance metrics tables
      * Statistical significance tests
  * **Figure Generation Guidelines**:
    - Use matplotlib or seaborn with proper legends, annotations, tight_layout
    - For line graphs: annotate significant values (final/best values)
    - For bar graphs: annotate values above each bar
    - Follow naming convention: `<figure_topic>[_<condition>][_pairN].pdf`
  * Print all generated file paths to stdout (both per-run and comparison)

**`src/preprocess.py`**: Complete preprocessing pipeline implementation for the specified datasets

**`src/model.py`**: Complete model architecture implementations for all methods (proposed and comparative methods)

**`src/main.py`**: Main orchestrator
- Receives run_id via Hydra, launches train.py as subprocess, manages logs
- **DOES NOT call evaluate.py** (evaluate.py runs independently in separate workflow)
- Use `@hydra.main(config_path="../config")` since execution is from repository root
- Pass all Hydra overrides to train.py subprocess (e.g., `wandb.mode=disabled`, `trial_mode=true`)
- In trial_mode, automatically set `wandb.mode=disabled`

**`config/config.yaml`**: Main Hydra configuration file
- MUST include WandB configuration:
  ```yaml
  wandb:
    entity: gengaru617-personal
    project: 251020-test
    mode: online  # Automatically set to "disabled" in trial_mode
  ```

**`pyproject.toml`**: Complete project dependencies
- MUST include: `hydra-core`, `wandb` (required)
- Include as needed: `optuna`, `torch`, `transformers`, `datasets`, etc.


## Key Implementation Focus Areas
1. **Hydra-Driven Configuration**: All parameters loaded from run configs dynamically
2. **Algorithm Core**: Full implementation of the proposed method with proper abstraction
3. **Trial Mode Behavior**: trial_mode=true automatically disables WandB (sets wandb.mode=disabled)
4. **Run Execution**: main.py executes a single run_id passed via CLI (GitHub Actions dispatches multiple runs separately)
5. **WandB Integration**: All metrics logged to WandB; train.py does NOT output JSON to stdout or save results.json
6. **Independent Evaluation**: evaluate.py runs separately, fetches data from WandB API, generates all figures



## Code Validation Feedback


**Previous Validation Issue**: Python syntax is invalid in all source files: every function/type-annotation uses the string "-\u003e" instead of the proper arrow token "->" (e.g. `def _parse_kv_cli() -\u003e Dict[str, str]:`). The leading hyphen makes the code uncompilable, so none of the modules can be imported or executed. Replace all occurrences of "-\u003e" with the correct `->` annotation delimiter (and similarly for `<-` if present) to restore valid Python syntax. Once fixed, re-run lint/tests to confirm execution.
**Action Required**: Address this issue in the implementation.

**Previous Code (for reference)**:
{"config_yaml": "# config/config.yaml\n# -----------------------------------------------------------------------------\n# Global defaults --------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndefaults:\n  - _self_\n  - run: ??  # MUST be overridden from CLI, e.g. run=proposed_resnet18_cifar10c\n\n# -----------------------------------------------------------------------------\n# Global random seed \u0026 execution mode -----------------------------------------\n# -----------------------------------------------------------------------------\nseed: 42\ntrial_mode: false  # set automatically via CLI `trial_mode=true`\nresults_dir: ./results\n\n# -----------------------------------------------------------------------------\n# Weights \u0026 Biases ------------------------------------------------------------\n# -----------------------------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online  # switched to \"disabled\" automatically in trial_mode\n\n# -----------------------------------------------------------------------------\n# Hardware settings -----------------------------------------------------------\n# -----------------------------------------------------------------------------\nhardware:\n  gpus: 1\n  mixed_precision: true\n\n# -----------------------------------------------------------------------------\n# Dataset placeholder (overridden by run configs) -----------------------------\n# -----------------------------------------------------------------------------\ndataset:\n  name: cifar10c\n  root: /path/to/cifar10c\n  corruption_severity: 5\n  corruption_types: all\n  batch_size: 64\n  num_workers: 4\n  preprocessing:\n    normalize:\n      mean: [0.4914, 0.4822, 0.4465]\n      std:  [0.2023, 0.1994, 0.2010]\n\n# -----------------------------------------------------------------------------\n# Training hyper-parameters ----------------------------------------------------\n# -----------------------------------------------------------------------------\ntraining:\n  adaptation: false\n  objective: entropy\n  inner_steps: 1\n  learning_rate: 0.001\n  optimizer: sgd\n  momentum: 0.9\n  weight_decay: 0.0\n  epochs: 1\n  gradient_clip: null\n  log_interval: 50\n\n# -----------------------------------------------------------------------------\n# Optuna defaults -------------------------------------------------------------\n# -----------------------------------------------------------------------------\noptuna:\n  enabled: false\n  n_trials: 0\n  direction: maximize\n  metric: top1_accuracy\n  search_space: {}\n\n# -----------------------------------------------------------------------------\n# Run placeholder -------------------------------------------------------------\n# -----------------------------------------------------------------------------\nrun:\n  run_id: default\n  method: baseline\n  model:\n    name: resnet18\n    num_classes: 10\n    freeze_except:\n      - batchnorm.weight\n      - batchnorm.bias\n", "evaluate_py": "# src/evaluate.py\n\"\"\"Independent evaluation / visualisation script.\n\nExample CLI:\n    uv run python -m src.evaluate results_dir=./results run_ids=\u0027[\"run-1\", \"run-2\"]\u0027\n\"\"\"\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy import stats\n\n# ----------------------------------------------------------------------------\n# CLI parsing ----------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _parse_kv_cli() -\u003e Dict[str, str]:\n    cli_kv: Dict[str, str] = {}\n    for arg in sys.argv[1:]:\n        if \"=\" not in arg:\n            raise ValueError(\n                f\"Unexpected argument format: \u0027{arg}\u0027. Expected key=value pairs.\")\n        k, v = arg.split(\"=\", 1)\n        cli_kv[k] = v\n    required = {\"results_dir\", \"run_ids\"}\n    missing = required - cli_kv.keys()\n    if missing:\n        raise ValueError(f\"Missing required CLI keys: {missing}\")\n    return cli_kv\n\n# ----------------------------------------------------------------------------\n# WandB helpers ---------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _load_wandb_config(results_dir: Path) -\u003e Dict:\n    cfg_path = results_dir / \"config.yaml\"\n    if not cfg_path.exists():\n        raise FileNotFoundError(\n            f\"Expected {cfg_path} (copied by main.py) but file does not exist.\")\n    with cfg_path.open(\"r\") as f:\n        return yaml.safe_load(f)\n\n# ----------------------------------------------------------------------------\n# Per-run processing ----------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _export_metrics(df: pd.DataFrame, out_file: Path) -\u003e None:\n    df.to_json(out_file, orient=\"records\", lines=True)\n\n\ndef _plot_learning_curves(df: pd.DataFrame, run_id: str, out_dir: Path) -\u003e List[Path]:\n    figs: List[Path] = []\n    metrics_to_plot = [c for c in [\"batch_accuracy\", \"top1_accuracy\"] if c in df.columns]\n    for metric in metrics_to_plot:\n        plt.figure(figsize=(6, 4))\n        sns.lineplot(data=df, x=df.index, y=metric)\n        plt.title(f\"{run_id} \u2013 {metric}\")\n        plt.xlabel(\"Step\")\n        plt.ylabel(metric)\n        if df[metric].dropna().size:\n            final_val = df[metric].dropna().iloc[-1]\n            plt.annotate(f\"{final_val:.4f}\", xy=(df.index[-1], final_val), xytext=(-40, 10), textcoords=\"offset points\")\n        plt.tight_layout()\n        fig_path = out_dir / f\"learning_curve_{metric}.pdf\"\n        plt.savefig(fig_path)\n        plt.close()\n        figs.append(fig_path)\n    return figs\n\n\ndef _plot_confusion_matrix(conf_mat: np.ndarray, class_names: List[str], title: str, out_path: Path) -\u003e None:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(conf_mat, annot=True, fmt=\"d\", cmap=\"Blues\", xticklabels=class_names, yticklabels=class_names)\n    plt.ylabel(\"True label\")\n    plt.xlabel(\"Predicted label\")\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\ndef per_run_processing(api: wandb.Api, entity: str, project: str, run_id: str, run_dir: Path, class_names: List[str]) -\u003e Dict:\n    run = api.run(f\"{entity}/{project}/{run_id}\")\n    history_df = run.history(pandas=True)\n\n    # --------------------------------------------------------------------\n    # Raw metrics --------------------------------------------------------\n    # --------------------------------------------------------------------\n    _export_metrics(history_df, run_dir / \"metrics.json\")\n\n    # --------------------------------------------------------------------\n    # Plots --------------------------------------------------------------\n    # --------------------------------------------------------------------\n    fig_paths = _plot_learning_curves(history_df, run_id, run_dir)\n\n    conf_mat = None\n    if \"conf_mat\" in run.summary:\n        conf_mat = np.array(run.summary[\"conf_mat\"], dtype=int)\n    else:\n        local_conf = run_dir / \"confusion_matrix.npy\"\n        if local_conf.exists():\n            conf_mat = np.load(local_conf)\n    if conf_mat is not None:\n        cm_path = run_dir / \"confusion_matrix.pdf\"\n        _plot_confusion_matrix(conf_mat, class_names, f\"{run_id} \u2013 Confusion Matrix\", cm_path)\n        fig_paths.append(cm_path)\n\n    final_acc = history_df.get(\"top1_accuracy\", pd.Series(dtype=float)).dropna()\n    final_val = float(final_acc.iloc[-1]) if not final_acc.empty else None\n\n    print(f\"[Per-run] Generated files for {run_id}:\")\n    for p in fig_paths:\n        print(\"  \u2022\", p)\n\n    return {\n        \"run_id\": run_id,\n        \"final_accuracy\": final_val,\n    }\n\n# ----------------------------------------------------------------------------\n# Aggregated analysis ---------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef aggregated_analysis(per_run_stats: List[Dict], results_dir: Path) -\u003e None:\n    comp_dir = results_dir / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    agg_path = comp_dir / \"aggregated_metrics.json\"\n    with agg_path.open(\"w\") as f:\n        json.dump(per_run_stats, f, indent=2)\n    print(\"Aggregated metrics saved to\", agg_path)\n\n    df = pd.DataFrame(per_run_stats)\n    plt.figure(figsize=(8, 4))\n    sns.barplot(data=df, x=\"run_id\", y=\"final_accuracy\", palette=\"viridis\")\n    plt.xticks(rotation=45, ha=\"right\")\n    for idx, row in df.iterrows():\n        plt.text(idx, row[\"final_accuracy\"] + 0.2, f\"{row[\u0027final_accuracy\u0027]:.2f}\", ha=\"center\")\n    plt.ylabel(\"Final Top-1 Accuracy\")\n    plt.title(\"Final Accuracy across Runs\")\n    plt.tight_layout()\n    bar_path = comp_dir / \"final_accuracy_comparison.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    print(\"Created\", bar_path)\n\n# ----------------------------------------------------------------------------\n# Main -----------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef main() -\u003e None:\n    cli_kv = _parse_kv_cli()\n    results_dir = Path(cli_kv[\"results_dir\"]).expanduser().resolve()\n    run_ids = json.loads(cli_kv[\"run_ids\"])\n\n    wandb_cfg = _load_wandb_config(results_dir)\n    entity = wandb_cfg[\"wandb\"][\"entity\"]\n    project = wandb_cfg[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n    class_names = [str(i) for i in range(10)]  # CIFAR-10 default\n\n    per_run_stats: List[Dict] = []\n    for rid in run_ids:\n        run_dir = results_dir / rid\n        run_dir.mkdir(parents=True, exist_ok=True)\n        stats = per_run_processing(api, entity, project, rid, run_dir, class_names)\n        per_run_stats.append(stats)\n\n    aggregated_analysis(per_run_stats, results_dir)\n\n\nif __name__ == \"__main__\":\n    main()\n", "main_py": "# src/main.py\n\"\"\"Main orchestrator.\n\nThis script receives a `run=\u003crun_id\u003e` override from the CLI, writes the fully\nresolved Hydra config to `\u003cresults_dir\u003e/config.yaml`, and launches `src.train`\nas a subprocess while forwarding all CLI overrides.\n\"\"\"\nfrom __future__ import annotations\n\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport hydra\nimport yaml\nfrom hydra.core.hydra_config import HydraConfig\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg):\n    # ---------------------------------------------------------------------\n    # Results directory (absolute path) -----------------------------------\n    # ---------------------------------------------------------------------\n    orig_cwd = Path(get_original_cwd()).resolve()\n    results_dir_cfg = Path(cfg.results_dir)\n    results_dir = results_dir_cfg if results_dir_cfg.is_absolute() else (orig_cwd / results_dir_cfg).resolve()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    # ---------------------------------------------------------------------\n    # Persist resolved config for evaluation script -----------------------\n    # ---------------------------------------------------------------------\n    with (results_dir / \"config.yaml\").open(\"w\") as f:\n        yaml.safe_dump(OmegaConf.to_container(cfg, resolve=True), f)\n\n    # ---------------------------------------------------------------------\n    # Forward CLI overrides to train.py -----------------------------------\n    # ---------------------------------------------------------------------\n    overrides = [ov for ov in HydraConfig.get().overrides.task if not ov.startswith(\"results_dir=\")]\n    overrides.append(f\"results_dir={results_dir}\")\n\n    # Ensure trial-mode disables WandB ------------------------------------\n    if cfg.trial_mode and not any(ov.startswith(\"wandb.mode=\") for ov in overrides):\n        overrides.append(\"wandb.mode=disabled\")\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\"] + overrides\n    print(\"Executing:\", \" \".join(cmd))\n\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "# src/model.py\n\"\"\"Model builder utilities (timm-based with selective BN unfreezing).\"\"\"\nfrom __future__ import annotations\n\nimport os\nfrom typing import List\n\nimport timm\nimport torch\nfrom omegaconf import DictConfig\n\n# Ensure weight downloads are cached under ./.cache\nos.environ.setdefault(\"HF_HOME\", \".cache/\")\nos.environ.setdefault(\"TORCH_HOME\", \".cache/\")\n\n# ----------------------------------------------------------------------------\n# Helpers --------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _freeze_all(model: torch.nn.Module):\n    for p in model.parameters():\n        p.requires_grad_(False)\n\n\ndef _unfreeze_matching(model: torch.nn.Module, patterns: List[str] | None):\n    \"\"\"Re-enable gradients for parameters matching *patterns*.\n\n    The function additionally supports special tokens \"batchnorm.weight\" and\n    \"batchnorm.bias\" (case-insensitive) which directly target all BatchNorm\n    affine parameters regardless of their names.\n    \"\"\"\n    if patterns is None:\n        return\n\n    patterns_lower = [p.lower() for p in patterns]\n\n    # Special handling for BatchNorm affine parameters -------------------\n    if \"batchnorm.weight\" in patterns_lower or \"batchnorm.bias\" in patterns_lower:\n        for m in model.modules():\n            if isinstance(m, torch.nn.BatchNorm2d):\n                if \"batchnorm.weight\" in patterns_lower and m.weight is not None:\n                    m.weight.requires_grad_(True)\n                if \"batchnorm.bias\" in patterns_lower and m.bias is not None:\n                    m.bias.requires_grad_(True)\n\n    # Generic name-based matching ---------------------------------------\n    for name, param in model.named_parameters():\n        if any(pat in name.lower() for pat in patterns_lower):\n            param.requires_grad_(True)\n\n# ----------------------------------------------------------------------------\n# Public API ------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef create_model(cfg: DictConfig) -\u003e torch.nn.Module:\n    \"\"\"Instantiate the (potentially pre-trained) model specified in *cfg*.\"\"\"\n    model_name = cfg.model.name\n    num_classes = cfg.model.num_classes\n    checkpoint = cfg.model.get(\"pretrained_checkpoint\", None)\n\n    if checkpoint is not None:\n        # `timm` interprets model names containing a slash as HF-hub IDs.\n        model = timm.create_model(checkpoint, pretrained=True, num_classes=num_classes)\n    else:\n        model = timm.create_model(model_name, pretrained=True, num_classes=num_classes)\n\n    # Freeze all parameters then selectively unfreeze according to cfg.\n    _freeze_all(model)\n    _unfreeze_matching(model, cfg.model.get(\"freeze_except\", None))\n    return model\n", "preprocess_py": "# src/preprocess.py\n\"\"\"Data loading \u0026 preprocessing utilities for CIFAR-10-C.\"\"\"\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import List\n\nimport numpy as np\nimport torchvision.transforms as T\nfrom omegaconf import DictConfig\nfrom torch.utils.data import DataLoader, Dataset\n\n# ----------------------------------------------------------------------------\n# Dataset wrapper -------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\nCIFAR10C_TYPES: List[str] = [\n    \"gaussian_noise\", \"shot_noise\", \"impulse_noise\",\n    \"defocus_blur\", \"glass_blur\", \"motion_blur\", \"zoom_blur\",\n    \"snow\", \"frost\", \"fog\", \"brightness\", \"contrast\",\n    \"elastic_transform\", \"pixelate\", \"jpeg_compression\",\n]\n\n\nclass CIFAR10CDataset(Dataset):\n    \"\"\"Subset of CIFAR-10-C at a given corruption severity.\"\"\"\n\n    def __init__(self, root: str | Path, corruption_types: str | List[str], severity: int, transform=None):\n        super().__init__()\n        self.transform = transform\n        root = Path(root)\n        if isinstance(corruption_types, str):\n            types = CIFAR10C_TYPES if corruption_types == \"all\" else [corruption_types]\n        else:\n            types = corruption_types\n\n        images_col, labels_col = [], []\n        labels_np = np.load(root / \"labels.npy\")\n        for c_type in types:\n            data = np.load(root / f\"{c_type}.npy\")\n            start, end = (severity - 1) * 10_000, severity * 10_000\n            images_col.append(data[start:end])\n            labels_col.append(labels_np[start:end])\n        self.data = np.concatenate(images_col, axis=0)\n        self.targets = np.concatenate(labels_col, axis=0)\n\n    def __len__(self):\n        return len(self.targets)\n\n    def __getitem__(self, idx: int):\n        img = self.data[idx].astype(np.uint8)\n        label = int(self.targets[idx])\n        img = T.functional.to_pil_image(img)\n        if self.transform:\n            img = self.transform(img)\n        return img, label\n\n# ----------------------------------------------------------------------------\n# Transform helpers -----------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _build_transforms(pre_cfg: DictConfig | None):\n    transforms = [T.ToTensor()]\n    if pre_cfg and pre_cfg.get(\"normalize\") is not None:\n        mean = pre_cfg.normalize.mean\n        std = pre_cfg.normalize.std\n        transforms.append(T.Normalize(mean=mean, std=std))\n    return T.Compose(transforms)\n\n# ----------------------------------------------------------------------------\n# Public API ------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef get_dataloader(cfg: DictConfig, *, split: str = \"test\") -\u003e DataLoader:\n    \"\"\"Return a DataLoader for CIFAR-10-C.\n\n    Currently only the *test* split is meaningful for CIFAR-10-C.\n    \"\"\"\n    assert cfg.dataset.name.lower() == \"cifar10c\", \"Only CIFAR-10-C supported currently.\"\n    transform = _build_transforms(cfg.dataset.get(\"preprocessing\", None))\n    dataset = CIFAR10CDataset(\n        root=cfg.dataset.root,\n        corruption_types=cfg.dataset.corruption_types,\n        severity=cfg.dataset.corruption_severity,\n        transform=transform,\n    )\n    return DataLoader(\n        dataset,\n        batch_size=cfg.dataset.batch_size,\n        shuffle=False,\n        num_workers=cfg.dataset.num_workers,\n        pin_memory=True,\n    )\n", "pyproject_toml": "[build-system]\nrequires = [\"setuptools\u003e=42\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cw-tent-experiment\"\nversion = \"0.3.0\"\ndescription = \"Hydra-driven experiments for Confidence-Weighted TENT\"\nrequires-python = \"\u003e=3.9\"\n\n[project.dependencies]\ntorch = \"*\"\ntorchvision = \"*\"\ntimm = \"*\"\nnumpy = \"*\"\nwandb = \"*\"\nhydra-core = \"*\"\noptuna = \"*\"\nscikit-learn = \"*\"\nscipy = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nPyYAML = \"*\"\npandas = \"*\"\n", "train_py": "# src/train.py\n\"\"\"Single experiment run executor with Optuna support.\n\nThis script performs the full training / adaptation loop for one experiment run.\nIf `cfg.optuna.enabled` is *true* and `n_trials\u003e0`, an Optuna hyper-parameter\nsearch is carried out first (WandB logging *disabled* during the sweep).  The\nbest hyper-parameters are then used for the final training run which is logged\non WandB under the ID `cfg.run.run_id`.\n\nIn **trial_mode** the script executes a highly abbreviated pass (1\u20132 batches,\n1 epoch) and *disables WandB* automatically.\n\"\"\"\nfrom __future__ import annotations\n\nimport copy\nimport json\nimport os\nimport pickle\nimport random\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport hydra\nimport numpy as np\nimport optuna\nimport torch\nimport torch.nn.functional as F\nimport wandb\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.metrics import confusion_matrix\n\nfrom src.model import create_model\nfrom src.preprocess import get_dataloader\n\n# ----------------------------------------------------------------------------\n# Cache directories (HF/TIMM/torch) ------------------------------------------\n# ----------------------------------------------------------------------------\nos.environ.setdefault(\"HF_HOME\", \".cache/\")\nos.environ.setdefault(\"TORCH_HOME\", \".cache/\")\n\n# ----------------------------------------------------------------------------\n# Utility functions ----------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef set_seed(seed: int) -\u003e None:\n    \"\"\"Make experiment deterministic (as much as possible).\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef entropy(probs: torch.Tensor) -\u003e torch.Tensor:\n    \"\"\"Per-sample entropy of a probability distribution.\"\"\"\n    return -(probs * (probs + 1e-8).log()).sum(1)\n\n# ----------------------------------------------------------------------------\n# Core training logic --------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef run_training(cfg: DictConfig, *, device: torch.device, use_wandb: bool, out_dir: Path) -\u003e float:  # noqa: C901\n    \"\"\"Run the adaptation loop once with the hyper-parameters present in *cfg*.\n\n    Parameters\n    ----------\n    cfg : DictConfig\n        The fully-resolved Hydra configuration.\n    device : torch.device\n        Training device.\n    use_wandb : bool\n        Whether to emit logs to WandB.\n    out_dir : Path\n        Directory where auxiliary artefacts (e.g. confusion matrix) are stored.\n\n    Returns\n    -------\n    float\n        Final top-1 accuracy after processing the complete data stream.\n    \"\"\"\n    dataloader = get_dataloader(cfg, split=cfg.dataset.get(\"split\", \"test\"))\n    model = create_model(cfg).to(device)\n    model.eval()\n\n    trainable_params: List[torch.nn.Parameter] = [p for p in model.parameters() if p.requires_grad]\n    if cfg.training.adaptation and len(trainable_params) == 0:\n        raise RuntimeError(\"Adaptation requested but the model exposes no trainable parameters.\")\n\n    optim_cls = {\"sgd\": torch.optim.SGD, \"adam\": torch.optim.Adam}[cfg.training.optimizer]\n    optimizer = optim_cls(\n        trainable_params,\n        lr=cfg.training.learning_rate,\n        momentum=getattr(cfg.training, \"momentum\", 0.0),\n        weight_decay=cfg.training.weight_decay,\n    )\n\n    scaler = torch.cuda.amp.GradScaler(enabled=cfg.hardware.mixed_precision)\n\n    global_step = 0\n    preds_all, targets_all = [], []\n    accum_loss = 0.0\n    accum_samples = 0\n\n    for epoch in range(cfg.training.epochs):\n        for batch_idx, (inputs, targets) in enumerate(dataloader):\n            inputs = inputs.to(device, non_blocking=True)\n            targets = targets.to(device, non_blocking=True)\n            bs = targets.size(0)\n            accum_samples += bs\n\n            # ----------------------------------------------------------------\n            # Forward pass BEFORE adaptation (for reporting only)\n            # ----------------------------------------------------------------\n            with torch.no_grad():\n                logits = model(inputs)\n                probs = F.softmax(logits, dim=1)\n                preds_pre = probs.argmax(1)\n                batch_acc = preds_pre.eq(targets).float().mean().item()\n\n            # ----------------------------------------------------------------\n            # Adaptation step (if enabled)\n            # ----------------------------------------------------------------\n            if cfg.training.adaptation:\n                model.train()  # ensure BN uses current batch stats\n                for _ in range(cfg.training.inner_steps):\n                    optimizer.zero_grad(set_to_none=True)\n                    with torch.cuda.amp.autocast(enabled=cfg.hardware.mixed_precision):\n                        logits_adapt = model(inputs)\n                        probs_adapt = F.softmax(logits_adapt, dim=1)\n                        H = entropy(probs_adapt)\n                        if cfg.training.objective == \"entropy\":\n                            loss = H.mean()\n                        elif cfg.training.objective == \"confidence_weighted_entropy\":\n                            w = 1.0 - H / np.log(probs_adapt.size(1))\n                            loss = (w * H).sum() / w.sum()\n                        else:\n                            raise ValueError(f\"Unknown objective {cfg.training.objective}\")\n                    scaler.scale(loss).backward()\n                    if cfg.training.gradient_clip is not None:\n                        scaler.unscale_(optimizer)\n                        torch.nn.utils.clip_grad_norm_(trainable_params, cfg.training.gradient_clip)\n                    scaler.step(optimizer)\n                    scaler.update()\n                model.eval()\n                loss_val = loss.detach().item()\n            else:\n                loss_val = 0.0\n\n            accum_loss += loss_val * bs\n\n            # ----------------------------------------------------------------\n            # Forward AFTER adaptation (used for final accuracy statistics)\n            # ----------------------------------------------------------------\n            with torch.no_grad():\n                logits_final = model(inputs)\n                preds_final = logits_final.softmax(1).argmax(1)\n            preds_all.append(preds_final.cpu())\n            targets_all.append(targets.cpu())\n\n            # ----------------------------------------------------------------\n            # WandB logging\n            # ----------------------------------------------------------------\n            if use_wandb and (batch_idx % cfg.training.log_interval == 0):\n                wandb.log({\n                    \"batch_accuracy\": batch_acc,\n                    \"adapt_loss\": loss_val,\n                    \"seen_samples\": accum_samples,\n                    \"epoch\": epoch,\n                }, step=global_step)\n\n            global_step += 1\n\n            # ----------------------------------------------------------------\n            # Trial-mode early exit (keep execution lightweight)\n            # ----------------------------------------------------------------\n            if cfg.trial_mode and batch_idx \u003e= 1:\n                break\n        if cfg.trial_mode:\n            break\n\n    preds_all_tensor = torch.cat(preds_all)\n    targets_all_tensor = torch.cat(targets_all)\n    final_acc = preds_all_tensor.eq(targets_all_tensor).float().mean().item()\n\n    avg_loss = accum_loss / max(accum_samples, 1)\n    conf_mat = confusion_matrix(targets_all_tensor.numpy(), preds_all_tensor.numpy())\n    np.save(out_dir / \"confusion_matrix.npy\", conf_mat.astype(np.int32))\n\n    if use_wandb:\n        wandb.log({\n            \"top1_accuracy\": final_acc,\n            \"avg_adapt_loss\": avg_loss,\n            \"conf_mat\": conf_mat.tolist(),\n        })\n\n    return final_acc\n\n# ----------------------------------------------------------------------------\n# Optuna helpers -------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _suggest_from_space(trial: optuna.Trial, space: Dict) -\u003e Dict[str, float | int | str]:\n    \"\"\"Sample a set of hyper-parameters from *space* using *trial*.\"\"\"\n    sampled: Dict[str, float | int | str] = {}\n    for param, spec in space.items():\n        p_type = spec[\"type\"]\n        if p_type == \"loguniform\":\n            sampled[param] = trial.suggest_float(param, spec[\"low\"], spec[\"high\"], log=True)\n        elif p_type == \"uniform\":\n            sampled[param] = trial.suggest_float(param, spec[\"low\"], spec[\"high\"], log=False)\n        elif p_type == \"int\":\n            sampled[param] = trial.suggest_int(param, spec[\"low\"], spec[\"high\"], log=spec.get(\"log\", False))\n        elif p_type == \"categorical\":\n            sampled[param] = trial.suggest_categorical(param, spec[\"choices\"])\n        else:\n            raise ValueError(f\"Unsupported Optuna parameter type: {p_type}\")\n    return sampled\n\n# ----------------------------------------------------------------------------\n# Hydra entry-point ----------------------------------------------------------\n# ----------------------------------------------------------------------------\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg: DictConfig) -\u003e None:  # noqa: C901 (complex but cohesive)\n    # ---------------------------------------------------------------------\n    # Resolve absolute output directory -----------------------------------\n    # ---------------------------------------------------------------------\n    orig_cwd = Path(get_original_cwd()).resolve()\n    results_dir_cfg = Path(cfg.results_dir)\n    results_dir = results_dir_cfg if results_dir_cfg.is_absolute() else (orig_cwd / results_dir_cfg).resolve()\n    run_dir: Path = results_dir / cfg.run.run_id\n    run_dir.mkdir(parents=True, exist_ok=True)\n\n    # ---------------------------------------------------------------------\n    # Trial-mode configuration tweaks -------------------------------------\n    # ---------------------------------------------------------------------\n    if cfg.trial_mode:\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.enabled = False\n        cfg.training.epochs = 1\n        cfg.training.inner_steps = 1\n        cfg.dataset.batch_size = min(cfg.dataset.batch_size, 2)\n        cfg.training.log_interval = 1\n\n    # ---------------------------------------------------------------------\n    # Reproducibility, device selection -----------------------------------\n    # ---------------------------------------------------------------------\n    set_seed(cfg.seed)\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ---------------------------------------------------------------------\n    # Hyper-parameter sweep (Optuna) --------------------------------------\n    # ---------------------------------------------------------------------\n    if cfg.optuna.enabled and cfg.optuna.n_trials \u003e 0:\n        print(f\"[Optuna] Starting hyper-parameter search for {cfg.optuna.n_trials} trials \u2026\")\n\n        def objective(trial: optuna.Trial) -\u003e float:\n            sampled_params = _suggest_from_space(trial, cfg.optuna.search_space)\n            local_cfg = copy.deepcopy(cfg)\n            for k, v in sampled_params.items():\n                local_cfg.training[k] = v\n            acc = run_training(local_cfg, device=device, use_wandb=False, out_dir=run_dir)\n            return acc  # maximise accuracy\n\n        study = optuna.create_study(direction=cfg.optuna.direction)\n        study.optimize(objective, n_trials=cfg.optuna.n_trials)\n\n        best_params = study.best_params\n        print(f\"[Optuna] Best hyper-parameters: {best_params}\")\n\n        # Persist study artefacts ----------------------------------------\n        with open(run_dir / \"optuna_study.pkl\", \"wb\") as f:\n            pickle.dump(study, f)\n        with open(run_dir / \"optuna_best_params.json\", \"w\") as f:\n            json.dump(best_params, f, indent=2)\n\n        # Update cfg.training with best params ---------------------------\n        for k, v in best_params.items():\n            cfg.training[k] = v\n\n    # ---------------------------------------------------------------------\n    # Initialise WandB (may be disabled) ----------------------------------\n    # ---------------------------------------------------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb_run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            resume=\"allow\",\n            config=OmegaConf.to_container(cfg, resolve=True),\n            mode=cfg.wandb.mode,\n            dir=str(run_dir),\n        )\n        print(\"WandB URL:\", wandb_run.get_url())\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n\n    # ---------------------------------------------------------------------\n    # Final training pass --------------------------------------------------\n    # ---------------------------------------------------------------------\n    final_acc = run_training(cfg, device=device, use_wandb=(cfg.wandb.mode != \"disabled\"), out_dir=run_dir)\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.summary[\"final_top1_accuracy\"] = final_acc\n        wandb.finish()\n\n    print(f\"[Done] Top-1 accuracy: {final_acc:.4f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}

Fix the issues identified above while preserving the correct parts of the implementation.



# Experimental Environment
NVIDIA H200×8
VRAM: 144GB×8
RAM： 2048 GB or more

# Current Research Method
{
    "Open Problems": "Most popular test-time adaptation (TTA) methods such as TENT adapt only BatchNorm affine parameters by minimizing prediction entropy on the incoming test stream. Although very effective, they often require 3-10 gradient steps for each incoming mini-batch to reach their best performance. The slow convergence mainly comes from noisy gradients produced by low-confidence (high-entropy) samples that dominate early in adaptation. A simple mechanism to down-weight these uncertain samples during optimization is missing.",
    "Methods": "Confidence-Weighted Entropy Minimization (CW-TENT).\n1. Keep the original TENT objective L = Σ_i H(p_i) where H is entropy.\n2. Introduce a scalar weight per sample w_i = 1 – H(p_i)/log(C)  (ranges in [0,1]; C = #classes).\n3. Replace the loss with the weighted variant  L_w = Σ_i w_i · H(p_i) / Σ_i w_i.\n4. Use the same SGD update of BatchNorm affine parameters, but with a single gradient step per mini-batch (optionally with momentum=0.9).\nTheoretical intuition: high-confidence samples (low entropy) are already close to the target domain optimum and provide reliable gradients; amplifying their contribution yields a cleaner gradient direction, allowing larger learning rate or fewer steps, hence faster convergence.",
    "Experimental Setup": "Dataset: CIFAR-10-C with 15 corruption types, severity 5 (standard TTA benchmark).\nModel: Pre-trained ResNet-18.\nBaselines: 1) Source model (no adaptation). 2) Original TENT (default 10 inner steps). 3) CW-TENT (1 inner step).\nMetric: Top-1 accuracy after processing the full test stream; also accuracy after first K (e.g., 1, 3) adaptation steps to measure convergence speed.",
    "Experimental Code": "import torch, torch.nn.functional as F\n\ndef entropy(p):\n    return -(p * p.log()).sum(1)\n\nclass CWTentAdapter:\n    def __init__(self, model, lr=1e-3, momentum=0.9):\n        self.model = model.eval()\n        self.model.requires_grad_(False)\n        # enable gradients for affine BN params only\n        for m in model.modules():\n            if isinstance(m, torch.nn.BatchNorm2d):\n                m.weight.requires_grad_(True)\n                m.bias.requires_grad_(True)\n        self.optimizer = torch.optim.SGD(filter(lambda p: p.requires_grad, model.parameters()), lr=lr, momentum=momentum)\n\n    @torch.no_grad()\n    def predict(self, x):\n        return self.model(x).softmax(1)\n\n    def adapt(self, x):\n        self.model.train()        # BN uses batch statistics\n        self.optimizer.zero_grad()\n        logits = self.model(x)\n        probs = logits.softmax(1)\n        H = entropy(probs)\n        w = 1 - H / torch.log(torch.tensor(probs.size(1), device=x.device))\n        loss = (w * H).sum() / w.sum()\n        loss.backward()\n        self.optimizer.step()\n        self.model.eval()\n        return probs.detach()\n",
    "Expected Result": "With only one gradient step per mini-batch, CW-TENT is expected to match or surpass the accuracy of TENT that uses 5–10 steps. For example on CIFAR-10-C severity 5: Source 58.7%, TENT (10 steps) 71.0%, CW-TENT (1 step) ≈71.5%. Convergence plot should show CW-TENT reaching peak accuracy after the first step, whereas TENT needs several.",
    "Expected Conclusion": "A tiny modification—confidence-weighted entropy—suppresses noisy gradients from uncertain samples and lets TENT converge in a single step. The change is trivial to implement (four extra lines) yet meaningfully cuts computation and latency at test time, making TTA more practical for real-time deployment."
}

# Experimental Design
- Summary: The experiment demonstrates that Confidence-Weighted TENT (CW-TENT) enables fast, one-step test-time adaptation by down-weighting high-entropy (low-confidence) samples in the classic entropy-minimisation objective used by TENT. A pre-trained ResNet-18 is sequentially exposed to the CIFAR-10-C corruption stream (severity-5). At every incoming mini-batch the model first produces predictions, then performs one SGD update on BatchNorm affine parameters using the confidence-weighted entropy loss. Performance is evaluated as the stream proceeds and compared against: (1) the frozen source model (no adaptation) and (2) the original TENT that applies 10 inner optimisation steps. All runs share identical data order, initial weights and hardware (8×H200, 144 GB each). Hyper-parameter sweeps on learning-rate, momentum and weight-decay are carried out with random search (30 trials) on a held-out corruption set to obtain fair settings for both CW-TENT and the baseline.
- Evaluation metrics: ['Top-1 Accuracy', 'Average Accuracy After First Adaptation Step']

# Experiment Runs

- Run ID: proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: proposed
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  Config File: config/run/proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5).yaml
  
  Config Content:
  ```yaml
  run_id: 'proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)'
method: cw-tent
model:
  name: resnet18
  pretrained_checkpoint: timm/resnet18.a1_in1k
  num_parameters_m: 11.7
  num_classes: 10
  freeze_except:
    - BatchNorm.weight
    - BatchNorm.bias
dataset:
  name: cifar10c
  root: /datasets/CIFAR-10-C
  corruption_severity: 5
  corruption_types: all
  split: test
  batch_size: 64
  num_workers: 8
  preprocessing:
    normalize:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2023, 0.1994, 0.2010]
training:
  adaptation: true
  objective: confidence_weighted_entropy
  inner_steps: 1
  learning_rate: 0.001
  momentum: 0.9
  weight_decay: 0.0
  optimizer: sgd
  epochs: 1
  scheduler: none
  gradient_clip: null
  stream_mode: sequential
  log_interval: 50
optuna:
  enabled: true
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
hardware:
  gpus: 8
  gpu_type: NVIDIA H200
  vram_per_gpu_gb: 144
  mixed_precision: true
seed: 42

  ```
  

- Run ID: comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: comparative-1
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  Config File: config/run/comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5).yaml
  
  Config Content:
  ```yaml
  run_id: 'comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)'
method: tent
model:
  name: resnet18
  pretrained_checkpoint: timm/resnet18.a1_in1k
  num_parameters_m: 11.7
  num_classes: 10
  freeze_except:
    - BatchNorm.weight
    - BatchNorm.bias
dataset:
  name: cifar10c
  root: /datasets/CIFAR-10-C
  corruption_severity: 5
  corruption_types: all
  split: test
  batch_size: 64
  num_workers: 8
  preprocessing:
    normalize:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2023, 0.1994, 0.2010]
training:
  adaptation: true
  objective: entropy
  inner_steps: 10
  learning_rate: 0.0005
  momentum: 0.9
  weight_decay: 0.0
  optimizer: sgd
  epochs: 1
  scheduler: none
  gradient_clip: null
  stream_mode: sequential
  log_interval: 50
optuna:
  enabled: true
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
    inner_steps:
      type: categorical
      choices: [1, 3, 5, 10]
hardware:
  gpus: 8
  gpu_type: NVIDIA H200
  vram_per_gpu_gb: 144
  mixed_precision: true
seed: 42

  ```
  


# External Resources (Use these for implementation)

**HuggingFace Models:**

- ID: timm/resnet18.a1_in1k

- Code: from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model('resnet18.a1_in1k', pretrained=True)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # unsqueeze single image into batch of 1

top5_probabilities, top5_class_indices = torch.topk(output.softmax(dim=1) * 100, k=5)

from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model(
    'resnet18.a1_in1k',
    pretrained=True,
    features_only=True,
)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # unsqueeze single image into batch of 1

for o in output:
    # print shape of each feature map in output
    # e.g.:
    #  torch.Size([1, 64, 112, 112])
    #  torch.Size([1, 64, 56, 56])
    #  torch.Size([1, 128, 28, 28])
    #  torch.Size([1, 256, 14, 14])
    #  torch.Size([1, 512, 7, 7])

    print(o.shape)

from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model(
    'resnet18.a1_in1k',
    pretrained=True,
    num_classes=0,  # remove classifier nn.Linear
)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # output is (batch_size, num_features) shaped tensor

# or equivalently (without needing to set num_classes=0)

output = model.forward_features(transforms(img).unsqueeze(0))
# output is unpooled, a (1, 512, 7, 7) shaped tensor

output = model.forward_head(output, pre_logits=True)
# output is a (1, num_features) shaped tensor



**HuggingFace Datasets:**



Generate complete, production-ready experiment code that integrates with Hydra configuration system.
Output:
{
    "train_py": "# src/train.py\n\"\"\"Single experiment run executor with Optuna support.\n\nThis script performs the full training / adaptation loop for one experiment run.\nIf `cfg.optuna.enabled` is *true* and `n_trials>0`, an Optuna hyper-parameter\nsearch is carried out first (WandB logging *disabled* during the sweep).  The\nbest hyper-parameters are then used for the final training run which is logged\non WandB under the ID `cfg.run.run_id`.\n\nIn **trial_mode** the script executes a highly abbreviated pass (1–2 batches,\n1 epoch) and *disables WandB* automatically.\n\"\"\"\nfrom __future__ import annotations\n\nimport copy\nimport json\nimport os\nimport pickle\nimport random\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport hydra\nimport numpy as np\nimport optuna\nimport torch\nimport torch.nn.functional as F\nimport wandb\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.metrics import confusion_matrix\n\nfrom src.model import create_model\nfrom src.preprocess import get_dataloader\n\n# ----------------------------------------------------------------------------\n# Cache directories (HF/TIMM/torch) ------------------------------------------\n# ----------------------------------------------------------------------------\nos.environ.setdefault(\"HF_HOME\", \".cache/\")\nos.environ.setdefault(\"TORCH_HOME\", \".cache/\")\n\n# ----------------------------------------------------------------------------\n# Utility functions -----------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef set_seed(seed: int) -> None:\n    \"\"\"Make experiment deterministic (as much as possible).\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef entropy(probs: torch.Tensor) -> torch.Tensor:\n    \"\"\"Per-sample entropy of a probability distribution.\"\"\"\n    return -(probs * (probs + 1e-8).log()).sum(1)\n\n# ----------------------------------------------------------------------------\n# Core training logic ---------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef run_training(\n    cfg: DictConfig,\n    *,\n    device: torch.device,\n    use_wandb: bool,\n    out_dir: Path,\n) -> float:  # noqa: C901\n    \"\"\"Run the adaptation loop once with the hyper-parameters present in *cfg*.\n\n    Parameters\n    ----------\n    cfg : DictConfig\n        The fully-resolved Hydra configuration.\n    device : torch.device\n        Training device.\n    use_wandb : bool\n        Whether to emit logs to WandB.\n    out_dir : Path\n        Directory where auxiliary artefacts (e.g. confusion matrix) are stored.\n\n    Returns\n    -------\n    float\n        Final top-1 accuracy after processing the complete data stream.\n    \"\"\"\n    dataloader = get_dataloader(cfg, split=cfg.dataset.get(\"split\", \"test\"))\n    model = create_model(cfg).to(device)\n    model.eval()\n\n    trainable_params: List[torch.nn.Parameter] = [p for p in model.parameters() if p.requires_grad]\n    if cfg.training.adaptation and len(trainable_params) == 0:\n        raise RuntimeError(\n            \"Adaptation requested but the model exposes no trainable parameters.\")\n\n    optim_cls = {\"sgd\": torch.optim.SGD, \"adam\": torch.optim.Adam}[cfg.training.optimizer]\n    optimizer = optim_cls(\n        trainable_params,\n        lr=cfg.training.learning_rate,\n        momentum=getattr(cfg.training, \"momentum\", 0.0),\n        weight_decay=cfg.training.weight_decay,\n    )\n\n    scaler = torch.cuda.amp.GradScaler(enabled=cfg.hardware.mixed_precision)\n\n    global_step = 0\n    preds_all, targets_all = [], []\n    accum_loss = 0.0\n    accum_samples = 0\n\n    for epoch in range(cfg.training.epochs):\n        for batch_idx, (inputs, targets) in enumerate(dataloader):\n            inputs = inputs.to(device, non_blocking=True)\n            targets = targets.to(device, non_blocking=True)\n            bs = targets.size(0)\n            accum_samples += bs\n\n            # ------------------------------------------------------------\n            # Forward pass BEFORE adaptation (for reporting only)\n            # ------------------------------------------------------------\n            with torch.no_grad():\n                logits = model(inputs)\n                probs = F.softmax(logits, dim=1)\n                preds_pre = probs.argmax(1)\n                batch_acc = preds_pre.eq(targets).float().mean().item()\n\n            # ------------------------------------------------------------\n            # Adaptation step (if enabled)\n            # ------------------------------------------------------------\n            if cfg.training.adaptation:\n                model.train()  # ensure BN uses current batch stats\n                for _ in range(cfg.training.inner_steps):\n                    optimizer.zero_grad(set_to_none=True)\n                    with torch.cuda.amp.autocast(enabled=cfg.hardware.mixed_precision):\n                        logits_adapt = model(inputs)\n                        probs_adapt = F.softmax(logits_adapt, dim=1)\n                        H = entropy(probs_adapt)\n                        if cfg.training.objective == \"entropy\":\n                            loss = H.mean()\n                        elif cfg.training.objective == \"confidence_weighted_entropy\":\n                            w = 1.0 - H / np.log(probs_adapt.size(1))\n                            loss = (w * H).sum() / w.sum()\n                        else:\n                            raise ValueError(\n                                f\"Unknown objective {cfg.training.objective}\")\n                    scaler.scale(loss).backward()\n                    if cfg.training.gradient_clip is not None:\n                        scaler.unscale_(optimizer)\n                        torch.nn.utils.clip_grad_norm_(\n                            trainable_params, cfg.training.gradient_clip)\n                    scaler.step(optimizer)\n                    scaler.update()\n                model.eval()\n                loss_val = loss.detach().item()\n            else:\n                loss_val = 0.0\n\n            accum_loss += loss_val * bs\n\n            # ------------------------------------------------------------\n            # Forward AFTER adaptation (used for final accuracy statistics)\n            # ------------------------------------------------------------\n            with torch.no_grad():\n                logits_final = model(inputs)\n                preds_final = logits_final.softmax(1).argmax(1)\n            preds_all.append(preds_final.cpu())\n            targets_all.append(targets.cpu())\n\n            # ------------------------------------------------------------\n            # WandB logging\n            # ------------------------------------------------------------\n            if use_wandb and (batch_idx % cfg.training.log_interval == 0):\n                wandb.log({\n                    \"batch_accuracy\": batch_acc,\n                    \"adapt_loss\": loss_val,\n                    \"seen_samples\": accum_samples,\n                    \"epoch\": epoch,\n                }, step=global_step)\n\n            global_step += 1\n\n            # ------------------------------------------------------------\n            # Trial-mode early exit (keep execution lightweight)\n            # ------------------------------------------------------------\n            if cfg.trial_mode and batch_idx >= 1:\n                break\n        if cfg.trial_mode:\n            break\n\n    preds_all_tensor = torch.cat(preds_all)\n    targets_all_tensor = torch.cat(targets_all)\n    final_acc = preds_all_tensor.eq(targets_all_tensor).float().mean().item()\n\n    avg_loss = accum_loss / max(accum_samples, 1)\n    conf_mat = confusion_matrix(targets_all_tensor.numpy(),\n                                preds_all_tensor.numpy())\n    np.save(out_dir / \"confusion_matrix.npy\", conf_mat.astype(np.int32))\n\n    if use_wandb:\n        wandb.log({\n            \"top1_accuracy\": final_acc,\n            \"avg_adapt_loss\": avg_loss,\n            \"conf_mat\": conf_mat.tolist(),\n        })\n\n    return final_acc\n\n# ----------------------------------------------------------------------------\n# Optuna helpers --------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _suggest_from_space(trial: optuna.Trial, space: Dict) -> Dict[str, float | int | str]:\n    \"\"\"Sample a set of hyper-parameters from *space* using *trial*.\"\"\"\n    sampled: Dict[str, float | int | str] = {}\n    for param, spec in space.items():\n        p_type = spec[\"type\"]\n        if p_type == \"loguniform\":\n            sampled[param] = trial.suggest_float(\n                param, spec[\"low\"], spec[\"high\"], log=True)\n        elif p_type == \"uniform\":\n            sampled[param] = trial.suggest_float(\n                param, spec[\"low\"], spec[\"high\"], log=False)\n        elif p_type == \"int\":\n            sampled[param] = trial.suggest_int(\n                param, spec[\"low\"], spec[\"high\"], log=spec.get(\"log\", False))\n        elif p_type == \"categorical\":\n            sampled[param] = trial.suggest_categorical(param, spec[\"choices\"])\n        else:\n            raise ValueError(f\"Unsupported Optuna parameter type: {p_type}\")\n    return sampled\n\n# ----------------------------------------------------------------------------\n# Hydra entry-point -----------------------------------------------------------\n# ----------------------------------------------------------------------------\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg: DictConfig) -> None:  # noqa: C901 (complex but cohesive)\n    # ---------------------------------------------------------------------\n    # Resolve absolute output directory -----------------------------------\n    # ---------------------------------------------------------------------\n    orig_cwd = Path(get_original_cwd()).resolve()\n    results_dir_cfg = Path(cfg.results_dir)\n    results_dir = (\n        results_dir_cfg\n        if results_dir_cfg.is_absolute()\n        else (orig_cwd / results_dir_cfg).resolve()\n    )\n    run_dir: Path = results_dir / cfg.run.run_id\n    run_dir.mkdir(parents=True, exist_ok=True)\n\n    # ---------------------------------------------------------------------\n    # Trial-mode configuration tweaks -------------------------------------\n    # ---------------------------------------------------------------------\n    if cfg.trial_mode:\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.enabled = False\n        cfg.training.epochs = 1\n        cfg.training.inner_steps = 1\n        cfg.dataset.batch_size = min(cfg.dataset.batch_size, 2)\n        cfg.training.log_interval = 1\n\n    # ---------------------------------------------------------------------\n    # Reproducibility & device selection ----------------------------------\n    # ---------------------------------------------------------------------\n    set_seed(cfg.seed)\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ---------------------------------------------------------------------\n    # Hyper-parameter sweep (Optuna) --------------------------------------\n    # ---------------------------------------------------------------------\n    if cfg.optuna.enabled and cfg.optuna.n_trials > 0:\n        print(\n            f\"[Optuna] Starting hyper-parameter search for {cfg.optuna.n_trials} trials …\"\n        )\n\n        def objective(trial: optuna.Trial) -> float:\n            sampled_params = _suggest_from_space(trial, cfg.optuna.search_space)\n            local_cfg = copy.deepcopy(cfg)\n            for k, v in sampled_params.items():\n                local_cfg.training[k] = v\n            return run_training(\n                local_cfg, device=device, use_wandb=False, out_dir=run_dir\n            )\n\n        study = optuna.create_study(direction=cfg.optuna.direction)\n        study.optimize(objective, n_trials=cfg.optuna.n_trials)\n\n        best_params = study.best_params\n        print(f\"[Optuna] Best hyper-parameters: {best_params}\")\n\n        # Persist study artefacts -----------------------------------------\n        with open(run_dir / \"optuna_study.pkl\", \"wb\") as f:\n            pickle.dump(study, f)\n        with open(run_dir / \"optuna_best_params.json\", \"w\") as f:\n            json.dump(best_params, f, indent=2)\n\n        # Update cfg.training with best params ----------------------------\n        for k, v in best_params.items():\n            cfg.training[k] = v\n\n    # ---------------------------------------------------------------------\n    # Initialise WandB (may be disabled) ----------------------------------\n    # ---------------------------------------------------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb_run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            resume=\"allow\",\n            config=OmegaConf.to_container(cfg, resolve=True),\n            mode=cfg.wandb.mode,\n            dir=str(run_dir),\n        )\n        print(\"WandB URL:\", wandb_run.get_url())\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n\n    # ---------------------------------------------------------------------\n    # Final training pass --------------------------------------------------\n    # ---------------------------------------------------------------------\n    final_acc = run_training(\n        cfg,\n        device=device,\n        use_wandb=(cfg.wandb.mode != \"disabled\"),\n        out_dir=run_dir,\n    )\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.summary[\"final_top1_accuracy\"] = final_acc\n        wandb.finish()\n\n    print(f\"[Done] Top-1 accuracy: {final_acc:.4f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "evaluate_py": "# src/evaluate.py\n\"\"\"Independent evaluation / visualisation script.\n\nExample CLI:\n    uv run python -m src.evaluate results_dir=./results run_ids='[\"run-1\", \"run-2\"]'\n\"\"\"\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy import stats\n\n# ----------------------------------------------------------------------------\n# CLI parsing ----------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _parse_kv_cli() -> Dict[str, str]:\n    cli_kv: Dict[str, str] = {}\n    for arg in sys.argv[1:]:\n        if \"=\" not in arg:\n            raise ValueError(\n                f\"Unexpected argument format: '{arg}'. Expected key=value pairs.\")\n        k, v = arg.split(\"=\", 1)\n        cli_kv[k] = v\n    required = {\"results_dir\", \"run_ids\"}\n    missing = required - cli_kv.keys()\n    if missing:\n        raise ValueError(f\"Missing required CLI keys: {missing}\")\n    return cli_kv\n\n# ----------------------------------------------------------------------------\n# WandB helpers ---------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _load_wandb_config(results_dir: Path) -> Dict:\n    cfg_path = results_dir / \"config.yaml\"\n    if not cfg_path.exists():\n        raise FileNotFoundError(\n            f\"Expected {cfg_path} (copied by main.py) but file does not exist.\")\n    with cfg_path.open(\"r\") as f:\n        return yaml.safe_load(f)\n\n# ----------------------------------------------------------------------------\n# Per-run processing ----------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _export_metrics(df: pd.DataFrame, out_file: Path) -> None:\n    df.to_json(out_file, orient=\"records\", lines=True)\n\n\ndef _plot_learning_curves(\n    df: pd.DataFrame, run_id: str, out_dir: Path\n) -> List[Path]:\n    figs: List[Path] = []\n    metrics_to_plot = [c for c in [\"batch_accuracy\", \"top1_accuracy\"] if c in df.columns]\n    for metric in metrics_to_plot:\n        plt.figure(figsize=(6, 4))\n        sns.lineplot(data=df, x=df.index, y=metric)\n        plt.title(f\"{run_id} – {metric}\")\n        plt.xlabel(\"Step\")\n        plt.ylabel(metric)\n        if df[metric].dropna().size:\n            final_val = df[metric].dropna().iloc[-1]\n            plt.annotate(\n                f\"{final_val:.4f}\",\n                xy=(df.index[-1], final_val),\n                xytext=(-40, 10),\n                textcoords=\"offset points\",\n            )\n        plt.tight_layout()\n        fig_path = out_dir / f\"learning_curve_{metric}.pdf\"\n        plt.savefig(fig_path)\n        plt.close()\n        figs.append(fig_path)\n    return figs\n\n\ndef _plot_confusion_matrix(\n    conf_mat: np.ndarray, class_names: List[str], title: str, out_path: Path\n) -> None:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(\n        conf_mat,\n        annot=True,\n        fmt=\"d\",\n        cmap=\"Blues\",\n        xticklabels=class_names,\n        yticklabels=class_names,\n    )\n    plt.ylabel(\"True label\")\n    plt.xlabel(\"Predicted label\")\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\ndef per_run_processing(\n    api: wandb.Api,\n    entity: str,\n    project: str,\n    run_id: str,\n    run_dir: Path,\n    class_names: List[str],\n) -> Dict:\n    run = api.run(f\"{entity}/{project}/{run_id}\")\n    history_df = run.history(pandas=True)\n\n    # --------------------------------------------------------------------\n    # Raw metrics --------------------------------------------------------\n    # --------------------------------------------------------------------\n    _export_metrics(history_df, run_dir / \"metrics.json\")\n\n    # --------------------------------------------------------------------\n    # Plots --------------------------------------------------------------\n    # --------------------------------------------------------------------\n    fig_paths = _plot_learning_curves(history_df, run_id, run_dir)\n\n    conf_mat = None\n    if \"conf_mat\" in run.summary:\n        conf_mat = np.array(run.summary[\"conf_mat\"], dtype=int)\n    else:\n        local_conf = run_dir / \"confusion_matrix.npy\"\n        if local_conf.exists():\n            conf_mat = np.load(local_conf)\n    if conf_mat is not None:\n        cm_path = run_dir / \"confusion_matrix.pdf\"\n        _plot_confusion_matrix(\n            conf_mat, class_names, f\"{run_id} – Confusion Matrix\", cm_path\n        )\n        fig_paths.append(cm_path)\n\n    final_acc = (\n        float(history_df[\"top1_accuracy\"].dropna().iloc[-1])\n        if \"top1_accuracy\" in history_df.columns and not history_df[\"top1_accuracy\"].dropna().empty\n        else None\n    )\n\n    print(f\"[Per-run] Generated files for {run_id}:\")\n    for p in fig_paths:\n        print(\"  •\", p)\n\n    return {\n        \"run_id\": run_id,\n        \"final_accuracy\": final_acc,\n    }\n\n# ----------------------------------------------------------------------------\n# Aggregated analysis ---------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef aggregated_analysis(per_run_stats: List[Dict], results_dir: Path) -> None:\n    comp_dir = results_dir / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    agg_path = comp_dir / \"aggregated_metrics.json\"\n    with agg_path.open(\"w\") as f:\n        json.dump(per_run_stats, f, indent=2)\n    print(\"Aggregated metrics saved to\", agg_path)\n\n    df = pd.DataFrame(per_run_stats)\n    plt.figure(figsize=(8, 4))\n    sns.barplot(data=df, x=\"run_id\", y=\"final_accuracy\", palette=\"viridis\")\n    plt.xticks(rotation=45, ha=\"right\")\n    for idx, row in df.iterrows():\n        plt.text(idx, row[\"final_accuracy\"] + 0.2, f\"{row['final_accuracy']:.2f}\", ha=\"center\")\n    plt.ylabel(\"Final Top-1 Accuracy\")\n    plt.title(\"Final Accuracy across Runs\")\n    plt.tight_layout()\n    bar_path = comp_dir / \"final_accuracy_comparison.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    print(\"Created\", bar_path)\n\n# ----------------------------------------------------------------------------\n# Main -----------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef main() -> None:\n    cli_kv = _parse_kv_cli()\n    results_dir = Path(cli_kv[\"results_dir\"]).expanduser().resolve()\n    run_ids = json.loads(cli_kv[\"run_ids\"])\n\n    wandb_cfg = _load_wandb_config(results_dir)\n    entity = wandb_cfg[\"wandb\"][\"entity\"]\n    project = wandb_cfg[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n    class_names = [str(i) for i in range(10)]  # CIFAR-10 default\n\n    per_run_stats: List[Dict] = []\n    for rid in run_ids:\n        run_dir = results_dir / rid\n        run_dir.mkdir(parents=True, exist_ok=True)\n        stats = per_run_processing(api, entity, project, rid, run_dir, class_names)\n        per_run_stats.append(stats)\n\n    aggregated_analysis(per_run_stats, results_dir)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "preprocess_py": "# src/preprocess.py\n\"\"\"Data loading & preprocessing utilities for CIFAR-10-C.\"\"\"\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import List\n\nimport numpy as np\nimport torchvision.transforms as T\nfrom omegaconf import DictConfig\nfrom torch.utils.data import DataLoader, Dataset\n\n# ----------------------------------------------------------------------------\n# Dataset wrapper -------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\nCIFAR10C_TYPES: List[str] = [\n    \"gaussian_noise\",\n    \"shot_noise\",\n    \"impulse_noise\",\n    \"defocus_blur\",\n    \"glass_blur\",\n    \"motion_blur\",\n    \"zoom_blur\",\n    \"snow\",\n    \"frost\",\n    \"fog\",\n    \"brightness\",\n    \"contrast\",\n    \"elastic_transform\",\n    \"pixelate\",\n    \"jpeg_compression\",\n]\n\n\nclass CIFAR10CDataset(Dataset):\n    \"\"\"Subset of CIFAR-10-C at a given corruption severity.\"\"\"\n\n    def __init__(\n        self,\n        root: str | Path,\n        corruption_types: str | List[str],\n        severity: int,\n        transform=None,\n    ):\n        super().__init__()\n        self.transform = transform\n        root = Path(root)\n        if isinstance(corruption_types, str):\n            types = CIFAR10C_TYPES if corruption_types == \"all\" else [corruption_types]\n        else:\n            types = corruption_types\n\n        images_col, labels_col = [], []\n        labels_np = np.load(root / \"labels.npy\")\n        for c_type in types:\n            data = np.load(root / f\"{c_type}.npy\")\n            start, end = (severity - 1) * 10_000, severity * 10_000\n            images_col.append(data[start:end])\n            labels_col.append(labels_np[start:end])\n        self.data = np.concatenate(images_col, axis=0)\n        self.targets = np.concatenate(labels_col, axis=0)\n\n    def __len__(self):\n        return len(self.targets)\n\n    def __getitem__(self, idx: int):\n        img = self.data[idx].astype(np.uint8)\n        label = int(self.targets[idx])\n        img = T.functional.to_pil_image(img)\n        if self.transform:\n            img = self.transform(img)\n        return img, label\n\n# ----------------------------------------------------------------------------\n# Transform helpers -----------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _build_transforms(pre_cfg: DictConfig | None):\n    transforms = [T.ToTensor()]\n    if pre_cfg and pre_cfg.get(\"normalize\") is not None:\n        mean = pre_cfg.normalize.mean\n        std = pre_cfg.normalize.std\n        transforms.append(T.Normalize(mean=mean, std=std))\n    return T.Compose(transforms)\n\n# ----------------------------------------------------------------------------\n# Public API ------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef get_dataloader(cfg: DictConfig, *, split: str = \"test\") -> DataLoader:\n    \"\"\"Return a DataLoader for CIFAR-10-C.\n\n    Currently only the *test* split is meaningful for CIFAR-10-C.\n    \"\"\"\n    assert (\n        cfg.dataset.name.lower() == \"cifar10c\"\n    ), \"Only CIFAR-10-C supported currently.\"\n    transform = _build_transforms(cfg.dataset.get(\"preprocessing\", None))\n    dataset = CIFAR10CDataset(\n        root=cfg.dataset.root,\n        corruption_types=cfg.dataset.corruption_types,\n        severity=cfg.dataset.corruption_severity,\n        transform=transform,\n    )\n    return DataLoader(\n        dataset,\n        batch_size=cfg.dataset.batch_size,\n        shuffle=False,\n        num_workers=cfg.dataset.num_workers,\n        pin_memory=True,\n    )\n",
    "model_py": "# src/model.py\n\"\"\"Model builder utilities (timm-based with selective BN unfreezing).\"\"\"\nfrom __future__ import annotations\n\nimport os\nfrom typing import List\n\nimport timm\nimport torch\nfrom omegaconf import DictConfig\n\n# Ensure weight downloads are cached under ./.cache\nos.environ.setdefault(\"HF_HOME\", \".cache/\")\nos.environ.setdefault(\"TORCH_HOME\", \".cache/\")\n\n# ----------------------------------------------------------------------------\n# Helpers --------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef _freeze_all(model: torch.nn.Module):\n    for p in model.parameters():\n        p.requires_grad_(False)\n\n\ndef _unfreeze_matching(model: torch.nn.Module, patterns: List[str] | None):\n    \"\"\"Re-enable gradients for parameters matching *patterns*.\n\n    The function additionally supports special tokens \"batchnorm.weight\" and\n    \"batchnorm.bias\" (case-insensitive) which directly target all BatchNorm\n    affine parameters regardless of their names.\n    \"\"\"\n    if patterns is None:\n        return\n\n    patterns_lower = [p.lower() for p in patterns]\n\n    # Special handling for BatchNorm affine parameters -------------------\n    if \"batchnorm.weight\" in patterns_lower or \"batchnorm.bias\" in patterns_lower:\n        for m in model.modules():\n            if isinstance(m, torch.nn.BatchNorm2d):\n                if \"batchnorm.weight\" in patterns_lower and m.weight is not None:\n                    m.weight.requires_grad_(True)\n                if \"batchnorm.bias\" in patterns_lower and m.bias is not None:\n                    m.bias.requires_grad_(True)\n\n    # Generic name-based matching ---------------------------------------\n    for name, param in model.named_parameters():\n        if any(pat in name.lower() for pat in patterns_lower):\n            param.requires_grad_(True)\n\n# ----------------------------------------------------------------------------\n# Public API ------------------------------------------------------------------\n# ----------------------------------------------------------------------------\n\ndef create_model(cfg: DictConfig) -> torch.nn.Module:\n    \"\"\"Instantiate the (potentially pre-trained) model specified in *cfg*.\"\"\"\n    model_name = cfg.model.name\n    num_classes = cfg.model.num_classes\n    checkpoint = cfg.model.get(\"pretrained_checkpoint\", None)\n\n    if checkpoint is not None:\n        # `timm` interprets model names containing a slash as HF-hub IDs.\n        model = timm.create_model(checkpoint, pretrained=True, num_classes=num_classes)\n    else:\n        model = timm.create_model(model_name, pretrained=True, num_classes=num_classes)\n\n    # Freeze all parameters then selectively unfreeze according to cfg.\n    _freeze_all(model)\n    _unfreeze_matching(model, cfg.model.get(\"freeze_except\", None))\n    return model\n",
    "main_py": "# src/main.py\n\"\"\"Main orchestrator.\n\nThis script receives a `run=<run_id>` override from the CLI, writes the fully\nresolved Hydra config to `<results_dir>/config.yaml`, and launches `src.train`\nas a subprocess while forwarding all CLI overrides.\n\"\"\"\nfrom __future__ import annotations\n\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport hydra\nimport yaml\nfrom hydra.core.hydra_config import HydraConfig\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg):\n    # ------------------------------------------------------------------\n    # Results directory (absolute path) --------------------------------\n    # ------------------------------------------------------------------\n    orig_cwd = Path(get_original_cwd()).resolve()\n    results_dir_cfg = Path(cfg.results_dir)\n    results_dir = (\n        results_dir_cfg\n        if results_dir_cfg.is_absolute()\n        else (orig_cwd / results_dir_cfg).resolve()\n    )\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    # ------------------------------------------------------------------\n    # Persist resolved config for evaluation script --------------------\n    # ------------------------------------------------------------------\n    with (results_dir / \"config.yaml\").open(\"w\") as f:\n        yaml.safe_dump(OmegaConf.to_container(cfg, resolve=True), f)\n\n    # ------------------------------------------------------------------\n    # Forward CLI overrides to train.py --------------------------------\n    # ------------------------------------------------------------------\n    overrides = [\n        ov for ov in HydraConfig.get().overrides.task if not ov.startswith(\"results_dir=\")\n    ]\n    overrides.append(f\"results_dir={results_dir}\")\n\n    # Ensure trial-mode disables WandB ---------------------------------\n    if cfg.trial_mode and not any(ov.startswith(\"wandb.mode=\") for ov in overrides):\n        overrides.append(\"wandb.mode=disabled\")\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\"] + overrides\n    print(\"Executing:\", \" \".join(cmd))\n\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject_toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cw-tent-experiment\"\nversion = \"0.3.0\"\ndescription = \"Hydra-driven experiments for Confidence-Weighted TENT\"\nrequires-python = \">=3.9\"\n\n[project.dependencies]\ntorch = \"*\"\ntorchvision = \"*\"\ntimm = \"*\"\nnumpy = \"*\"\nwandb = \"*\"\nhydra-core = \"*\"\noptuna = \"*\"\nscikit-learn = \"*\"\nscipy = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nPyYAML = \"*\"\npandas = \"*\"\n",
    "config_yaml": "# config/config.yaml\n# -----------------------------------------------------------------------------\n# Global defaults --------------------------------------------------------------\n# -----------------------------------------------------------------------------\n\ndefaults:\n  - _self_\n  - run: ??  # MUST be overridden from CLI, e.g. run=proposed_resnet18_cifar10c\n\n# -----------------------------------------------------------------------------\n# Global random seed & execution mode -----------------------------------------\n# -----------------------------------------------------------------------------\nseed: 42\ntrial_mode: false  # set automatically via CLI `trial_mode=true`\nresults_dir: ./results\n\n# -----------------------------------------------------------------------------\n# Weights & Biases -------------------------------------------------------------\n# -----------------------------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online  # switched to \"disabled\" automatically in trial_mode\n\n# -----------------------------------------------------------------------------\n# Hardware settings -----------------------------------------------------------\n# -----------------------------------------------------------------------------\nhardware:\n  gpus: 1\n  mixed_precision: true\n\n# -----------------------------------------------------------------------------\n# Dataset placeholder (overridden by run configs) -----------------------------\n# -----------------------------------------------------------------------------\ndataset:\n  name: cifar10c\n  root: /path/to/cifar10c\n  corruption_severity: 5\n  corruption_types: all\n  batch_size: 64\n  num_workers: 4\n  preprocessing:\n    normalize:\n      mean: [0.4914, 0.4822, 0.4465]\n      std:  [0.2023, 0.1994, 0.2010]\n\n# -----------------------------------------------------------------------------\n# Training hyper-parameters ----------------------------------------------------\n# -----------------------------------------------------------------------------\ntraining:\n  adaptation: false\n  objective: entropy\n  inner_steps: 1\n  learning_rate: 0.001\n  optimizer: sgd\n  momentum: 0.9\n  weight_decay: 0.0\n  epochs: 1\n  gradient_clip: null\n  log_interval: 50\n\n# -----------------------------------------------------------------------------\n# Optuna defaults -------------------------------------------------------------\n# -----------------------------------------------------------------------------\noptuna:\n  enabled: false\n  n_trials: 0\n  direction: maximize\n  metric: top1_accuracy\n  search_space: {}\n\n# -----------------------------------------------------------------------------\n# Run placeholder -------------------------------------------------------------\n# -----------------------------------------------------------------------------\nrun:\n  run_id: default\n  method: baseline\n  model:\n    name: resnet18\n    num_classes: 10\n    freeze_except:\n      - batchnorm.weight\n      - batchnorm.bias\n"
}
