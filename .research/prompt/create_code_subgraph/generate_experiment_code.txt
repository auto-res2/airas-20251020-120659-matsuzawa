
LLM Name: o3-2025-04-16
Input:
You are a cutting-edge AI researcher generating complete, executable code for research paper experiments with Hydra configuration management.

Based on the research method in # Current Research Method and experimental design in # Experimental Design, generate production-ready experiment code that integrates with Hydra for configuration management.

# Instructions: Complete Experiment Code Generation

## Core Requirements
- COMPLETE IMPLEMENTATION: Every component must be fully functional, production-ready, publication-worthy code. No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
- PYTORCH EXCLUSIVELY: Use PyTorch as the deep learning framework
- HYDRA INTEGRATION: Use Hydra to manage all experiment configurations from `config/run/*.yaml` files. Use `config_path="../config"` in all @hydra.main decorators
- COMPLETE DATA PIPELINE: Full data loading and preprocessing implementation. Use `.cache/` as the cache directory for all datasets and models (e.g., for HuggingFace, set `cache_dir=".cache/"`)
- WANDB REQUIRED: WandB is mandatory for metrics logging (except trial_mode validation)

## Hydra Configuration Structure
Each run config file (`config/run/{run_id}.yaml`) contains:
- run_id: Unique identifier for this run
- method: The method name (baseline, proposed, ablation, etc.)
- model: Model-specific parameters (name, architecture details, hyperparameters)
- dataset: Dataset-specific parameters (name, preprocessing settings, split ratios)
- training: Training hyperparameters (learning rate, batch size, epochs, optimizer settings, validation split)
- optuna: Hyperparameter search space definition for Optuna optimization

## Command Line Interface
The generated code must support the following CLI:

**Training (main.py):**
```bash
# Full experiment with WandB logging
uv run python -u -m src.main run={run_id} results_dir={path}

# Trial mode (validation only, WandB disabled)
uv run python -u -m src.main run={run_id} results_dir={path} trial_mode=true
```
- `run`: Experiment run_id (matching a run_id from config/run/*.yaml)
- `results_dir`: Output directory (passed from GitHub Actions workflow)
- `trial_mode=true` (optional): Lightweight execution for validation (epochs=1, batches limited to 1-2, disable Optuna n_trials=0, **WandB disabled**)

**Evaluation (evaluate.py, independent execution):**
```bash
uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'
```
- `results_dir`: Directory containing experiment metadata and where outputs will be saved
- `run_ids`: JSON string list of run IDs to evaluate (e.g., '["run-1-proposed-bert-glue", "run-2-baseline-bert-glue"]')
- Executed as a separate workflow after all training runs complete
- **NOT called from main.py**

## Script Structure (ExperimentCode format)
Generate complete code for these files ONLY. Do not create any additional files beyond this structure:

**`src/train.py`**: Single experiment run executor
- Uses Hydra config to load all parameters
- Called as subprocess by main.py
- Responsibilities:
  * Train model with given configuration
  * Initialize WandB: `wandb.init(entity=cfg.wandb.entity, project=cfg.wandb.project, id=cfg.run.run_id, config=OmegaConf.to_container(cfg, resolve=True), resume="allow")`
  * Skip `wandb.init()` if `cfg.wandb.mode == "disabled"` (trial_mode)
  * Log ALL metrics to WandB: `wandb.log({"train_loss": 0.5, "val_acc": 0.85, "epoch": 1, ...})`
  * Print WandB run URL to stdout
- **NO results.json, no stdout JSON output, no figure generation**

**`src/evaluate.py`**: Independent evaluation and visualization script
- **Execution**: Run independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
- **NOT called from main.py** - executes as separate workflow after all training completes
- **Responsibilities**:
  * Parse command line arguments:
    - `results_dir`: Output directory path
    - `run_ids`: JSON string list of run IDs (parse with `json.loads(args.run_ids)`)
  * Load WandB config from `{results_dir}/config.yaml`
  * Retrieve experimental data from WandB API for specified run_ids:
    ```python
    import json
    api = wandb.Api()
    run_ids = json.loads(args.run_ids)  # Parse JSON string to list
    for run_id in run_ids:
        run = api.run(f"{entity}/{project}/{run_id}")
        metrics_df = run.history()  # pandas DataFrame with all logged metrics
    ```
  * **STEP 1: Per-Run Processing** (for each run_id):
    - Export run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
    - Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
    - Each run should have its own subdirectory with its metrics and figures
  * **STEP 2: Aggregated Analysis** (after processing all runs):
    - Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
    - Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
    - Generate comparison figures to: `{results_dir}/comparison/`:
      * Cross-run comparison charts (bar charts, box plots)
      * Performance metrics tables
      * Statistical significance tests
  * **Figure Generation Guidelines**:
    - Use matplotlib or seaborn with proper legends, annotations, tight_layout
    - For line graphs: annotate significant values (final/best values)
    - For bar graphs: annotate values above each bar
    - Follow naming convention: `<figure_topic>[_<condition>][_pairN].pdf`
  * Print all generated file paths to stdout (both per-run and comparison)

**`src/preprocess.py`**: Complete preprocessing pipeline implementation for the specified datasets

**`src/model.py`**: Complete model architecture implementations for all methods (proposed and comparative methods)

**`src/main.py`**: Main orchestrator
- Receives run_id via Hydra, launches train.py as subprocess, manages logs
- **DOES NOT call evaluate.py** (evaluate.py runs independently in separate workflow)
- Use `@hydra.main(config_path="../config")` since execution is from repository root
- Pass all Hydra overrides to train.py subprocess (e.g., `wandb.mode=disabled`, `trial_mode=true`)
- In trial_mode, automatically set `wandb.mode=disabled`

**`config/config.yaml`**: Main Hydra configuration file
- MUST include WandB configuration:
  ```yaml
  wandb:
    entity: gengaru617-personal
    project: 251020-test
    mode: online  # Automatically set to "disabled" in trial_mode
  ```

**`pyproject.toml`**: Complete project dependencies
- MUST include: `hydra-core`, `wandb` (required)
- Include as needed: `optuna`, `torch`, `transformers`, `datasets`, etc.


## Key Implementation Focus Areas
1. **Hydra-Driven Configuration**: All parameters loaded from run configs dynamically
2. **Algorithm Core**: Full implementation of the proposed method with proper abstraction
3. **Trial Mode Behavior**: trial_mode=true automatically disables WandB (sets wandb.mode=disabled)
4. **Run Execution**: main.py executes a single run_id passed via CLI (GitHub Actions dispatches multiple runs separately)
5. **WandB Integration**: All metrics logged to WandB; train.py does NOT output JSON to stdout or save results.json
6. **Independent Evaluation**: evaluate.py runs separately, fetches data from WandB API, generates all figures



## Code Validation Feedback


**Previous Validation Issue**: Syntax error in src/preprocess.py: function load_cifar10c defines a keyword-only argument without a default (cache_dir) after arguments that have defaults (severity, corruption_types). Python raises "non-default argument follows default argument", preventing the whole package from importing. Reorder the parameters or supply a default value for cache_dir. No code can run until this is fixed.
**Action Required**: Address this issue in the implementation.

**Previous Code (for reference)**:
{"config_yaml": "defaults:\n  - _self_\n  - run: ???\n\n# Global switches -------------------------------------------------------------\ntrial_mode: false            # set to true via CLI for lightweight CI validation\nresults_dir: ./results       # can be overridden from CLI\n\n# WandB configuration ---------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online               # automatically switched to \"disabled\" in trial_mode\n\n# Optuna (overwritten by run configs) -----------------------------------------\noptuna:\n  n_trials: 0\n  direction: maximize\n  metric: top1_accuracy\n  search_space: {}\n", "evaluate_py": "# src/evaluate.py\n\"\"\"Independent evaluation \u0026 visualisation script.\nFetch metrics from WandB and generate per-run and aggregated artefacts.\nConforms to the required CLI:  python -m src.evaluate results_dir={path} run_ids=\u0027[\"run-1\", \u2026]\u0027\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy import stats\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\n\nsns.set(style=\"whitegrid\")\n\n###############################################################################\n# Argument parsing ------------------------------------------------------------\n###############################################################################\n\ndef _parse_cli() -\u003e Tuple[Path, List[str]]:\n    \"\"\"Parse key=value style CLI (results_dir=\u2026 run_ids=\u2026).\"\"\"\n    kv: Dict[str, str] = {}\n    for arg in sys.argv[1:]:\n        if \"=\" not in arg:\n            raise ValueError(\n                f\"Argument \u0027{arg}\u0027 is not in key=value form. Expected e.g. results_dir=/path run_ids=\u0027[...]\u0027\"\n            )\n        k, v = arg.split(\"=\", 1)\n        kv[k.strip()] = v.strip()\n\n    if \"results_dir\" not in kv or \"run_ids\" not in kv:\n        raise ValueError(\"Both results_dir and run_ids must be provided in key=value form.\")\n\n    results_dir = Path(kv[\"results_dir\"]).expanduser()\n\n    # Remove optional surrounding quotes so json.loads works irrespective of quoting\n    run_ids_raw = kv[\"run_ids\"].strip()\n    if (run_ids_raw.startswith(\"\u0027\") and run_ids_raw.endswith(\"\u0027\")) or (\n        run_ids_raw.startswith(\u0027\"\u0027) and run_ids_raw.endswith(\u0027\"\u0027)\n    ):\n        run_ids_raw = run_ids_raw[1:-1]\n    run_ids = json.loads(run_ids_raw)\n    if not isinstance(run_ids, list):\n        raise ValueError(\"run_ids must decode to a JSON list of strings.\")\n\n    return results_dir, run_ids\n\n###############################################################################\n# Helper functions ------------------------------------------------------------\n###############################################################################\n\ndef save_learning_curve(df: pd.DataFrame, out_path: Path, metric: str = \"val_acc_batch\") -\u003e None:\n    if metric not in df.columns:\n        return\n    plt.figure(figsize=(6, 4))\n    sns.lineplot(x=df.index, y=df[metric])\n    if df[metric].notna().any():\n        best_idx = df[metric].idxmax()\n        best_val = df[metric].max()\n        plt.scatter(best_idx, best_val, color=\"red\")\n        plt.text(best_idx, best_val, f\"{best_val:.2f}\")\n    plt.xlabel(\"Step\")\n    plt.ylabel(metric.replace(\"_\", \" \"))\n    plt.title(f\"{metric} over time\")\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\ndef save_confusion(y_true: List[int], y_pred: List[int], out_path: Path, classes: List[str]):\n    cm = confusion_matrix(y_true, y_pred, labels=list(range(len(classes))))\n    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=classes)\n    fig, ax = plt.subplots(figsize=(6, 6))\n    disp.plot(ax=ax, cmap=\"Blues\", colorbar=False)\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    fig.savefig(out_path)\n    plt.close(fig)\n\n\ndef mcnemar_significance(y_true: List[int], preds_a: List[int], preds_b: List[int]) -\u003e float:\n    correct_a = np.array(preds_a) == np.array(y_true)\n    correct_b = np.array(preds_b) == np.array(y_true)\n    n01 = np.logical_and(correct_a, ~correct_b).sum()\n    n10 = np.logical_and(~correct_a, correct_b).sum()\n    if (n01 + n10) == 0:\n        return 1.0\n    stat = (abs(n01 - n10) - 1) ** 2 / (n01 + n10)\n    return float(stats.chi2.sf(stat, df=1))\n\n###############################################################################\n# Main evaluation workflow ----------------------------------------------------\n###############################################################################\n\ndef main():\n    results_dir, run_ids = _parse_cli()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    cfg_path = results_dir / \"config.yaml\"\n    if not cfg_path.exists():\n        raise FileNotFoundError(\n            f\"{cfg_path} not found. Ensure you passed the same results_dir used during training.\"\n        )\n    with open(cfg_path, \"r\") as f:\n        global_cfg = yaml.safe_load(f)\n    entity = global_cfg[\"wandb\"][\"entity\"]\n    project = global_cfg[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n\n    aggregated: Dict[str, Dict[str, float]] = {}\n    predictions_cache: Dict[str, Tuple[List[int], List[int]]] = {}\n    generated_paths: List[str] = []\n\n    # ---------------- Per-run processing ----------------------------------\n    for run_id in run_ids:\n        print(f\"[Eval] Processing {run_id}\")\n        subdir = results_dir / run_id\n        subdir.mkdir(parents=True, exist_ok=True)\n\n        try:\n            run = api.run(f\"{entity}/{project}/{run_id}\")\n        except wandb.errors.CommError:\n            print(f\"  [WARN] Run {run_id} not found \u2013 skipping.\")\n            continue\n\n        history = run.history(samples=100_000)\n        metrics_path = subdir / \"metrics.json\"\n        history.to_json(metrics_path, orient=\"records\", indent=2)\n        generated_paths.append(str(metrics_path))\n\n        # Learning curve --------------------------------------------------\n        lc_path = subdir / \"learning_curve_val_acc_batch.pdf\"\n        save_learning_curve(history, lc_path)\n        generated_paths.append(str(lc_path))\n\n        # Confusion matrix -----------------------------------------------\n        y_true = run.summary.get(\"y_true\", [])\n        y_pred = run.summary.get(\"y_pred\", [])\n        if y_true and y_pred:\n            cm_path = subdir / \"confusion_matrix.pdf\"\n            num_classes = max(max(y_true), max(y_pred)) + 1\n            classes = [str(i) for i in range(num_classes)]\n            save_confusion(y_true, y_pred, cm_path, classes)\n            generated_paths.append(str(cm_path))\n        predictions_cache[run_id] = (y_true, y_pred)\n\n        final_acc = float(run.summary.get(\"top1_accuracy\", np.nan))\n        aggregated[run_id] = {\"top1_accuracy\": final_acc}\n\n    # ---------------- Aggregated comparison ------------------------------\n    comparison_dir = results_dir / \"comparison\"\n    comparison_dir.mkdir(exist_ok=True)\n\n    baseline_id = run_ids[0] if run_ids else None\n    baseline_acc = aggregated.get(baseline_id, {}).get(\"top1_accuracy\", np.nan)\n\n    for rid, metrics in aggregated.items():\n        if baseline_id and rid != baseline_id and not np.isnan(baseline_acc):\n            metrics[\"improvement_rate\"] = (metrics[\"top1_accuracy\"] - baseline_acc) / baseline_acc\n        else:\n            metrics[\"improvement_rate\"] = 0.0\n\n        if baseline_id and rid != baseline_id:\n            y_true_b, y_pred_b = predictions_cache.get(baseline_id, ([], []))\n            y_true_o, y_pred_o = predictions_cache.get(rid, ([], []))\n            if y_true_b and y_pred_b and y_true_o and y_pred_o:\n                p_val = mcnemar_significance(y_true_b, y_pred_b, y_pred_o)\n            else:\n                p_val = np.nan\n            metrics[\"p_value_vs_baseline\"] = p_val\n        else:\n            metrics[\"p_value_vs_baseline\"] = np.nan\n\n    # Save aggregated metrics --------------------------------------------\n    agg_path = comparison_dir / \"aggregated_metrics.json\"\n    with open(agg_path, \"w\") as f:\n        json.dump(aggregated, f, indent=2)\n    generated_paths.append(str(agg_path))\n\n    # Accuracy bar chart --------------------------------------------------\n    labels = list(aggregated.keys())\n    accuracies = [aggregated[k][\"top1_accuracy\"] for k in labels]\n    plt.figure(figsize=(8, 4))\n    ax = sns.barplot(x=labels, y=accuracies)\n    for p, acc in zip(ax.patches, accuracies):\n        ax.annotate(f\"{acc:.2f}\", (p.get_x() + p.get_width() / 2, acc), ha=\"center\", va=\"bottom\")\n    plt.ylabel(\"Top-1 Accuracy (%)\")\n    plt.title(\"Accuracy comparison\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    bar_path = comparison_dir / \"top1_accuracy_comparison.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    generated_paths.append(str(bar_path))\n\n    # Improvement rates ---------------------------------------------------\n    if len(aggregated) \u003e= 2 and baseline_id is not None:\n        imp_labels = [l for l in labels if l != baseline_id]\n        imp_vals = [aggregated[l][\"improvement_rate\"] * 100 for l in imp_labels]\n        plt.figure(figsize=(8, 4))\n        ax2 = sns.barplot(x=imp_labels, y=imp_vals, color=\"skyblue\")\n        for p, v in zip(ax2.patches, imp_vals):\n            ax2.annotate(f\"{v:.2f}%\", (p.get_x() + p.get_width() / 2, v), ha=\"center\", va=\"bottom\")\n        plt.ylabel(\"Improvement over baseline (%)\")\n        plt.title(\"Relative improvement\")\n        plt.xticks(rotation=45, ha=\"right\")\n        plt.tight_layout()\n        imp_path = comparison_dir / \"improvement_rates.pdf\"\n        plt.savefig(imp_path)\n        plt.close()\n        generated_paths.append(str(imp_path))\n\n    # ---------------- Summary -------------------------------------------\n    print(\"\\n[Evaluation] Generated artefacts:\")\n    for p in generated_paths:\n        print(p)\n\n\nif __name__ == \"__main__\":\n    main()\n", "main_py": "# src/main.py\n\"\"\"Main orchestrator \u2013 launches a single experiment run as a subprocess.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport shlex\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nfrom hydra.core.hydra_config import HydraConfig\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import OmegaConf\n\n###############################################################################\n# Hydra entry-point -----------------------------------------------------------\n###############################################################################\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg):\n    original_cwd = Path(get_original_cwd())\n\n    # Persist full configuration (for evaluate.py)\n    results_dir = Path(cfg.results_dir)\n    results_dir.mkdir(parents=True, exist_ok=True)\n    cfg_path = results_dir / \"config.yaml\"\n    if not cfg_path.exists():\n        OmegaConf.save(config=cfg, f=str(cfg_path))\n\n    task_overrides: List[str] = list(HydraConfig.get().overrides.task)\n\n    # Trial-mode convenience overrides -----------------------------------\n    if cfg.get(\"trial_mode\", False):\n        if \"wandb.mode=disabled\" not in task_overrides:\n            task_overrides.append(\"wandb.mode=disabled\")\n        if \"optuna.n_trials=0\" not in task_overrides:\n            task_overrides.append(\"optuna.n_trials=0\")\n\n    # Ensure results_dir propagates\n    if f\"results_dir={cfg.results_dir}\" not in task_overrides:\n        task_overrides.append(f\"results_dir={cfg.results_dir}\")\n\n    launch_cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", *task_overrides]\n\n    env = os.environ.copy()\n    env[\"PYTHONPATH\"] = f\"{original_cwd}:{env.get(\u0027PYTHONPATH\u0027, \u0027\u0027)}\"\n\n    print(\"\\n[Launcher] Executing:\\n  \", \" \".join(map(shlex.quote, launch_cmd)))\n    subprocess.check_call(launch_cmd, env=env)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "# src/model.py\n\"\"\"Model definitions \u0026 utilities.\nWe rely on timm for ResNet-18 and cache weights under .cache/torch.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\nos.environ.setdefault(\"TORCH_HOME\", \".cache/torch\")\nPath(os.environ[\"TORCH_HOME\"]).mkdir(parents=True, exist_ok=True)\n\nimport torch.nn as nn\nimport timm\n\n###############################################################################\n# Model factory ----------------------------------------------------------------\n###############################################################################\n\ndef build_model(model_cfg):\n    \"\"\"Return a timm model with num_classes=10 for CIFAR-10.\"\"\"\n    model_name = getattr(model_cfg, \"checkpoint\", model_cfg.name)\n    model = timm.create_model(model_name, pretrained=model_cfg.pretrained, num_classes=10)\n    return model\n\n###############################################################################\n# TENT/CW-TENT helpers ---------------------------------------------------------\n###############################################################################\n\ndef freeze_non_bn_parameters(model: nn.Module):\n    \"\"\"Freeze all parameters except BatchNorm affine weights \u0026 biases.\"\"\"\n    for p in model.parameters():\n        p.requires_grad = False\n    for m in model.modules():\n        if isinstance(m, (nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d)):\n            if m.weight is not None:\n                m.weight.requires_grad_(True)\n            if m.bias is not None:\n                m.bias.requires_grad_(True)\n\n\ndef initialize_bn_adaptation(model: nn.Module):\n    \"\"\"Set BN layers to train mode \u0026 disable running-stats (TENT style).\"\"\"\n    for m in model.modules():\n        if isinstance(m, (nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d)):\n            m.train()\n            m.track_running_stats = False\n\n###############################################################################\n# Losses -----------------------------------------------------------------------\n###############################################################################\n\nimport torch\nimport torch.nn.functional as F\n\nclass EntropyLoss(nn.Module):\n    \"\"\"Mean prediction entropy.\"\"\"\n\n    def forward(self, logits: torch.Tensor) -\u003e torch.Tensor:  # noqa: D401\n        p = F.softmax(logits, dim=1)\n        ent = -(p * torch.clamp(p, min=1e-12).log()).sum(dim=1)\n        return ent.mean()\n\n\nclass ConfidenceWeightedEntropyLoss(nn.Module):\n    \"\"\"Confidence-Weighted entropy loss (proposed).\"\"\"\n\n    def forward(self, logits: torch.Tensor) -\u003e torch.Tensor:  # noqa: D401\n        p = F.softmax(logits, dim=1)\n        ent = -(p * torch.clamp(p, min=1e-12).log()).sum(dim=1)\n        num_classes = logits.size(1)\n        weights = 1.0 - ent / torch.log(torch.tensor(num_classes, device=logits.device, dtype=ent.dtype))\n        return (weights * ent).sum() / torch.clamp(weights.sum(), min=1e-12)\n", "preprocess_py": "# src/preprocess.py\n\"\"\"Data loading \u0026 preprocessing pipeline for CIFAR-10-C.\"\"\"\n\nfrom __future__ import annotations\n\nimport tarfile\nfrom pathlib import Path\nfrom typing import List, Tuple, Union\n\nimport numpy as np\nimport requests\nfrom PIL import Image\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision import transforms\n\n###############################################################################\n# Constants -------------------------------------------------------------------\n###############################################################################\n\nCIFAR10C_URL = \"https://zenodo.org/record/3555552/files/CIFAR-10-C.tar?download=1\"\nCORRUPTIONS = [\n    \"gaussian_noise\",\n    \"shot_noise\",\n    \"impulse_noise\",\n    \"defocus_blur\",\n    \"glass_blur\",\n    \"motion_blur\",\n    \"zoom_blur\",\n    \"snow\",\n    \"frost\",\n    \"fog\",\n    \"brightness\",\n    \"contrast\",\n    \"elastic_transform\",\n    \"pixelate\",\n    \"jpeg_compression\",\n]\n\n###############################################################################\n# Download helpers ------------------------------------------------------------\n###############################################################################\n\ndef _download(url: str, dst: Path):\n    dst.parent.mkdir(parents=True, exist_ok=True)\n    with requests.get(url, stream=True) as r:\n        r.raise_for_status()\n        total = int(r.headers.get(\"content-length\", 0))\n        with open(dst, \"wb\") as f, tqdm(total=total, unit=\"iB\", unit_scale=True, desc=\"CIFAR-10-C\") as bar:\n            for chunk in r.iter_content(chunk_size=1024 * 1024):\n                if chunk:\n                    f.write(chunk)\n                    bar.update(len(chunk))\n\n\ndef _download_and_extract(url: str, cache_dir: Path) -\u003e Path:\n    tar_path = cache_dir / \"CIFAR-10-C.tar\"\n    out_dir = cache_dir / \"CIFAR-10-C\"\n    if not out_dir.exists():\n        if not tar_path.exists():\n            print(\"Downloading CIFAR-10-C \u2026\")\n            _download(url, tar_path)\n        print(\"Extracting CIFAR-10-C \u2026\")\n        with tarfile.open(tar_path) as tar:\n            tar.extractall(path=cache_dir)\n    return out_dir\n\n###############################################################################\n# Dataset wrapper -------------------------------------------------------------\n###############################################################################\n\nclass NumpyArrayDataset(Dataset):\n    \"\"\"Simple Dataset around CIFAR-10-C numpy arrays.\"\"\"\n\n    def __init__(self, images: np.ndarray, labels: np.ndarray, transform=None):\n        self.images = images\n        self.labels = labels.astype(np.int64)\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.images)\n\n    def __getitem__(self, idx):\n        img = Image.fromarray(self.images[idx])\n        label = int(self.labels[idx])\n        if self.transform is not None:\n            img = self.transform(img)\n        return img, label\n\n###############################################################################\n# Public API ------------------------------------------------------------------\n###############################################################################\n\ndef load_cifar10c(*, severity: int = 5, corruption_types: Union[str, List[str]] = \"all\", cache_dir: Path) -\u003e Tuple[np.ndarray, np.ndarray]:\n    if not 1 \u003c= severity \u003c= 5:\n        raise ValueError(\"Severity must be in [1, 5]\")\n\n    cache_dir = Path(cache_dir)\n    extract_dir = _download_and_extract(CIFAR10C_URL, cache_dir)\n\n    if corruption_types == \"all\":\n        corruption_types = CORRUPTIONS\n\n    images_list = []\n    labels_base = np.load(extract_dir / \"labels.npy\")\n    start, end = (severity - 1) * 10_000, severity * 10_000\n\n    for corr in corruption_types:\n        corr_arr = np.load(extract_dir / f\"{corr}.npy\")\n        images_list.append(corr_arr[start:end])\n    images = np.concatenate(images_list, axis=0)\n    labels = np.tile(labels_base[start:end], len(corruption_types))\n    return images, labels\n\n\ndef build_dataloader(dataset_cfg, *, split: str = \"test\", cache_dir: str = \".cache/\") -\u003e DataLoader:\n    cache_path = Path(cache_dir)\n\n    if dataset_cfg.name.lower() == \"cifar-10-c\":\n        imgs, lbls = load_cifar10c(\n            severity=dataset_cfg.severity,\n            corruption_types=dataset_cfg.corruption_types,\n            cache_dir=cache_path / \"cifar10_c\",\n        )\n        transform = transforms.Compose(\n            [\n                transforms.ToTensor(),\n                transforms.Normalize(mean=dataset_cfg.normalization.mean, std=dataset_cfg.normalization.std),\n            ]\n        )\n        ds = NumpyArrayDataset(imgs, lbls, transform)\n        return DataLoader(ds, batch_size=dataset_cfg.batch_size, shuffle=False, num_workers=4, pin_memory=True)\n\n    raise ValueError(f\"Unsupported dataset {dataset_cfg.name}\")\n", "pyproject_toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cw_tent_experiments\"\nversion = \"0.1.0\"\ndescription = \"Confidence-Weighted TENT experiments with Hydra \u0026 WandB\"\nauthors = [{name = \"AI Autogenerated\", email = \"noreply@example.com\"}]\nrequires-python = \"\u003e=3.8\"\n\n[project.dependencies]\ntorch = \"*\"\ntorchvision = \"*\"\ntimm = \"*\"\nhydra-core = \"*\"\noptuna = \"*\"\nwandb = \"*\"\n\nnumpy = \"*\"\npandas = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nscikit-learn = \"*\"\nscipy = \"*\"\nPillow = \"*\"\nrequests = \"*\"\nPyYAML = \"*\"\ntqdm = \"*\"\n", "train_py": "# src/train.py\n\"\"\"Training script executed as a subprocess by main.py.\nImplements baseline TENT and the proposed CW-TENT for CIFAR-10-C.\nAll models / data are cached under .cache/ to avoid re-downloads on CI.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\n# ----------------------------------------------------------------------------\n# Enforce local caching BEFORE importing torch / timm / datasets --------------\n# ----------------------------------------------------------------------------\nos.environ.setdefault(\"TORCH_HOME\", \".cache/torch\")\n\nimport hydra\nimport optuna\nimport torch\nimport torch.nn.functional as F  # noqa: F401  (used implicitly)\nimport wandb\nfrom omegaconf import OmegaConf\n\nfrom src.model import (\n    ConfidenceWeightedEntropyLoss,\n    EntropyLoss,\n    build_model,\n    freeze_non_bn_parameters,\n    initialize_bn_adaptation,\n)\nfrom src.preprocess import build_dataloader\n\n###############################################################################\n# Helper utilities ------------------------------------------------------------\n###############################################################################\n\ndef topk_acc(output: torch.Tensor, target: torch.Tensor, k: int = 1) -\u003e float:\n    \"\"\"Compute top-k accuracy (percentage) for a single batch.\"\"\"\n    with torch.no_grad():\n        maxk = k\n        batch_size = target.size(0)\n        _, pred = output.topk(maxk, 1, True, True)\n        pred = pred.t()\n        correct = pred.eq(target.view(1, -1).expand_as(pred))\n        correct_k = correct.reshape(-1)[: k * batch_size].float().sum(0)\n        return float(correct_k.item()) * 100.0 / batch_size\n\n###############################################################################\n# Core routine ----------------------------------------------------------------\n###############################################################################\n\ndef run_single(cfg, *, enable_wandb: bool = True) -\u003e float:\n    \"\"\"Run a single configuration and return final accuracy.\"\"\"\n\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ---------------------------------------------------------------------\n    # WandB initialisation (might be disabled in trial-mode) --------------\n    # ---------------------------------------------------------------------\n    if enable_wandb and cfg.wandb.mode != \"disabled\":\n        wandb_run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run_id,\n            resume=\"allow\",\n            config=OmegaConf.to_container(cfg, resolve=True),\n            reinit=True,\n        )\n        print(f\"[WandB] Run URL: {wandb_run.url}\")\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n        wandb_run = None\n\n    # ---------------------------------------------------------------------\n    # Data ----------------------------------------------------------------\n    # ---------------------------------------------------------------------\n    dataloader = build_dataloader(cfg.dataset, split=\"test\", cache_dir=\".cache/\")\n\n    # ---------------------------------------------------------------------\n    # Model \u0026 optimiser ----------------------------------------------------\n    # ---------------------------------------------------------------------\n    model = build_model(cfg.model).to(device)\n    model.eval()\n\n    freeze_non_bn_parameters(model)\n    initialize_bn_adaptation(model)\n\n    params_to_update = filter(lambda p: p.requires_grad, model.parameters())\n\n    opt_name = cfg.training.optimizer.lower()\n    if opt_name == \"sgd\":\n        optimizer = torch.optim.SGD(\n            params_to_update,\n            lr=cfg.training.learning_rate,\n            momentum=cfg.training.momentum,\n            weight_decay=cfg.training.weight_decay,\n        )\n    elif opt_name == \"adam\":\n        optimizer = torch.optim.Adam(\n            params_to_update,\n            lr=cfg.training.learning_rate,\n            weight_decay=cfg.training.weight_decay,\n        )\n    else:\n        raise ValueError(f\"Unsupported optimizer {opt_name}\")\n\n    if cfg.training.loss == \"entropy\":\n        criterion = EntropyLoss()\n    elif cfg.training.loss == \"confidence_weighted_entropy\":\n        criterion = ConfidenceWeightedEntropyLoss()\n    else:\n        raise ValueError(f\"Unsupported loss {cfg.training.loss}\")\n\n    # ---------------------------------------------------------------------\n    # Adaptation loop (TENT-style) ----------------------------------------\n    # ---------------------------------------------------------------------\n    global_step = 0\n    all_preds: List[int] = []\n    all_targets: List[int] = []\n\n    trial_mode: bool = bool(cfg.get(\"trial_mode\", False))\n\n    for epoch in range(cfg.training.epochs):\n        for batch_idx, (images, targets) in enumerate(dataloader):\n            # In trial-mode process only 1\u20132 batches to keep CI fast\n            if trial_mode and batch_idx \u003e= 2:\n                break\n\n            images = images.to(device, non_blocking=True)\n            targets = targets.to(device, non_blocking=True)\n\n            # ----- Inner update(s) ---------------------------------------\n            model.train()\n            for _ in range(cfg.training.inner_steps):\n                optimizer.zero_grad(set_to_none=True)\n                logits_in = model(images)\n                loss = criterion(logits_in)\n                loss.backward()\n                optimizer.step()\n            model.eval()\n\n            # ----- Metrics ----------------------------------------------\n            with torch.no_grad():\n                logits_out = model(images)\n            preds = logits_out.argmax(dim=1)\n            acc1 = topk_acc(logits_out, targets, k=1)\n\n            all_preds.extend(preds.cpu().tolist())\n            all_targets.extend(targets.cpu().tolist())\n\n            if wandb_run is not None:\n                wandb.log(\n                    {\n                        \"train_loss\": float(loss.item()),\n                        \"val_acc_batch\": float(acc1),\n                        \"epoch\": epoch,\n                    },\n                    step=global_step,\n                )\n            global_step += 1\n\n    # ---------------------------------------------------------------------\n    # Final accuracy \u0026 WandB summary --------------------------------------\n    # ---------------------------------------------------------------------\n    all_preds_t = torch.tensor(all_preds)\n    all_targets_t = torch.tensor(all_targets)\n    final_acc = 100.0 * (all_preds_t == all_targets_t).float().mean().item()\n    print(f\"[RESULT] {cfg.run_id} \u2013 Final Top-1 Acc: {final_acc:.2f}%\")\n\n    if wandb_run is not None:\n        wandb_run.summary[\"top1_accuracy\"] = float(final_acc)\n        wandb_run.summary[\"y_true\"] = all_targets  # for later evaluation\n        wandb_run.summary[\"y_pred\"] = all_preds\n        wandb_run.finish()\n\n    return float(final_acc)\n\n###############################################################################\n# Optuna helpers --------------------------------------------------------------\n###############################################################################\n\ndef _suggest_from_space(trial: optuna.Trial, space: Dict[str, Dict[str, Any]]):\n    params: Dict[str, Any] = {}\n    for name, spec in space.items():\n        typ = spec[\"type\"]\n        if typ == \"loguniform\":\n            params[name] = trial.suggest_float(name, spec[\"low\"], spec[\"high\"], log=True)\n        elif typ == \"uniform\":\n            params[name] = trial.suggest_float(name, spec[\"low\"], spec[\"high\"], log=False)\n        elif typ == \"categorical\":\n            params[name] = trial.suggest_categorical(name, spec[\"choices\"])\n        else:\n            raise ValueError(f\"Unknown Optuna param type {typ}\")\n    return params\n\n\ndef _apply_trial_params(cfg, params: Dict[str, Any]):\n    \"\"\"Write Optuna-suggested parameters back into the OmegaConf object.\"\"\"\n    for k, v in params.items():\n        if hasattr(cfg.training, k):\n            setattr(cfg.training, k, v)\n        elif hasattr(cfg.dataset, k):\n            setattr(cfg.dataset, k, v)\n        elif hasattr(cfg.model, k):\n            setattr(cfg.model, k, v)\n\n###############################################################################\n# Hydra entry-point -----------------------------------------------------------\n###############################################################################\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg):  # noqa: C901\n    # ---------------- Trial-mode overrides --------------------------------\n    if bool(cfg.get(\"trial_mode\", False)):\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.training.epochs = 1\n\n    # Ensure cache directories exist\n    Path(\".cache/torch\").mkdir(parents=True, exist_ok=True)\n    Path(\".cache/datasets\").mkdir(parents=True, exist_ok=True)\n\n    # ---------------- Hyper-parameter optimisation -----------------------\n    if cfg.optuna.n_trials \u003e 0:\n        print(f\"[Optuna] Running {cfg.optuna.n_trials} trials \u2026\")\n\n        def objective(trial: optuna.Trial) -\u003e float:\n            cfg_trial = OmegaConf.create(OmegaConf.to_container(cfg, resolve=True))\n            params = _suggest_from_space(trial, cfg_trial.optuna.search_space)\n            _apply_trial_params(cfg_trial, params)\n            cfg_trial.wandb.mode = \"disabled\"  # disable logging during search\n            return run_single(cfg_trial, enable_wandb=False)\n\n        study = optuna.create_study(direction=cfg.optuna.direction)\n        study.optimize(objective, n_trials=cfg.optuna.n_trials)\n        print(\n            f\"[Optuna] Best value = {study.best_value:.4f}\\n[Optuna] Best params = {study.best_params}\"\n        )\n        _apply_trial_params(cfg, study.best_params)\n\n    # ---------------- Final (possibly best) run --------------------------\n    run_single(cfg, enable_wandb=(cfg.wandb.mode != \"disabled\"))\n\n\nif __name__ == \"__main__\":\n    main()\n"}

Fix the issues identified above while preserving the correct parts of the implementation.



# Experimental Environment
NVIDIA A100×8
VRAM：80GB×8
RAM：2048 GB

# Current Research Method
{
    "Open Problems": "Most popular test-time adaptation (TTA) methods such as TENT adapt only BatchNorm affine parameters by minimizing prediction entropy on the incoming test stream. Although very effective, they often require 3-10 gradient steps for each incoming mini-batch to reach their best performance. The slow convergence mainly comes from noisy gradients produced by low-confidence (high-entropy) samples that dominate early in adaptation. A simple mechanism to down-weight these uncertain samples during optimization is missing.",
    "Methods": "Confidence-Weighted Entropy Minimization (CW-TENT).\n1. Keep the original TENT objective L = Σ_i H(p_i) where H is entropy.\n2. Introduce a scalar weight per sample w_i = 1 – H(p_i)/log(C)  (ranges in [0,1]; C = #classes).\n3. Replace the loss with the weighted variant  L_w = Σ_i w_i · H(p_i) / Σ_i w_i.\n4. Use the same SGD update of BatchNorm affine parameters, but with a single gradient step per mini-batch (optionally with momentum=0.9).\nTheoretical intuition: high-confidence samples (low entropy) are already close to the target domain optimum and provide reliable gradients; amplifying their contribution yields a cleaner gradient direction, allowing larger learning rate or fewer steps, hence faster convergence.",
    "Experimental Setup": "Dataset: CIFAR-10-C with 15 corruption types, severity 5 (standard TTA benchmark).\nModel: Pre-trained ResNet-18.\nBaselines: 1) Source model (no adaptation). 2) Original TENT (default 10 inner steps). 3) CW-TENT (1 inner step).\nMetric: Top-1 accuracy after processing the full test stream; also accuracy after first K (e.g., 1, 3) adaptation steps to measure convergence speed.",
    "Experimental Code": "import torch, torch.nn.functional as F\n\ndef entropy(p):\n    return -(p * p.log()).sum(1)\n\nclass CWTentAdapter:\n    def __init__(self, model, lr=1e-3, momentum=0.9):\n        self.model = model.eval()\n        self.model.requires_grad_(False)\n        # enable gradients for affine BN params only\n        for m in model.modules():\n            if isinstance(m, torch.nn.BatchNorm2d):\n                m.weight.requires_grad_(True)\n                m.bias.requires_grad_(True)\n        self.optimizer = torch.optim.SGD(filter(lambda p: p.requires_grad, model.parameters()), lr=lr, momentum=momentum)\n\n    @torch.no_grad()\n    def predict(self, x):\n        return self.model(x).softmax(1)\n\n    def adapt(self, x):\n        self.model.train()        # BN uses batch statistics\n        self.optimizer.zero_grad()\n        logits = self.model(x)\n        probs = logits.softmax(1)\n        H = entropy(probs)\n        w = 1 - H / torch.log(torch.tensor(probs.size(1), device=x.device))\n        loss = (w * H).sum() / w.sum()\n        loss.backward()\n        self.optimizer.step()\n        self.model.eval()\n        return probs.detach()\n",
    "Expected Result": "With only one gradient step per mini-batch, CW-TENT is expected to match or surpass the accuracy of TENT that uses 5–10 steps. For example on CIFAR-10-C severity 5: Source 58.7%, TENT (10 steps) 71.0%, CW-TENT (1 step) ≈71.5%. Convergence plot should show CW-TENT reaching peak accuracy after the first step, whereas TENT needs several.",
    "Expected Conclusion": "A tiny modification—confidence-weighted entropy—suppresses noisy gradients from uncertain samples and lets TENT converge in a single step. The change is trivial to implement (four extra lines) yet meaningfully cuts computation and latency at test time, making TTA more practical for real-time deployment."
}

# Experimental Design
- Summary: The experiment demonstrates that Confidence-Weighted TENT (CW-TENT) enables fast, one-step test-time adaptation by down-weighting high-entropy (low-confidence) samples in the classic entropy-minimisation objective used by TENT. A pre-trained ResNet-18 is sequentially exposed to the CIFAR-10-C corruption stream (severity-5). At every incoming mini-batch the model first produces predictions, then performs one SGD update on BatchNorm affine parameters using the confidence-weighted entropy loss. Performance is evaluated as the stream proceeds and compared against: (1) the frozen source model (no adaptation) and (2) the original TENT that applies 10 inner optimisation steps. All runs share identical data order, initial weights and hardware (8×H200, 144 GB each). Hyper-parameter sweeps on learning-rate, momentum and weight-decay are carried out with random search (30 trials) on a held-out corruption set to obtain fair settings for both CW-TENT and the baseline.
- Evaluation metrics: ['Top-1 Accuracy', 'Average Accuracy After First Adaptation Step']

# Experiment Runs

- Run ID: proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: proposed
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  Config File: config/run/proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5).yaml
  
  Config Content:
  ```yaml
  run_id: "proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)"
method: proposed
model:
  name: ResNet-18
  provider: timm
  checkpoint: resnet18.a1_in1k
  num_parameters: 11700000
  pretrained: true
  trainable_parameters:
    - BatchNorm2d.weight
    - BatchNorm2d.bias
dataset:
  name: CIFAR-10-C
  severity: 5
  corruption_types: all            # 15 standard corruptions
  normalization:
    mean: [0.4914, 0.4822, 0.4465]
    std:  [0.2470, 0.2435, 0.2616]
  batch_size: 64
training:
  adaptation: true                 # test-time adaptation instead of full training
  inner_steps: 1                   # CW-TENT uses a single gradient step
  loss: confidence_weighted_entropy
  optimizer: sgd
  learning_rate: 0.001
  momentum: 0.9
  weight_decay: 0.0
  epochs: 1                        # one pass over the test stream
  lr_schedule: constant
optuna:
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
    batch_size:
      type: categorical
      choices: [32, 64, 128]

  ```
  

- Run ID: comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: comparative-1
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  Config File: config/run/comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5).yaml
  
  Config Content:
  ```yaml
  run_id: "comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)"
method: comparative-1      # Original TENT baseline
model:
  name: ResNet-18
  provider: timm
  checkpoint: resnet18.a1_in1k
  num_parameters: 11700000
  pretrained: true
  trainable_parameters:
    - BatchNorm2d.weight
    - BatchNorm2d.bias
dataset:
  name: CIFAR-10-C
  severity: 5
  corruption_types: all
  normalization:
    mean: [0.4914, 0.4822, 0.4465]
    std:  [0.2470, 0.2435, 0.2616]
  batch_size: 64
training:
  adaptation: true
  inner_steps: 10                  # classic TENT uses 10 inner optimisation steps
  loss: entropy
  optimizer: sgd
  learning_rate: 0.001
  momentum: 0.9
  weight_decay: 0.0
  epochs: 1
  lr_schedule: constant
optuna:
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
    batch_size:
      type: categorical
      choices: [32, 64, 128]

  ```
  


# External Resources (Use these for implementation)

**HuggingFace Models:**

- ID: timm/resnet18.a1_in1k

- Code: from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model('resnet18.a1_in1k', pretrained=True)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # unsqueeze single image into batch of 1

top5_probabilities, top5_class_indices = torch.topk(output.softmax(dim=1) * 100, k=5)

from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model(
    'resnet18.a1_in1k',
    pretrained=True,
    features_only=True,
)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # unsqueeze single image into batch of 1

for o in output:
    # print shape of each feature map in output
    # e.g.:
    #  torch.Size([1, 64, 112, 112])
    #  torch.Size([1, 64, 56, 56])
    #  torch.Size([1, 128, 28, 28])
    #  torch.Size([1, 256, 14, 14])
    #  torch.Size([1, 512, 7, 7])

    print(o.shape)

from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model(
    'resnet18.a1_in1k',
    pretrained=True,
    num_classes=0,  # remove classifier nn.Linear
)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # output is (batch_size, num_features) shaped tensor

# or equivalently (without needing to set num_classes=0)

output = model.forward_features(transforms(img).unsqueeze(0))
# output is unpooled, a (1, 512, 7, 7) shaped tensor

output = model.forward_head(output, pre_logits=True)
# output is a (1, num_features) shaped tensor



**HuggingFace Datasets:**



Generate complete, production-ready experiment code that integrates with Hydra configuration system.
Output:
{
    "train_py": "# src/train.py\n\"\"\"Training script executed as a subprocess by main.py.\nImplements baseline TENT and the proposed CW-TENT for CIFAR-10-C.\nEverything (models, datasets) is cached in .cache/ so that CI stays fast.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\n# -----------------------------------------------------------------------------\n# Force local cache BEFORE heavy imports --------------------------------------\n# -----------------------------------------------------------------------------\nos.environ.setdefault(\"TORCH_HOME\", \".cache/torch\")\n\nimport hydra\nimport optuna\nimport torch\nimport torch.nn.functional as F  # noqa: F401  (used implicitly by losses)\nimport wandb\nfrom omegaconf import OmegaConf\n\nfrom src.model import (\n    ConfidenceWeightedEntropyLoss,\n    EntropyLoss,\n    build_model,\n    freeze_non_bn_parameters,\n    initialize_bn_adaptation,\n)\nfrom src.preprocess import build_dataloader\n\n###############################################################################\n# Utility functions -----------------------------------------------------------\n###############################################################################\n\ndef topk_acc(output: torch.Tensor, target: torch.Tensor, k: int = 1) -> float:\n    \"\"\"Return top-k accuracy (percentage) for a single batch.\"\"\"\n    with torch.no_grad():\n        maxk = k\n        batch_size = target.size(0)\n        _, pred = output.topk(maxk, 1, True, True)\n        pred = pred.t()\n        correct = pred.eq(target.view(1, -1).expand_as(pred))\n        correct_k = correct.reshape(-1)[: k * batch_size].float().sum(0)\n        return float(correct_k.item()) * 100.0 / batch_size\n\n###############################################################################\n# Core routine ----------------------------------------------------------------\n###############################################################################\n\ndef run_single(cfg, *, enable_wandb: bool = True) -> float:\n    \"\"\"Run adaptation with the parameters in ``cfg`` and return final accuracy.\"\"\"\n\n    run_cfg = getattr(cfg, \"run\", cfg)  # support both flattened & nested\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ---------------------------------------------------------------------\n    # WandB initialisation -------------------------------------------------\n    # ---------------------------------------------------------------------\n    if enable_wandb and cfg.wandb.mode != \"disabled\":\n        wandb_run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=run_cfg.run_id,\n            resume=\"allow\",\n            config=OmegaConf.to_container(cfg, resolve=True),\n            reinit=True,\n        )\n        print(f\"[WandB] Run URL: {wandb_run.url}\")\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n        wandb_run = None\n\n    # ---------------------------------------------------------------------\n    # Data ----------------------------------------------------------------\n    # ---------------------------------------------------------------------\n    dataloader = build_dataloader(run_cfg.dataset, split=\"test\", cache_dir=\".cache/\")\n\n    # ---------------------------------------------------------------------\n    # Model & optimiser ---------------------------------------------------\n    # ---------------------------------------------------------------------\n    model = build_model(run_cfg.model).to(device)\n    model.eval()\n\n    freeze_non_bn_parameters(model)\n    initialize_bn_adaptation(model)\n\n    params_to_update = filter(lambda p: p.requires_grad, model.parameters())\n\n    opt_name = run_cfg.training.optimizer.lower()\n    if opt_name == \"sgd\":\n        optimizer = torch.optim.SGD(\n            params_to_update,\n            lr=run_cfg.training.learning_rate,\n            momentum=run_cfg.training.momentum,\n            weight_decay=run_cfg.training.weight_decay,\n        )\n    elif opt_name == \"adam\":\n        optimizer = torch.optim.Adam(\n            params_to_update,\n            lr=run_cfg.training.learning_rate,\n            weight_decay=run_cfg.training.weight_decay,\n        )\n    else:\n        raise ValueError(f\"Unsupported optimizer {opt_name}\")\n\n    if run_cfg.training.loss == \"entropy\":\n        criterion = EntropyLoss()\n    elif run_cfg.training.loss == \"confidence_weighted_entropy\":\n        criterion = ConfidenceWeightedEntropyLoss()\n    else:\n        raise ValueError(f\"Unsupported loss {run_cfg.training.loss}\")\n\n    # ---------------------------------------------------------------------\n    # Adaptation loop (TENT-style) ----------------------------------------\n    # ---------------------------------------------------------------------\n    global_step = 0\n    all_preds: List[int] = []\n    all_targets: List[int] = []\n\n    trial_mode: bool = bool(cfg.get(\"trial_mode\", False))\n\n    for epoch in range(run_cfg.training.epochs):\n        for batch_idx, (images, targets) in enumerate(dataloader):\n            # In trial-mode process only a few batches to keep CI fast\n            if trial_mode and batch_idx >= 2:\n                break\n\n            images = images.to(device, non_blocking=True)\n            targets = targets.to(device, non_blocking=True)\n\n            # ----- Inner update(s) ---------------------------------------\n            model.train()\n            for _ in range(run_cfg.training.inner_steps):\n                optimizer.zero_grad(set_to_none=True)\n                logits_in = model(images)\n                loss = criterion(logits_in)\n                loss.backward()\n                optimizer.step()\n            model.eval()\n\n            # ----- Metrics ----------------------------------------------\n            with torch.no_grad():\n                logits_out = model(images)\n            preds = logits_out.argmax(dim=1)\n            acc1 = topk_acc(logits_out, targets, k=1)\n\n            all_preds.extend(preds.cpu().tolist())\n            all_targets.extend(targets.cpu().tolist())\n\n            if wandb_run is not None:\n                wandb.log(\n                    {\n                        \"train_loss\": float(loss.item()),\n                        \"val_acc_batch\": float(acc1),\n                        \"epoch\": epoch,\n                    },\n                    step=global_step,\n                )\n            global_step += 1\n\n    # ---------------------------------------------------------------------\n    # Final accuracy & WandB summary --------------------------------------\n    # ---------------------------------------------------------------------\n    all_preds_t = torch.tensor(all_preds)\n    all_targets_t = torch.tensor(all_targets)\n    final_acc = 100.0 * (all_preds_t == all_targets_t).float().mean().item()\n    print(f\"[RESULT] {run_cfg.run_id} – Final Top-1 Acc: {final_acc:.2f}%\")\n\n    if wandb_run is not None:\n        wandb_run.summary[\"top1_accuracy\"] = float(final_acc)\n        wandb_run.summary[\"y_true\"] = all_targets  # for later evaluation\n        wandb_run.summary[\"y_pred\"] = all_preds\n        wandb_run.finish()\n\n    return float(final_acc)\n\n###############################################################################\n# Optuna helpers --------------------------------------------------------------\n###############################################################################\n\ndef _suggest_from_space(trial: optuna.Trial, space: Dict[str, Dict[str, Any]]):\n    \"\"\"Sample parameters from an Optuna search-space description.\"\"\"\n    params: Dict[str, Any] = {}\n    for name, spec in space.items():\n        typ = spec[\"type\"]\n        if typ == \"loguniform\":\n            params[name] = trial.suggest_float(name, spec[\"low\"], spec[\"high\"], log=True)\n        elif typ == \"uniform\":\n            params[name] = trial.suggest_float(name, spec[\"low\"], spec[\"high\"], log=False)\n        elif typ == \"categorical\":\n            params[name] = trial.suggest_categorical(name, spec[\"choices\"])\n        else:\n            raise ValueError(f\"Unknown Optuna param type {typ}\")\n    return params\n\n\ndef _apply_trial_params(cfg, params: Dict[str, Any]):\n    \"\"\"Write Optuna-suggested parameters back into ``cfg`` (in-place).\"\"\"\n    run_cfg = getattr(cfg, \"run\", cfg)\n    for k, v in params.items():\n        if hasattr(run_cfg.training, k):\n            setattr(run_cfg.training, k, v)\n        elif hasattr(run_cfg.dataset, k):\n            setattr(run_cfg.dataset, k, v)\n        elif hasattr(run_cfg.model, k):\n            setattr(run_cfg.model, k, v)\n\n###############################################################################\n# Hydra entry-point -----------------------------------------------------------\n###############################################################################\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg):  # noqa: C901  (complex but clear)\n    # ---------------- Trial-mode tweaks ----------------------------------\n    if bool(cfg.get(\"trial_mode\", False)):\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.run.training.epochs = 1\n\n    # Ensure cache directories exist\n    Path(\".cache/torch\").mkdir(parents=True, exist_ok=True)\n    Path(\".cache/datasets\").mkdir(parents=True, exist_ok=True)\n\n    # ---------------- Hyper-parameter optimisation ----------------------\n    if cfg.optuna.n_trials > 0:\n        print(f\"[Optuna] Running {cfg.optuna.n_trials} trials …\")\n\n        def objective(trial: optuna.Trial) -> float:\n            cfg_trial = OmegaConf.create(OmegaConf.to_container(cfg, resolve=True))\n            params = _suggest_from_space(trial, cfg_trial.optuna.search_space)\n            _apply_trial_params(cfg_trial, params)\n            cfg_trial.wandb.mode = \"disabled\"  # disable logging during search\n            return run_single(cfg_trial, enable_wandb=False)\n\n        study = optuna.create_study(direction=cfg.optuna.direction)\n        study.optimize(objective, n_trials=cfg.optuna.n_trials)\n        print(\n            f\"[Optuna] Best value = {study.best_value:.4f}\\n[Optuna] Best params = {study.best_params}\"\n        )\n        _apply_trial_params(cfg, study.best_params)\n\n    # ---------------- Final (potentially best) run ----------------------\n    run_single(cfg, enable_wandb=(cfg.wandb.mode != \"disabled\"))\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "evaluate_py": "# src/evaluate.py\n\"\"\"Independent evaluation and visualisation script.\nFetch metrics from WandB and generate per-run and aggregated artefacts.\nCLI:  python -m src.evaluate results_dir=PATH run_ids='[\"run-1\", …]'\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy import stats\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\n\nsns.set(style=\"whitegrid\")\n\n###############################################################################\n# Argument parsing ------------------------------------------------------------\n###############################################################################\n\ndef _parse_cli() -> Tuple[Path, List[str]]:\n    \"\"\"Parse key=value style CLI arguments.\"\"\"\n    kv: Dict[str, str] = {}\n    for arg in sys.argv[1:]:\n        if \"=\" not in arg:\n            raise ValueError(\n                f\"Argument '{arg}' is not in key=value form (expected e.g. results_dir=/path run_ids='[…]').\"\n            )\n        k, v = arg.split(\"=\", 1)\n        kv[k.strip()] = v.strip()\n\n    if \"results_dir\" not in kv or \"run_ids\" not in kv:\n        raise ValueError(\"Both results_dir and run_ids must be provided in key=value form.\")\n\n    results_dir = Path(kv[\"results_dir\"]).expanduser()\n\n    # Remove optional surrounding quotes so json.loads works irrespective of quoting\n    run_ids_raw = kv[\"run_ids\"].strip()\n    if (\n        (run_ids_raw.startswith(\"'\") and run_ids_raw.endswith(\"'\"))\n        or (run_ids_raw.startswith(\"\\\"\") and run_ids_raw.endswith(\"\\\"\"))\n    ):\n        run_ids_raw = run_ids_raw[1:-1]\n    run_ids = json.loads(run_ids_raw)\n    if not isinstance(run_ids, list):\n        raise ValueError(\"run_ids must decode to a JSON list of strings.\")\n\n    return results_dir, run_ids\n\n###############################################################################\n# Helper functions ------------------------------------------------------------\n###############################################################################\n\ndef save_learning_curve(df: pd.DataFrame, out_path: Path, metric: str = \"val_acc_batch\") -> None:\n    if metric not in df.columns:\n        return\n    plt.figure(figsize=(6, 4))\n    sns.lineplot(x=df.index, y=df[metric])\n    if df[metric].notna().any():\n        best_idx = df[metric].idxmax()\n        best_val = df[metric].max()\n        plt.scatter(best_idx, best_val, color=\"red\")\n        plt.text(best_idx, best_val, f\"{best_val:.2f}\")\n    plt.xlabel(\"Step\")\n    plt.ylabel(metric.replace(\"_\", \" \"))\n    plt.title(f\"{metric} over time\")\n    plt.tight_layout()\n    plt.savefig(out_path)\n    plt.close()\n\n\ndef save_confusion(y_true: List[int], y_pred: List[int], out_path: Path, classes: List[str]):\n    cm = confusion_matrix(y_true, y_pred, labels=list(range(len(classes))))\n    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=classes)\n    fig, ax = plt.subplots(figsize=(6, 6))\n    disp.plot(ax=ax, cmap=\"Blues\", colorbar=False)\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    fig.savefig(out_path)\n    plt.close(fig)\n\n\ndef mcnemar_significance(y_true: List[int], preds_a: List[int], preds_b: List[int]) -> float:\n    correct_a = np.array(preds_a) == np.array(y_true)\n    correct_b = np.array(preds_b) == np.array(y_true)\n    n01 = np.logical_and(correct_a, ~correct_b).sum()\n    n10 = np.logical_and(~correct_a, correct_b).sum()\n    if (n01 + n10) == 0:\n        return 1.0\n    stat = (abs(n01 - n10) - 1) ** 2 / (n01 + n10)\n    return float(stats.chi2.sf(stat, df=1))\n\n###############################################################################\n# Main evaluation workflow ----------------------------------------------------\n###############################################################################\n\ndef main():\n    results_dir, run_ids = _parse_cli()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    cfg_path = results_dir / \"config.yaml\"\n    if not cfg_path.exists():\n        raise FileNotFoundError(\n            f\"{cfg_path} not found. Ensure you passed the same results_dir used during training.\"\n        )\n    with open(cfg_path, \"r\") as f:\n        global_cfg = yaml.safe_load(f)\n    entity = global_cfg[\"wandb\"][\"entity\"]\n    project = global_cfg[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n\n    aggregated: Dict[str, Dict[str, float]] = {}\n    predictions_cache: Dict[str, Tuple[List[int], List[int]]] = {}\n    generated_paths: List[str] = []\n\n    # ---------------- Per-run processing ---------------------------------\n    for run_id in run_ids:\n        print(f\"[Eval] Processing {run_id}\")\n        subdir = results_dir / run_id\n        subdir.mkdir(parents=True, exist_ok=True)\n\n        try:\n            run = api.run(f\"{entity}/{project}/{run_id}\")\n        except wandb.errors.CommError:\n            print(f\"  [WARN] Run {run_id} not found – skipping.\")\n            continue\n\n        history = run.history(samples=100_000)\n        metrics_path = subdir / \"metrics.json\"\n        history.to_json(metrics_path, orient=\"records\", indent=2)\n        generated_paths.append(str(metrics_path))\n\n        # Learning curve --------------------------------------------------\n        lc_path = subdir / \"learning_curve_val_acc_batch.pdf\"\n        save_learning_curve(history, lc_path)\n        generated_paths.append(str(lc_path))\n\n        # Confusion matrix -----------------------------------------------\n        y_true = run.summary.get(\"y_true\", [])\n        y_pred = run.summary.get(\"y_pred\", [])\n        if y_true and y_pred:\n            cm_path = subdir / \"confusion_matrix.pdf\"\n            num_classes = max(max(y_true), max(y_pred)) + 1\n            classes = [str(i) for i in range(num_classes)]\n            save_confusion(y_true, y_pred, cm_path, classes)\n            generated_paths.append(str(cm_path))\n        predictions_cache[run_id] = (y_true, y_pred)\n\n        final_acc = float(run.summary.get(\"top1_accuracy\", np.nan))\n        aggregated[run_id] = {\"top1_accuracy\": final_acc}\n\n    # ---------------- Aggregated comparison -----------------------------\n    comparison_dir = results_dir / \"comparison\"\n    comparison_dir.mkdir(exist_ok=True)\n\n    baseline_id = run_ids[0] if run_ids else None\n    baseline_acc = aggregated.get(baseline_id, {}).get(\"top1_accuracy\", np.nan)\n\n    for rid, metrics in aggregated.items():\n        if baseline_id and rid != baseline_id and not np.isnan(baseline_acc):\n            metrics[\"improvement_rate\"] = (metrics[\"top1_accuracy\"] - baseline_acc) / baseline_acc\n        else:\n            metrics[\"improvement_rate\"] = 0.0\n\n        if baseline_id and rid != baseline_id:\n            y_true_b, y_pred_b = predictions_cache.get(baseline_id, ([], []))\n            y_true_o, y_pred_o = predictions_cache.get(rid, ([], []))\n            if y_true_b and y_pred_b and y_true_o and y_pred_o:\n                p_val = mcnemar_significance(y_true_b, y_pred_b, y_pred_o)\n            else:\n                p_val = np.nan\n            metrics[\"p_value_vs_baseline\"] = p_val\n        else:\n            metrics[\"p_value_vs_baseline\"] = np.nan\n\n    # Save aggregated metrics -------------------------------------------\n    agg_path = comparison_dir / \"aggregated_metrics.json\"\n    with open(agg_path, \"w\") as f:\n        json.dump(aggregated, f, indent=2)\n    generated_paths.append(str(agg_path))\n\n    # Accuracy bar chart -------------------------------------------------\n    labels = list(aggregated.keys())\n    accuracies = [aggregated[k][\"top1_accuracy\"] for k in labels]\n    plt.figure(figsize=(8, 4))\n    ax = sns.barplot(x=labels, y=accuracies)\n    for p, acc in zip(ax.patches, accuracies):\n        ax.annotate(f\"{acc:.2f}\", (p.get_x() + p.get_width() / 2, acc), ha=\"center\", va=\"bottom\")\n    plt.ylabel(\"Top-1 Accuracy (%)\")\n    plt.title(\"Accuracy comparison\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    bar_path = comparison_dir / \"top1_accuracy_comparison.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    generated_paths.append(str(bar_path))\n\n    # Improvement rates --------------------------------------------------\n    if len(aggregated) >= 2 and baseline_id is not None:\n        imp_labels = [l for l in labels if l != baseline_id]\n        imp_vals = [aggregated[l][\"improvement_rate\"] * 100 for l in imp_labels]\n        plt.figure(figsize=(8, 4))\n        ax2 = sns.barplot(x=imp_labels, y=imp_vals, color=\"skyblue\")\n        for p, v in zip(ax2.patches, imp_vals):\n            ax2.annotate(f\"{v:.2f}%\", (p.get_x() + p.get_width() / 2, v), ha=\"center\", va=\"bottom\")\n        plt.ylabel(\"Improvement over baseline (%)\")\n        plt.title(\"Relative improvement\")\n        plt.xticks(rotation=45, ha=\"right\")\n        plt.tight_layout()\n        imp_path = comparison_dir / \"improvement_rates.pdf\"\n        plt.savefig(imp_path)\n        plt.close()\n        generated_paths.append(str(imp_path))\n\n    # ---------------- Summary ------------------------------------------\n    print(\"\\n[Evaluation] Generated artefacts:\")\n    for p in generated_paths:\n        print(p)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "preprocess_py": "# src/preprocess.py\n\"\"\"Data loading & preprocessing pipeline for CIFAR-10-C.\"\"\"\n\nfrom __future__ import annotations\n\nimport tarfile\nfrom pathlib import Path\nfrom typing import List, Tuple, Union\n\nimport numpy as np\nimport requests\nfrom PIL import Image\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision import transforms\n\n###############################################################################\n# Constants -------------------------------------------------------------------\n###############################################################################\n\nCIFAR10C_URL = \"https://zenodo.org/record/3555552/files/CIFAR-10-C.tar?download=1\"\nCORRUPTIONS = [\n    \"gaussian_noise\",\n    \"shot_noise\",\n    \"impulse_noise\",\n    \"defocus_blur\",\n    \"glass_blur\",\n    \"motion_blur\",\n    \"zoom_blur\",\n    \"snow\",\n    \"frost\",\n    \"fog\",\n    \"brightness\",\n    \"contrast\",\n    \"elastic_transform\",\n    \"pixelate\",\n    \"jpeg_compression\",\n]\n\n###############################################################################\n# Download helpers ------------------------------------------------------------\n###############################################################################\n\ndef _download(url: str, dst: Path):\n    dst.parent.mkdir(parents=True, exist_ok=True)\n    with requests.get(url, stream=True) as r:\n        r.raise_for_status()\n        total = int(r.headers.get(\"content-length\", 0))\n        with open(dst, \"wb\") as f, tqdm(total=total, unit=\"iB\", unit_scale=True, desc=\"CIFAR-10-C\") as bar:\n            for chunk in r.iter_content(chunk_size=1024 * 1024):\n                if chunk:\n                    f.write(chunk)\n                    bar.update(len(chunk))\n\n\ndef _download_and_extract(url: str, cache_dir: Path) -> Path:\n    tar_path = cache_dir / \"CIFAR-10-C.tar\"\n    out_dir = cache_dir / \"CIFAR-10-C\"\n    if not out_dir.exists():\n        if not tar_path.exists():\n            print(\"Downloading CIFAR-10-C …\")\n            _download(url, tar_path)\n        print(\"Extracting CIFAR-10-C …\")\n        with tarfile.open(tar_path) as tar:\n            tar.extractall(path=cache_dir)\n    return out_dir\n\n###############################################################################\n# Dataset wrapper -------------------------------------------------------------\n###############################################################################\n\nclass NumpyArrayDataset(Dataset):\n    \"\"\"Simple Dataset around CIFAR-10-C numpy arrays.\"\"\"\n\n    def __init__(self, images: np.ndarray, labels: np.ndarray, transform=None):\n        self.images = images\n        self.labels = labels.astype(np.int64)\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.images)\n\n    def __getitem__(self, idx):\n        img = Image.fromarray(self.images[idx])\n        label = int(self.labels[idx])\n        if self.transform is not None:\n            img = self.transform(img)\n        return img, label\n\n###############################################################################\n# Public API ------------------------------------------------------------------\n###############################################################################\n\ndef load_cifar10c(\n    *,\n    severity: int = 5,\n    corruption_types: Union[str, List[str]] = \"all\",\n    cache_dir: Union[str, Path] = \".cache/\",\n) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Return images & labels subset of CIFAR-10-C.\n\n    Parameters\n    ----------\n    severity : int\n        Corruption severity in [1,5].\n    corruption_types : str | list[str]\n        Either \"all\" or subset of CORRUPTIONS.\n    cache_dir : str | Path\n        Directory to store / look up cached data.\n    \"\"\"\n    if not 1 <= severity <= 5:\n        raise ValueError(\"Severity must be in [1, 5]\")\n\n    cache_dir = Path(cache_dir)\n    extract_dir = _download_and_extract(CIFAR10C_URL, cache_dir)\n\n    if corruption_types == \"all\":\n        corruption_types = CORRUPTIONS\n\n    images_list = []\n    labels_base = np.load(extract_dir / \"labels.npy\")\n    start, end = (severity - 1) * 10_000, severity * 10_000\n\n    for corr in corruption_types:\n        corr_arr = np.load(extract_dir / f\"{corr}.npy\")\n        images_list.append(corr_arr[start:end])\n    images = np.concatenate(images_list, axis=0)\n    labels = np.tile(labels_base[start:end], len(corruption_types))\n    return images, labels\n\n\ndef build_dataloader(\n    dataset_cfg,\n    *,\n    split: str = \"test\",\n    cache_dir: str = \".cache/\",\n) -> DataLoader:\n    \"\"\"Build a DataLoader according to the Hydra ``dataset_cfg`` object.\"\"\"\n    cache_path = Path(cache_dir)\n\n    if dataset_cfg.name.lower() == \"cifar-10-c\":\n        imgs, lbls = load_cifar10c(\n            severity=dataset_cfg.severity,\n            corruption_types=dataset_cfg.corruption_types,\n            cache_dir=cache_path / \"cifar10_c\",\n        )\n        transform = transforms.Compose(\n            [\n                transforms.ToTensor(),\n                transforms.Normalize(\n                    mean=list(dataset_cfg.normalization.mean),\n                    std=list(dataset_cfg.normalization.std),\n                ),\n            ]\n        )\n        ds = NumpyArrayDataset(imgs, lbls, transform)\n        return DataLoader(\n            ds,\n            batch_size=dataset_cfg.batch_size,\n            shuffle=False,\n            num_workers=4,\n            pin_memory=torch.cuda.is_available(),\n        )\n\n    raise ValueError(f\"Unsupported dataset {dataset_cfg.name}\")\n",
    "model_py": "# src/model.py\n\"\"\"Model definitions & utilities (timm ResNet-18 + helpers for TENT/CW-TENT).\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Ensure timm model weights are stored locally\nos.environ.setdefault(\"TORCH_HOME\", \".cache/torch\")\nPath(os.environ[\"TORCH_HOME\"]).mkdir(parents=True, exist_ok=True)\n\nimport torch.nn as nn\nimport timm\n\n###############################################################################\n# Model factory ----------------------------------------------------------------\n###############################################################################\n\ndef build_model(model_cfg):\n    \"\"\"Create a timm model with the specified configuration.\"\"\"\n    model_name = getattr(model_cfg, \"checkpoint\", model_cfg.name)\n    model = timm.create_model(model_name, pretrained=model_cfg.pretrained, num_classes=10)\n    return model\n\n###############################################################################\n# TENT/CW-TENT helpers ---------------------------------------------------------\n###############################################################################\n\ndef freeze_non_bn_parameters(model: nn.Module):\n    \"\"\"Freeze all parameters except BatchNorm affine weights & biases.\"\"\"\n    for p in model.parameters():\n        p.requires_grad = False\n    for m in model.modules():\n        if isinstance(m, (nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d)):\n            if m.weight is not None:\n                m.weight.requires_grad_(True)\n            if m.bias is not None:\n                m.bias.requires_grad_(True)\n\n\ndef initialize_bn_adaptation(model: nn.Module):\n    \"\"\"Set BN layers to train mode & disable running-stats (TENT style).\"\"\"\n    for m in model.modules():\n        if isinstance(m, (nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d)):\n            m.train()\n            m.track_running_stats = False\n\n###############################################################################\n# Losses -----------------------------------------------------------------------\n###############################################################################\n\nimport torch\nimport torch.nn.functional as F\n\nclass EntropyLoss(nn.Module):\n    \"\"\"Standard prediction entropy loss used by TENT.\"\"\"\n\n    def forward(self, logits: torch.Tensor) -> torch.Tensor:  # noqa: D401\n        p = F.softmax(logits, dim=1)\n        ent = -(p * torch.clamp(p, min=1e-12).log()).sum(dim=1)\n        return ent.mean()\n\n\nclass ConfidenceWeightedEntropyLoss(nn.Module):\n    \"\"\"Confidence-Weighted entropy loss (proposed).\"\"\"\n\n    def forward(self, logits: torch.Tensor) -> torch.Tensor:  # noqa: D401\n        p = F.softmax(logits, dim=1)\n        ent = -(p * torch.clamp(p, min=1e-12).log()).sum(dim=1)\n        num_classes = logits.size(1)\n        weights = 1.0 - ent / torch.log(torch.tensor(num_classes, device=logits.device, dtype=ent.dtype))\n        return (weights * ent).sum() / torch.clamp(weights.sum(), min=1e-12)\n",
    "main_py": "# src/main.py\n\"\"\"Main orchestrator – launches a single experiment run as a subprocess.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport shlex\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nfrom hydra.core.hydra_config import HydraConfig\nfrom hydra.utils import get_original_cwd\nfrom omegaconf import OmegaConf\n\n###############################################################################\n# Hydra entry-point -----------------------------------------------------------\n###############################################################################\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg):\n    original_cwd = Path(get_original_cwd())\n\n    # Persist full configuration (for evaluate.py)\n    results_dir = Path(cfg.results_dir)\n    results_dir.mkdir(parents=True, exist_ok=True)\n    cfg_path = results_dir / \"config.yaml\"\n    if not cfg_path.exists():\n        OmegaConf.save(config=cfg, f=str(cfg_path))\n\n    task_overrides: List[str] = list(HydraConfig.get().overrides.task)\n\n    # Trial-mode convenience overrides -----------------------------------\n    if cfg.get(\"trial_mode\", False):\n        if \"wandb.mode=disabled\" not in task_overrides:\n            task_overrides.append(\"wandb.mode=disabled\")\n        if \"optuna.n_trials=0\" not in task_overrides:\n            task_overrides.append(\"optuna.n_trials=0\")\n        # Make only one epoch during trial-mode\n        if \"run.training.epochs=1\" not in task_overrides:\n            task_overrides.append(\"run.training.epochs=1\")\n\n    # Ensure results_dir propagates\n    if f\"results_dir={cfg.results_dir}\" not in task_overrides:\n        task_overrides.append(f\"results_dir={cfg.results_dir}\")\n\n    launch_cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", *task_overrides]\n\n    env = os.environ.copy()\n    env[\"PYTHONPATH\"] = f\"{original_cwd}:{env.get('PYTHONPATH', '')}\"\n\n    print(\"\\n[Launcher] Executing:\\n  \", \" \".join(map(shlex.quote, launch_cmd)))\n    subprocess.check_call(launch_cmd, env=env)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject_toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cw_tent_experiments\"\nversion = \"0.1.0\"\ndescription = \"Confidence-Weighted TENT experiments with Hydra & WandB\"\nauthors = [{name = \"AI Autogenerated\", email = \"noreply@example.com\"}]\nrequires-python = \">=3.8\"\n\n[project.dependencies]\ntorch = \"*\"\ntorchvision = \"*\"\ntimm = \"*\"\nhydra-core = \"*\"\noptuna = \"*\"\nwandb = \"*\"\n\nnumpy = \"*\"\npandas = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nscikit-learn = \"*\"\nscipy = \"*\"\nPillow = \"*\"\nrequests = \"*\"\nPyYAML = \"*\"\ntqdm = \"*\"\n",
    "config_yaml": "defaults:\n  - _self_\n  - run: ???\n\n# Global switches -------------------------------------------------------------\ntrial_mode: false            # set to true via CLI for lightweight CI validation\nresults_dir: ./results       # can be overridden from CLI\n\n# WandB configuration ---------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online               # automatically switched to \"disabled\" in trial_mode\n\n# Optuna (overwritten by run configs) -----------------------------------------\noptuna:\n  n_trials: 0\n  direction: maximize\n  metric: top1_accuracy\n  search_space: {}\n"
}
