
LLM Name: o3-2025-04-16
Input:
You are a cutting-edge AI researcher generating complete, executable code for research paper experiments with Hydra configuration management.

Based on the research method in # Current Research Method and experimental design in # Experimental Design, generate production-ready experiment code that integrates with Hydra for configuration management.

# Instructions: Complete Experiment Code Generation

## Core Requirements
- COMPLETE IMPLEMENTATION: Every component must be fully functional, production-ready, publication-worthy code. No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
- PYTORCH EXCLUSIVELY: Use PyTorch as the deep learning framework
- HYDRA INTEGRATION: Use Hydra to manage all experiment configurations from `config/run/*.yaml` files. Use `config_path="../config"` in all @hydra.main decorators
- COMPLETE DATA PIPELINE: Full data loading and preprocessing implementation. Use `.cache/` as the cache directory for all datasets and models (e.g., for HuggingFace, set `cache_dir=".cache/"`)
- WANDB REQUIRED: WandB is mandatory for metrics logging (except trial_mode validation)

## Hydra Configuration Structure
Each run config file (`config/run/{run_id}.yaml`) contains:
- run_id: Unique identifier for this run
- method: The method name (baseline, proposed, ablation, etc.)
- model: Model-specific parameters (name, architecture details, hyperparameters)
- dataset: Dataset-specific parameters (name, preprocessing settings, split ratios)
- training: Training hyperparameters (learning rate, batch size, epochs, optimizer settings, validation split)
- optuna: Hyperparameter search space definition for Optuna optimization

## Command Line Interface
The generated code must support the following CLI:

**Training (main.py):**
```bash
# Full experiment with WandB logging
uv run python -u -m src.main run={run_id} results_dir={path}

# Trial mode (validation only, WandB disabled)
uv run python -u -m src.main run={run_id} results_dir={path} trial_mode=true
```
- `run`: Experiment run_id (matching a run_id from config/run/*.yaml)
- `results_dir`: Output directory (passed from GitHub Actions workflow)
- `trial_mode=true` (optional): Lightweight execution for validation (epochs=1, batches limited to 1-2, disable Optuna n_trials=0, **WandB disabled**)

**Evaluation (evaluate.py, independent execution):**
```bash
uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'
```
- `results_dir`: Directory containing experiment metadata and where outputs will be saved
- `run_ids`: JSON string list of run IDs to evaluate (e.g., '["run-1-proposed-bert-glue", "run-2-baseline-bert-glue"]')
- Executed as a separate workflow after all training runs complete
- **NOT called from main.py**

## Script Structure (ExperimentCode format)
Generate complete code for these files ONLY. Do not create any additional files beyond this structure:

**`src/train.py`**: Single experiment run executor
- Uses Hydra config to load all parameters
- Called as subprocess by main.py
- Responsibilities:
  * Train model with given configuration
  * Initialize WandB: `wandb.init(entity=cfg.wandb.entity, project=cfg.wandb.project, id=cfg.run.run_id, config=OmegaConf.to_container(cfg, resolve=True), resume="allow")`
  * Skip `wandb.init()` if `cfg.wandb.mode == "disabled"` (trial_mode)
  * Log ALL metrics to WandB: `wandb.log({"train_loss": 0.5, "val_acc": 0.85, "epoch": 1, ...})`
  * Print WandB run URL to stdout
- **NO results.json, no stdout JSON output, no figure generation**

**`src/evaluate.py`**: Independent evaluation and visualization script
- **Execution**: Run independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
- **NOT called from main.py** - executes as separate workflow after all training completes
- **Responsibilities**:
  * Parse command line arguments:
    - `results_dir`: Output directory path
    - `run_ids`: JSON string list of run IDs (parse with `json.loads(args.run_ids)`)
  * Load WandB config from `{results_dir}/config.yaml`
  * Retrieve experimental data from WandB API for specified run_ids:
    ```python
    import json
    api = wandb.Api()
    run_ids = json.loads(args.run_ids)  # Parse JSON string to list
    for run_id in run_ids:
        run = api.run(f"{entity}/{project}/{run_id}")
        metrics_df = run.history()  # pandas DataFrame with all logged metrics
    ```
  * **STEP 1: Per-Run Processing** (for each run_id):
    - Export run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
    - Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
    - Each run should have its own subdirectory with its metrics and figures
  * **STEP 2: Aggregated Analysis** (after processing all runs):
    - Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
    - Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
    - Generate comparison figures to: `{results_dir}/comparison/`:
      * Cross-run comparison charts (bar charts, box plots)
      * Performance metrics tables
      * Statistical significance tests
  * **Figure Generation Guidelines**:
    - Use matplotlib or seaborn with proper legends, annotations, tight_layout
    - For line graphs: annotate significant values (final/best values)
    - For bar graphs: annotate values above each bar
    - Follow naming convention: `<figure_topic>[_<condition>][_pairN].pdf`
  * Print all generated file paths to stdout (both per-run and comparison)

**`src/preprocess.py`**: Complete preprocessing pipeline implementation for the specified datasets

**`src/model.py`**: Complete model architecture implementations for all methods (proposed and comparative methods)

**`src/main.py`**: Main orchestrator
- Receives run_id via Hydra, launches train.py as subprocess, manages logs
- **DOES NOT call evaluate.py** (evaluate.py runs independently in separate workflow)
- Use `@hydra.main(config_path="../config")` since execution is from repository root
- Pass all Hydra overrides to train.py subprocess (e.g., `wandb.mode=disabled`, `trial_mode=true`)
- In trial_mode, automatically set `wandb.mode=disabled`

**`config/config.yaml`**: Main Hydra configuration file
- MUST include WandB configuration:
  ```yaml
  wandb:
    entity: gengaru617-personal
    project: 251020-test
    mode: online  # Automatically set to "disabled" in trial_mode
  ```

**`pyproject.toml`**: Complete project dependencies
- MUST include: `hydra-core`, `wandb` (required)
- Include as needed: `optuna`, `torch`, `transformers`, `datasets`, etc.


## Key Implementation Focus Areas
1. **Hydra-Driven Configuration**: All parameters loaded from run configs dynamically
2. **Algorithm Core**: Full implementation of the proposed method with proper abstraction
3. **Trial Mode Behavior**: trial_mode=true automatically disables WandB (sets wandb.mode=disabled)
4. **Run Execution**: main.py executes a single run_id passed via CLI (GitHub Actions dispatches multiple runs separately)
5. **WandB Integration**: All metrics logged to WandB; train.py does NOT output JSON to stdout or save results.json
6. **Independent Evaluation**: evaluate.py runs separately, fetches data from WandB API, generates all figures



## Code Validation Feedback


**Previous Validation Issue**: The code runs end-to-end but does NOT satisfy all mandatory requirements:

1. Evaluation script incompleteness (Core criterion #8):
   • Step-2 aggregated analysis misses all statistical significance tests and derived/secondary metrics (e.g. improvement-rate).  Only a bar-plot and raw means are created.
   • Confusion matrices are required for every run but are generated only when `y_true`/`y_pred` are present in WandB history.  train.py never logs these fields, so confusion matrices will never be produced.

2. Requirement #8 demands the figures/tables "performance metrics tables"; these are absent.

Because the evaluation pipeline is not fully implemented, the experiment package is NOT yet production-ready.
**Action Required**: Address this issue in the implementation.

**Previous Code (for reference)**:
{"config_yaml": "# config/config.yaml \u2013 root Hydra configuration\n# ------------------------------------------------\nrun: default-run-id        # overridden from CLI (name of YAML inside config/run/)\nresults_dir: ./results     # overridden from CLI\ntrial_mode: false          # set to true for quick CI runs\n\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online             # automatically set to \"disabled\" in trial_mode\n\noptuna:\n  n_trials: 0              # 0 \u2192 disabled (fast); can be overridden per-run\n  direction: maximize\n  metric: top1_accuracy\n  search_space: {}\n\nlogging:\n  log_every_n_steps: 50\n", "evaluate_py": "\"\"\"src/evaluate.py \u2013 post-hoc evaluation \u0026 visualisation\n-------------------------------------------------------\nUsage example:\n    uv run python -m src.evaluate results_dir=./results \\\n                                run_ids=\u0027[\"run-1\", \"run-2\"]\u0027\nThe script is **not** invoked by the training code. It downloads\nmetrics from WandB, saves them locally, and produces comparison figures.\n\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom sklearn.metrics import confusion_matrix\n\nsns.set_style(\"whitegrid\")\nplt.rcParams.update({\"figure.dpi\": 160})\n\n# ---------------------------------------------------------------------------\n#                               Small utilities\n# ---------------------------------------------------------------------------\n\ndef _save_json(obj: Any, path: Path) -\u003e None:\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with open(path, \"w\") as fh:\n        json.dump(obj, fh, indent=2)\n\n\ndef _save_fig(fig, path: Path) -\u003e None:  # noqa: ANN001 \u2013 matplotlib Figure\n    path.parent.mkdir(parents=True, exist_ok=True)\n    fig.tight_layout()\n    fig.savefig(path, format=\"pdf\")\n    plt.close(fig)\n\n\ndef _flatten(series):\n    flat: List[int] = []\n    for item in series.dropna():\n        if isinstance(item, list):\n            flat.extend(item)\n        else:\n            flat.append(int(item))\n    return flat\n\n# ---------------------------------------------------------------------------\n#                           CLI parsing (key=value)\n# ---------------------------------------------------------------------------\n\ndef _parse_cli(argv: List[str]) -\u003e Dict[str, str]:\n    out: Dict[str, str] = {}\n    for tok in argv[1:]:  # skip prog name\n        if \"=\" not in tok:\n            raise RuntimeError(f\"Unexpected token \u0027{tok}\u0027. Expected key=value format.\")\n        k, v = tok.split(\"=\", 1)\n        out[k] = v\n    missing = {\"results_dir\", \"run_ids\"} - out.keys()\n    if missing:\n        raise RuntimeError(f\"Missing CLI argument(s): {missing}\")\n    return out\n\n\n# ---------------------------------------------------------------------------\n#                       Per-run processing \u0026 figures\n# ---------------------------------------------------------------------------\n\ndef process_single_run(run: wandb.apis.public.Run, out_dir: Path) -\u003e None:\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    history = run.history(keys=None, pandas=True)\n    history.to_json(out_dir / \"metrics.json\", orient=\"records\")\n\n    # ------------------------- learning curve of accuracy after adaptation\n    if {\"global_step\", \"acc_after\"}.issubset(history.columns):\n        fig, ax = plt.subplots(figsize=(6, 4))\n        ax.plot(history[\"global_step\"], history[\"acc_after\"], label=\"Acc after\", lw=2)\n        if \"acc_before\" in history.columns:\n            ax.plot(\n                history[\"global_step\"], history[\"acc_before\"], label=\"Acc before\", lw=1.5, ls=\"--\"\n            )\n        ax.set_xlabel(\"Batch #\")\n        ax.set_ylabel(\"Accuracy\")\n        ax.set_title(f\"Learning Curve \u2013 {run.id}\")\n        ax.legend()\n        _save_fig(fig, out_dir / \"learning_curve.pdf\")\n\n    # ------------------------- confusion matrix (aggregated over stream)\n    if {\"y_true\", \"y_pred\"}.issubset(history.columns):\n        y_true = _flatten(history[\"y_true\"])\n        y_pred = _flatten(history[\"y_pred\"])\n        if y_true:\n            cm = confusion_matrix(y_true, y_pred)\n            fig, ax = plt.subplots(figsize=(5, 4))\n            sns.heatmap(cm, cmap=\"Blues\", ax=ax, cbar=True, annot=False)\n            ax.set_xlabel(\"Predicted\")\n            ax.set_ylabel(\"True\")\n            ax.set_title(f\"Confusion Matrix \u2013 {run.id}\")\n            _save_fig(fig, out_dir / \"confusion_matrix.pdf\")\n\n    print(out_dir / \"metrics.json\")\n\n\n# ---------------------------------------------------------------------------\n#                          Aggregated comparison\n# ---------------------------------------------------------------------------\n\ndef aggregate(runs: List[wandb.apis.public.Run], out_dir: Path) -\u003e None:\n    out_dir.mkdir(parents=True, exist_ok=True)\n    rows: List[Dict[str, Any]] = []\n    for r in runs:\n        rows.append(\n            {\n                \"run_id\": r.id,\n                \"method\": r.config.get(\"method\", {}).get(\"name\", \"n/a\"),\n                \"final_acc\": r.summary.get(\"final_top1_accuracy\", None),\n            }\n        )\n    df = pd.DataFrame(rows)\n    _save_json(df.to_dict(orient=\"records\"), out_dir / \"aggregated_metrics.json\")\n\n    # bar chart comparison ------------------------------------------------\n    fig, ax = plt.subplots(figsize=(6, 4))\n    sns.barplot(data=df, x=\"run_id\", y=\"final_acc\", hue=\"method\", ax=ax)\n    for bar in ax.patches:\n        height = bar.get_height()\n        if not pd.isna(height):\n            ax.annotate(f\"{height:.1%}\", (bar.get_x() + bar.get_width() / 2, height),\n                        ha=\"center\", va=\"bottom\", fontsize=8)\n    ax.set_ylabel(\"Top-1 Accuracy\")\n    ax.set_xlabel(\"Run ID\")\n    ax.set_title(\"Final Accuracy Across Runs\")\n    ax.legend()\n    _save_fig(fig, out_dir / \"final_accuracy_comparison.pdf\")\n\n    print(out_dir / \"aggregated_metrics.json\")\n\n\n# ---------------------------------------------------------------------------\n#                                   main()\n# ---------------------------------------------------------------------------\n\ndef main() -\u003e None:\n    cli = _parse_cli(sys.argv)\n    results_dir = Path(cli[\"results_dir\"]).expanduser().resolve()\n    run_ids: List[str] = json.loads(cli[\"run_ids\"])\n\n    # --- load WandB credentials written by train.py\n    with open(results_dir / \"wandb_config.yaml\", \"r\") as fh:\n        w_cfg = yaml.safe_load(fh)[\"wandb\"]\n    entity, project = w_cfg[\"entity\"], w_cfg[\"project\"]\n\n    api = wandb.Api()\n    runs: List[wandb.apis.public.Run] = []\n    for rid in run_ids:\n        run = api.run(f\"{entity}/{project}/{rid}\")\n        runs.append(run)\n        process_single_run(run, results_dir / rid)\n\n    aggregate(runs, results_dir / \"comparison\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "main_py": "\"\"\"src/main.py \u2013 lightweight orchestrator that spawns src.train as subprocess.\n-----------------------------------------------------------------------------\nIt parses the root Hydra config, then forwards *all* CLI overrides (unfiltered)\nto the training subprocess so that users can pass arbitrary adjustments.\n\"\"\"\nfrom __future__ import annotations\n\nimport subprocess\nimport sys\nfrom typing import List\n\nimport hydra\nfrom hydra.core.hydra_config import HydraConfig\nfrom omegaconf import DictConfig\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg: DictConfig) -\u003e None:  # noqa: D401 \u2013 simple description is fine\n    \"\"\"Spawn `src.train` with the same overrides Hydra received.\"\"\"\n    # Retrieve *original* CLI overrides Hydra saw (before resolving paths)\n    overrides: List[str] = HydraConfig.get().overrides.task.copy()\n\n    # Ensure essential overrides are present / updated --------------------\n    # We remove potential duplicates for cleanliness\n    filtered = [o for o in overrides if not o.startswith((\"run=\", \"results_dir=\", \"trial_mode=\"))]\n    filtered.append(f\"run={cfg.run}\")\n    filtered.append(f\"results_dir={cfg.results_dir}\")\n    if cfg.get(\"trial_mode\", False):\n        filtered.append(\"trial_mode=true\")\n\n    # Build subprocess command -------------------------------------------\n    cmd: List[str] = [\n        sys.executable,\n        \"-u\",\n        \"-m\",\n        \"src.train\",\n        *filtered,\n    ]\n\n    print(\"[main] Launching subprocess:\\n  \", \" \".join(cmd))\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "\"\"\"src/model.py \u2013 backbone construction \u0026 adaptation wrappers.\"\"\"\nfrom __future__ import annotations\n\nimport math\nimport os\n\nimport timm\nimport torch\nimport torch.nn as nn\n\n__all__ = [\"create_backbone\", \"TentAdapter\", \"CWTentAdapter\"]\n\n\n# ---------------------------------------------------------------------------\n#                         Backbone helper function\n# ---------------------------------------------------------------------------\n\ndef create_backbone(cfg) -\u003e nn.Module:  # noqa: ANN001 \u2013 cfg is Hydra object\n    os.environ.setdefault(\"TORCH_HOME\", \".cache\")  # ensure local weight cache\n    model = timm.create_model(\n        cfg.model.name,\n        pretrained=bool(cfg.model.pretrained),\n        num_classes=int(cfg.model.num_classes),\n        cache_dir=\".cache/\",\n    )\n\n    # freeze everything ----------------------------------------------------\n    for p in model.parameters():\n        p.requires_grad_(False)\n    # un-freeze BatchNorm affine params only\n    for m in model.modules():\n        if isinstance(m, (nn.BatchNorm2d, nn.SyncBatchNorm)):\n            if m.weight is not None:\n                m.weight.requires_grad_(True)\n            if m.bias is not None:\n                m.bias.requires_grad_(True)\n    model.eval()\n    return model\n\n\n# ---------------------------------------------------------------------------\n#                       Utility: entropy from probabilities\n# ---------------------------------------------------------------------------\n\ndef entropy_from_probs(p: torch.Tensor) -\u003e torch.Tensor:\n    return -(p * (p + 1e-8).log()).sum(1)\n\n\n# ---------------------------------------------------------------------------\n#                       Base adapter (shared functionality)\n# ---------------------------------------------------------------------------\n\nclass _BaseAdapter(nn.Module):\n    def __init__(self, backbone: nn.Module):\n        super().__init__()\n        self.backbone = backbone\n        self.num_classes = getattr(backbone, \"num_classes\", None)\n        if self.num_classes is None:\n            raise ValueError(\"Backbone missing \u0027num_classes\u0027 attribute.\")\n        self.backbone.train()  # BN layers use batch stats during adaptation\n\n    @torch.no_grad()\n    def predict(self, x: torch.Tensor) -\u003e torch.Tensor:\n        self.backbone.eval()\n        logits = self.backbone(x)\n        return logits.softmax(1)\n\n\n# ---------------------------------------------------------------------------\n#                           Original TENT adapter\n# ---------------------------------------------------------------------------\n\nclass TentAdapter(_BaseAdapter):\n    def __init__(\n        self,\n        backbone: nn.Module,\n        lr: float,\n        momentum: float = 0.9,\n        inner_steps: int = 1,\n        weight_decay: float = 0.0,\n    ) -\u003e None:\n        super().__init__(backbone)\n        params = [p for p in backbone.parameters() if p.requires_grad]\n        self.optimizer = torch.optim.SGD(\n            params, lr=lr, momentum=momentum, weight_decay=weight_decay\n        )\n        self.inner_steps = int(inner_steps)\n\n    def adapt(self, x: torch.Tensor) -\u003e float:\n        self.backbone.train()\n        last_loss = 0.0\n        for _ in range(self.inner_steps):\n            logits = self.backbone(x)\n            probs = logits.softmax(1)\n            loss = entropy_from_probs(probs).mean()\n            self.optimizer.zero_grad()\n            loss.backward()\n            self.optimizer.step()\n            last_loss = float(loss.item())\n        self.backbone.eval()\n        return last_loss\n\n\n# ---------------------------------------------------------------------------\n#                     Confidence-Weighted TENT adapter\n# ---------------------------------------------------------------------------\n\nclass CWTentAdapter(TentAdapter):\n    \"\"\"Implements confidence-weighted entropy minimisation (single step).\"\"\"\n\n    def adapt(self, x: torch.Tensor) -\u003e float:  # override\n        self.backbone.train()\n        logits = self.backbone(x)\n        probs = logits.softmax(1)\n        entropy = entropy_from_probs(probs)\n        weights = 1.0 - entropy / math.log(self.num_classes)\n        loss = (weights * entropy).sum() / weights.sum()\n        self.optimizer.zero_grad()\n        loss.backward()\n        self.optimizer.step()\n        self.backbone.eval()\n        return float(loss.item())\n", "preprocess_py": "\"\"\"src/preprocess.py \u2013 dataset loading \u0026 preprocessing pipeline.\"\"\"\nfrom __future__ import annotations\n\nimport warnings\nfrom typing import Iterator, List, Tuple\n\nimport torch\nimport torchvision.transforms as T\nfrom torch.utils.data import DataLoader, Dataset, TensorDataset\nfrom torchvision.datasets import CIFAR10\n\n# RobustBench is optional \u2013 fall back gracefully if missing\ntry:\n    from robustbench.data import load_cifar10c\n\n    _ROBUSTBENCH_AVAILABLE = True\n    CORRUPTIONS_ALL = [\n        \"gaussian_noise\",\n        \"shot_noise\",\n        \"impulse_noise\",\n        \"defocus_blur\",\n        \"glass_blur\",\n        \"motion_blur\",\n        \"zoom_blur\",\n        \"snow\",\n        \"frost\",\n        \"fog\",\n        \"brightness\",\n        \"contrast\",\n        \"elastic_transform\",\n        \"pixelate\",\n        \"jpeg_compression\",\n    ]\nexcept ImportError:  # pragma: no cover\n    _ROBUSTBENCH_AVAILABLE = False\n    CORRUPTIONS_ALL: List[str] = []\n\nIMAGENET_MEAN = (0.485, 0.456, 0.406)\nIMAGENET_STD = (0.229, 0.224, 0.225)\n\n\n# ---------------------------------------------------------------------------\n#                         internal helper functions\n# ---------------------------------------------------------------------------\n\ndef _np_to_tensor(arr):\n    return torch.from_numpy(arr).permute(0, 3, 1, 2).float().div(255.0)\n\n\n# ---------------------------------------------------------------------------\n#                       public DataLoader-builder entry\n# ---------------------------------------------------------------------------\n\ndef build_dataloader(cfg, device: torch.device) -\u003e Iterator[Tuple[torch.Tensor, torch.Tensor]]:\n    \"\"\"Return an iterator that yields batches already on *device*.\"\"\"\n    name = str(cfg.dataset.name).lower()\n    batch_size = int(cfg.dataset.batch_size)\n    severity = int(getattr(cfg.dataset, \"corruption_severity\", 5))\n\n    # -------------------------------------------------- CIFAR-10-C via RobustBench\n    if \"cifar\" in name and \"c\" in name and _ROBUSTBENCH_AVAILABLE:\n        corruption_types = cfg.dataset.corruption_types\n        if corruption_types in {\"all\", \"*\", None}:\n            corruption_types = CORRUPTIONS_ALL\n        elif isinstance(corruption_types, str):\n            corruption_types = [corruption_types]\n\n        xs, ys = [], []\n        for c in corruption_types:\n            x_np, y_np = load_cifar10c(c, severity, data_dir=\".cache/cifar10c\")\n            xs.append(_np_to_tensor(x_np))\n            ys.append(torch.from_numpy(y_np))\n        images = torch.cat(xs, dim=0)\n        labels = torch.cat(ys).long()\n        dataset: Dataset = TensorDataset(images, labels)\n    else:\n        # ------------------------------------------- fallback to vanilla CIFAR-10 test set\n        if not _ROBUSTBENCH_AVAILABLE:\n            warnings.warn(\"RobustBench not found \u2013 using standard CIFAR-10 test set.\")\n        transform = T.Compose([\n            T.ToTensor(),\n            T.Normalize(IMAGENET_MEAN, IMAGENET_STD),\n        ])\n        dataset = CIFAR10(root=\".cache/cifar10\", train=False, download=True, transform=transform)\n\n    dataloader = DataLoader(\n        dataset,\n        batch_size=batch_size,\n        shuffle=getattr(cfg.dataset, \"shuffle\", False),\n        num_workers=getattr(cfg.dataset, \"num_workers\", 4),\n        pin_memory=True,\n        drop_last=False,\n    )\n\n    # Move tensors to device on-the-fly -----------------------------------\n    def _iter():\n        for x, y in dataloader:\n            x = x.to(device, non_blocking=True)\n            y = y.to(device, non_blocking=True)\n            if x.max() \u003c= 1.0:  # ensure normalisation for CIFAR-10-C loaded raw\n                x = T.Normalize(IMAGENET_MEAN, IMAGENET_STD)(x)\n            yield x, y\n\n    return _iter()\n", "pyproject_toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\"]\n\n[project]\nname = \"cw-tent-experiments\"\nversion = \"0.3.0\"\n\n[project.dependencies]\ntorch = \"\u003e=2.0\"\ntorchvision = \"*\"\ntimm = \"*\"\nrobustbench = \"*\"  # optional, used when available\nhydra-core = \"*\"\nomegaconf = \"*\"\nwandb = \"*\"\noptuna = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nscikit-learn = \"*\"\npandas = \"*\"\npyyaml = \"*\"\n", "train_py": "\"\"\"src/train.py \u2013 executes a single experiment run (training / adaptation)\n--------------------------------------------------------------------------\nThis file MUST be fully self-contained and production-ready. It loads the\nrun-specific configuration, prepares data + model, launches the adaptation\nloop, and logs everything to WandB (unless trial_mode disables it).\n\"\"\"\nfrom __future__ import annotations\n\nimport os\nimport random\nimport re\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\nimport hydra\nimport numpy as np\nimport optuna\nimport torch\nimport wandb\nimport yaml\nfrom omegaconf import DictConfig, OmegaConf\n\nfrom .model import CWTentAdapter, TentAdapter, create_backbone\nfrom .preprocess import build_dataloader\n\n# ---------------------------------------------------------------------------\n#                         Re-usable helper utilities\n# ---------------------------------------------------------------------------\n\ndef seed_everything(seed: int = 42) -\u003e None:\n    \"\"\"Guarantee deterministic behaviour as much as possible.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True  # type: ignore[attr-defined]\n    torch.backends.cudnn.benchmark = False  # type: ignore[attr-defined]\n\n\ndef slugify(value: str) -\u003e str:\n    \"\"\"Very light slugification (file-system \u0026 URL friendly).\"\"\"\n    value = value.strip().replace(\" \", \"_\")\n    return re.sub(r\"[^A-Za-z0-9_.-]\", \"_\", value)\n\n\ndef accuracy(pred: torch.Tensor, tgt: torch.Tensor) -\u003e float:\n    return (pred.argmax(1) == tgt).float().mean().item()\n\n\n# ---------------------------------------------------------------------------\n#                           Core adaptation routine\n# ---------------------------------------------------------------------------\n\ndef run_adaptation(cfg: DictConfig) -\u003e Dict[str, float]:\n    \"\"\"Stream through the dataset once while adapting online.\"\"\"\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    dataloader = build_dataloader(cfg, device)\n\n    backbone = create_backbone(cfg).to(device)\n    method_key = str(cfg.method.name).upper()\n    if method_key in {\"TENT\"}:\n        AdapterCls = TentAdapter\n    elif method_key in {\"CW-TENT\", \"CWTENT\", \"CWTENTADAPTER\"}:\n        AdapterCls = CWTentAdapter\n    else:\n        raise ValueError(f\"Unsupported method: {cfg.method.name}\")\n\n    adapter = AdapterCls(\n        backbone,\n        lr=cfg.training.learning_rate,\n        momentum=cfg.training.momentum,\n        inner_steps=cfg.method.inner_steps,\n        weight_decay=cfg.training.weight_decay,\n    )\n\n    total_correct, total_seen = 0, 0\n\n    for step, (imgs, lbls) in enumerate(dataloader, 1):\n        # ----- prediction BEFORE adaptation (for analysis only)\n        pred_before = adapter.predict(imgs)\n        acc_before = accuracy(pred_before, lbls)\n\n        # ----- single / multiple gradient steps\n        loss_val = adapter.adapt(imgs)\n\n        # ----- prediction AFTER adaptation\n        pred_after = adapter.predict(imgs)\n        acc_after = accuracy(pred_after, lbls)\n\n        total_correct += (pred_after.argmax(1) == lbls).sum().item()\n        total_seen += lbls.size(0)\n\n        if step == 1 or step % cfg.logging.log_every_n_steps == 0:\n            log_payload = {\n                \"train_loss\": loss_val,\n                \"acc_before\": acc_before,\n                \"acc_after\": acc_after,\n                \"global_step\": step,\n                \"epoch\": 1,  # online stream assumed as single epoch\n            }\n            if cfg.wandb.mode != \"disabled\":\n                wandb.log(log_payload)\n            # concise stdout message (human-readable, no JSON!)\n            print(\n                f\"[step {step:04d}] loss={loss_val:.4f}  acc_before={acc_before:.4f}  \"\n                f\"acc_after={acc_after:.4f}\"\n            )\n\n        # ------------------------- early exit in trial mode\n        if cfg.get(\"trial_mode\", False) and step \u003e= cfg.trial_limit_batches:\n            break\n\n    final_acc = total_correct / max(1, total_seen)\n    if cfg.wandb.mode != \"disabled\":\n        wandb.log({\"final_top1_accuracy\": final_acc})\n        wandb.run.summary[\"final_top1_accuracy\"] = final_acc\n    return {\"top1_accuracy\": final_acc, \"processed_batches\": step}\n\n\n# ---------------------------------------------------------------------------\n#                  Optuna hyper-parameter optimisation helper\n# ---------------------------------------------------------------------------\n\ndef build_objective(cfg_template: DictConfig):\n    \"\"\"Create an Optuna objective that clones \u0026 mutates *cfg_template*.\"\"\"\n\n    # mapping from search space flat keys \u2192 dotted config paths\n    name2path = {\n        \"learning_rate\": \"training.learning_rate\",\n        \"momentum\": \"training.momentum\",\n        \"weight_decay\": \"training.weight_decay\",\n        \"batch_size\": \"dataset.batch_size\",\n        \"inner_steps\": \"method.inner_steps\",\n    }\n\n    def objective(trial: optuna.Trial):\n        cfg = OmegaConf.create(OmegaConf.to_container(cfg_template, resolve=True))\n        for param_name, spec in cfg_template.optuna.search_space.items():\n            # spec is a DictConfig with keys like {type, low, high, choices}\n            t = str(spec.type)\n            if t == \"loguniform\":\n                val = trial.suggest_float(param_name, spec.low, spec.high, log=True)\n            elif t == \"uniform\":\n                val = trial.suggest_float(param_name, spec.low, spec.high)\n            elif t == \"int\":\n                val = trial.suggest_int(param_name, spec.low, spec.high)\n            elif t == \"categorical\":\n                val = trial.suggest_categorical(param_name, spec.choices)\n            else:\n                raise ValueError(f\"Unknown search-space type: {t}\")\n            target_path = name2path.get(param_name, param_name)\n            OmegaConf.update(cfg, target_path, val, merge=False)\n        result = run_adaptation(cfg)\n        return result[cfg.optuna.metric]\n\n    return objective\n\n\n# ---------------------------------------------------------------------------\n#                               Hydra entry-point\n# ---------------------------------------------------------------------------\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg_cli: DictConfig) -\u003e None:\n    \"\"\"Hydra-driven main that resolves the run-specific YAML and executes it.\"\"\"\n\n    # ---------------------------------------------------------------------\n    #   Locate \u0026 load the run-specific YAML (relative to project root)\n    # ---------------------------------------------------------------------\n    run_name: str = str(cfg_cli.run)  # string identifying which YAML to load\n    run_cfg_path = (\n        Path(__file__).resolve().parents[1] / \"config\" / \"run\" / f\"{run_name}.yaml\"\n    )\n    if not run_cfg_path.exists():\n        raise FileNotFoundError(f\"Run-config not found: {run_cfg_path}\")\n\n    cfg_run = OmegaConf.load(run_cfg_path)\n    # Merge **cli first**, then run-dict so that nested structures are kept.\n    cfg: DictConfig = OmegaConf.merge(cfg_cli, cfg_run)\n\n    # ---------------------------------------------------------------------\n    #   Trial-mode lightening tweaks (CI / quick validation)\n    # ---------------------------------------------------------------------\n    if cfg.get(\"trial_mode\", False):\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.trial_limit_batches = 2  # iterate over just a couple of batches\n    else:\n        cfg.trial_limit_batches = int(1e12)\n\n    # ---------------------------------------------------------------------\n    #   File-system preparation \u0026 config persistence\n    # ---------------------------------------------------------------------\n    results_root = Path(cfg.results_dir).expanduser().resolve()\n    results_root.mkdir(parents=True, exist_ok=True)\n\n    run_dir = results_root / slugify(str(cfg.run_id if \"run_id\" in cfg else cfg_run.run_id))\n    run_dir.mkdir(parents=True, exist_ok=True)\n\n    # persist full config for reproducibility\n    with open(run_dir / \"config.yaml\", \"w\") as fh:\n        yaml.safe_dump(OmegaConf.to_container(cfg, resolve=True), fh)\n\n    # stash WandB credentials once per results-dir (for evaluate.py)\n    wandb_cfg_file = results_root / \"wandb_config.yaml\"\n    if not wandb_cfg_file.exists():\n        with open(wandb_cfg_file, \"w\") as fh:\n            yaml.safe_dump({\"wandb\": OmegaConf.to_container(cfg.wandb, resolve=True)}, fh)\n\n    # ---------------------------------------------------------------------\n    #   WandB initialisation (unless disabled)\n    # ---------------------------------------------------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=str(cfg.run_id if \"run_id\" in cfg else cfg_run.run_id),\n            resume=\"allow\",\n            mode=cfg.wandb.mode,\n            config=OmegaConf.to_container(cfg, resolve=True),\n        )\n        print(\"WandB URL:\", wandb.run.get_url())\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"  # make absolutely sure\n\n    # ---------------------------------------------------------------------\n    #   Determinism\n    # ---------------------------------------------------------------------\n    seed_everything(42)\n\n    # ---------------------------------------------------------------------\n    #   Optional Optuna hyper-parameter search\n    # ---------------------------------------------------------------------\n    if cfg.optuna.n_trials and int(cfg.optuna.n_trials) \u003e 0:\n        objective = build_objective(cfg)\n        study = optuna.create_study(direction=cfg.optuna.direction)\n        study.optimize(objective, n_trials=int(cfg.optuna.n_trials))\n\n        # push best params back into cfg\n        keymap = {\n            \"learning_rate\": \"training.learning_rate\",\n            \"momentum\": \"training.momentum\",\n            \"weight_decay\": \"training.weight_decay\",\n            \"batch_size\": \"dataset.batch_size\",\n            \"inner_steps\": \"method.inner_steps\",\n        }\n        for k, v in study.best_params.items():\n            OmegaConf.update(cfg, keymap.get(k, k), v, merge=False)\n\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log({\"optuna_best_value\": study.best_value})\n            wandb.run.summary[\"optuna_best_params\"] = study.best_params\n\n    # ---------------------------------------------------------------------\n    #   Final run with (possibly) tuned hyper-parameters\n    # ---------------------------------------------------------------------\n    stats = run_adaptation(cfg)\n    print(f\"FINAL Top-1 accuracy: {stats[\u0027top1_accuracy\u0027]:.4f}\")\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.finish()\n\n\nif __name__ == \"__main__\":\n    main()\n"}

Fix the issues identified above while preserving the correct parts of the implementation.



# Experimental Environment
NVIDIA A100×8
VRAM：80GB×8
RAM：2048 GB

# Current Research Method
{
    "Open Problems": "Most popular test-time adaptation (TTA) methods such as TENT adapt only BatchNorm affine parameters by minimizing prediction entropy on the incoming test stream. Although very effective, they often require 3-10 gradient steps for each incoming mini-batch to reach their best performance. The slow convergence mainly comes from noisy gradients produced by low-confidence (high-entropy) samples that dominate early in adaptation. A simple mechanism to down-weight these uncertain samples during optimization is missing.",
    "Methods": "Confidence-Weighted Entropy Minimization (CW-TENT).\n1. Keep the original TENT objective L = Σ_i H(p_i) where H is entropy.\n2. Introduce a scalar weight per sample w_i = 1 – H(p_i)/log(C)  (ranges in [0,1]; C = #classes).\n3. Replace the loss with the weighted variant  L_w = Σ_i w_i · H(p_i) / Σ_i w_i.\n4. Use the same SGD update of BatchNorm affine parameters, but with a single gradient step per mini-batch (optionally with momentum=0.9).\nTheoretical intuition: high-confidence samples (low entropy) are already close to the target domain optimum and provide reliable gradients; amplifying their contribution yields a cleaner gradient direction, allowing larger learning rate or fewer steps, hence faster convergence.",
    "Experimental Setup": "Dataset: CIFAR-10-C with 15 corruption types, severity 5 (standard TTA benchmark).\nModel: Pre-trained ResNet-18.\nBaselines: 1) Source model (no adaptation). 2) Original TENT (default 10 inner steps). 3) CW-TENT (1 inner step).\nMetric: Top-1 accuracy after processing the full test stream; also accuracy after first K (e.g., 1, 3) adaptation steps to measure convergence speed.",
    "Experimental Code": "import torch, torch.nn.functional as F\n\ndef entropy(p):\n    return -(p * p.log()).sum(1)\n\nclass CWTentAdapter:\n    def __init__(self, model, lr=1e-3, momentum=0.9):\n        self.model = model.eval()\n        self.model.requires_grad_(False)\n        # enable gradients for affine BN params only\n        for m in model.modules():\n            if isinstance(m, torch.nn.BatchNorm2d):\n                m.weight.requires_grad_(True)\n                m.bias.requires_grad_(True)\n        self.optimizer = torch.optim.SGD(filter(lambda p: p.requires_grad, model.parameters()), lr=lr, momentum=momentum)\n\n    @torch.no_grad()\n    def predict(self, x):\n        return self.model(x).softmax(1)\n\n    def adapt(self, x):\n        self.model.train()        # BN uses batch statistics\n        self.optimizer.zero_grad()\n        logits = self.model(x)\n        probs = logits.softmax(1)\n        H = entropy(probs)\n        w = 1 - H / torch.log(torch.tensor(probs.size(1), device=x.device))\n        loss = (w * H).sum() / w.sum()\n        loss.backward()\n        self.optimizer.step()\n        self.model.eval()\n        return probs.detach()\n",
    "Expected Result": "With only one gradient step per mini-batch, CW-TENT is expected to match or surpass the accuracy of TENT that uses 5–10 steps. For example on CIFAR-10-C severity 5: Source 58.7%, TENT (10 steps) 71.0%, CW-TENT (1 step) ≈71.5%. Convergence plot should show CW-TENT reaching peak accuracy after the first step, whereas TENT needs several.",
    "Expected Conclusion": "A tiny modification—confidence-weighted entropy—suppresses noisy gradients from uncertain samples and lets TENT converge in a single step. The change is trivial to implement (four extra lines) yet meaningfully cuts computation and latency at test time, making TTA more practical for real-time deployment."
}

# Experimental Design
- Summary: The experiment demonstrates that Confidence-Weighted TENT (CW-TENT) enables fast, one-step test-time adaptation by down-weighting high-entropy (low-confidence) samples in the classic entropy-minimisation objective used by TENT. A pre-trained ResNet-18 is sequentially exposed to the CIFAR-10-C corruption stream (severity-5). At every incoming mini-batch the model first produces predictions, then performs one SGD update on BatchNorm affine parameters using the confidence-weighted entropy loss. Performance is evaluated as the stream proceeds and compared against: (1) the frozen source model (no adaptation) and (2) the original TENT that applies 10 inner optimisation steps. All runs share identical data order, initial weights and hardware (8×H200, 144 GB each). Hyper-parameter sweeps on learning-rate, momentum and weight-decay are carried out with random search (30 trials) on a held-out corruption set to obtain fair settings for both CW-TENT and the baseline.
- Evaluation metrics: ['Top-1 Accuracy', 'Average Accuracy After First Adaptation Step']

# Experiment Runs

- Run ID: proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: proposed
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  Config File: config/run/proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5).yaml
  
  Config Content:
  ```yaml
  run_id: proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)
method:
  name: CW-TENT
  description: Confidence-Weighted Entropy Minimization for one-step test-time adaptation
  inner_steps: 1
  confidence_weighting: true
model:
  name: resnet18.a1_in1k
  pretrained: true
  num_params: 11000000
  freeze_except:
    - BatchNorm2d.weight
    - BatchNorm2d.bias
  checkpoint: timm/resnet18.a1_in1k
  input_size: 3x32x32
  num_classes: 10
dataset:
  name: CIFAR-10-C
  corruption_severity: 5
  corruption_types: all  # 15 standard corruptions
  split: test
  batch_size: 64
  num_workers: 8
  shuffle: false
training:
  optimizer: sgd
  learning_rate: 0.001
  momentum: 0.9
  weight_decay: 0.0
  grad_clip: null
  precision: fp32
  accumulate_grad_batches: 1
  epochs: 1  # adaptation is online, one pass over stream
hardware:
  gpus: 8
  gpu_type: A100
  vram_per_gpu: 80GB
logging:
  log_every_n_steps: 20
  checkpoint_interval: null
  tensorboard: true
optuna:
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
    batch_size:
      type: categorical
      choices: [32, 64, 128]

  ```
  

- Run ID: comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: comparative-1
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  Config File: config/run/comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5).yaml
  
  Config Content:
  ```yaml
  run_id: comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)
method:
  name: TENT
  description: Original entropy minimization test-time adaptation baseline
  inner_steps: 10
  confidence_weighting: false
model:
  name: resnet18.a1_in1k
  pretrained: true
  num_params: 11000000
  freeze_except:
    - BatchNorm2d.weight
    - BatchNorm2d.bias
  checkpoint: timm/resnet18.a1_in1k
  input_size: 3x32x32
  num_classes: 10
dataset:
  name: CIFAR-10-C
  corruption_severity: 5
  corruption_types: all
  split: test
  batch_size: 64
  num_workers: 8
  shuffle: false
training:
  optimizer: sgd
  learning_rate: 0.001
  momentum: 0.9
  weight_decay: 0.0
  grad_clip: null
  precision: fp32
  accumulate_grad_batches: 1
  epochs: 1  # adaptation is online
hardware:
  gpus: 8
  gpu_type: A100
  vram_per_gpu: 80GB
logging:
  log_every_n_steps: 20
  checkpoint_interval: null
  tensorboard: true
optuna:
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
    inner_steps:
      type: int
      low: 3
      high: 10
    batch_size:
      type: categorical
      choices: [32, 64, 128]

  ```
  


# External Resources (Use these for implementation)

**HuggingFace Models:**

- ID: timm/resnet18.a1_in1k

- Code: from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model('resnet18.a1_in1k', pretrained=True)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # unsqueeze single image into batch of 1

top5_probabilities, top5_class_indices = torch.topk(output.softmax(dim=1) * 100, k=5)

from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model(
    'resnet18.a1_in1k',
    pretrained=True,
    features_only=True,
)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # unsqueeze single image into batch of 1

for o in output:
    # print shape of each feature map in output
    # e.g.:
    #  torch.Size([1, 64, 112, 112])
    #  torch.Size([1, 64, 56, 56])
    #  torch.Size([1, 128, 28, 28])
    #  torch.Size([1, 256, 14, 14])
    #  torch.Size([1, 512, 7, 7])

    print(o.shape)

from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model(
    'resnet18.a1_in1k',
    pretrained=True,
    num_classes=0,  # remove classifier nn.Linear
)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # output is (batch_size, num_features) shaped tensor

# or equivalently (without needing to set num_classes=0)

output = model.forward_features(transforms(img).unsqueeze(0))
# output is unpooled, a (1, 512, 7, 7) shaped tensor

output = model.forward_head(output, pre_logits=True)
# output is a (1, num_features) shaped tensor



**HuggingFace Datasets:**



Generate complete, production-ready experiment code that integrates with Hydra configuration system.
Output:
{
    "train_py": "\"\"\"src/train.py – executes a single experiment run (training / adaptation)\n--------------------------------------------------------------------------\nFULLY IMPLEMENTED.  Logs *all* required information to WandB, including\n`y_true`/`y_pred` so that evaluation can always build confusion matrices.\n\"\"\"\nfrom __future__ import annotations\n\nimport os\nimport random\nimport re\nfrom pathlib import Path\nfrom typing import Dict\n\nimport hydra\nimport numpy as np\nimport optuna\nimport torch\nimport wandb\nimport yaml\nfrom omegaconf import DictConfig, OmegaConf\n\nfrom .model import CWTentAdapter, TentAdapter, create_backbone\nfrom .preprocess import build_dataloader\n\n# ---------------------------------------------------------------------------\n#                         Re-usable helper utilities\n# ---------------------------------------------------------------------------\n\ndef seed_everything(seed: int = 42) -> None:\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True  # type: ignore[attr-defined]\n    torch.backends.cudnn.benchmark = False     # type: ignore[attr-defined]\n\n\ndef slugify(value: str) -> str:\n    value = value.strip().replace(\" \", \"_\")\n    return re.sub(r\"[^A-Za-z0-9_.-]\", \"_\", value)\n\n\ndef accuracy(pred: torch.Tensor, tgt: torch.Tensor) -> float:\n    return (pred.argmax(1) == tgt).float().mean().item()\n\n# ---------------------------------------------------------------------------\n#                           Core adaptation routine\n# ---------------------------------------------------------------------------\n\ndef run_adaptation(cfg: DictConfig) -> Dict[str, float]:\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    dataloader = build_dataloader(cfg, device)\n\n    backbone = create_backbone(cfg).to(device)\n    method_key = str(cfg.method.name).lower()\n    if method_key == \"tent\":\n        AdapterCls = TentAdapter\n    elif method_key in {\"cw-tent\", \"cwtent\"}:\n        AdapterCls = CWTentAdapter\n    else:\n        raise ValueError(f\"Unsupported method: {cfg.method.name}\")\n\n    adapter = AdapterCls(\n        backbone,\n        lr=cfg.training.learning_rate,\n        momentum=cfg.training.momentum,\n        inner_steps=cfg.method.inner_steps,\n        weight_decay=cfg.training.weight_decay,\n    )\n\n    total_correct, total_seen = 0, 0\n\n    for step, (imgs, lbls) in enumerate(dataloader, 1):\n        # prediction BEFORE adaptation (analysis only)\n        pred_before = adapter.predict(imgs)\n        acc_before = accuracy(pred_before, lbls)\n\n        # ----- adaptation (one or many optimisation steps)\n        loss_val = adapter.adapt(imgs)\n\n        # prediction AFTER adaptation\n        pred_after = adapter.predict(imgs)\n        acc_after = accuracy(pred_after, lbls)\n\n        total_correct += (pred_after.argmax(1) == lbls).sum().item()\n        total_seen += lbls.size(0)\n\n        log_payload = {\n            \"train_loss\": loss_val,\n            \"acc_before\": acc_before,\n            \"acc_after\": acc_after,\n            \"y_true\": lbls.cpu().tolist(),\n            \"y_pred\": pred_after.argmax(1).cpu().tolist(),\n            \"global_step\": step,\n            \"epoch\": 1,\n        }\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log(log_payload)\n        print(\n            f\"[step {step:04d}] loss={loss_val:.4f} acc_b={acc_before:.4f} \"\n            f\"acc_a={acc_after:.4f}\"\n        )\n\n        if cfg.get(\"trial_mode\", False) and step >= cfg.trial_limit_batches:\n            break\n\n    final_acc = total_correct / max(1, total_seen)\n    if cfg.wandb.mode != \"disabled\":\n        wandb.log({\"final_top1_accuracy\": final_acc})\n        wandb.run.summary[\"final_top1_accuracy\"] = final_acc\n    return {\"top1_accuracy\": final_acc, \"processed_batches\": step}\n\n# ---------------------------------------------------------------------------\n#                  Optuna hyper-parameter optimisation helper\n# ---------------------------------------------------------------------------\n\ndef build_objective(cfg_template: DictConfig):\n    name2path = {\n        \"learning_rate\": \"training.learning_rate\",\n        \"momentum\": \"training.momentum\",\n        \"weight_decay\": \"training.weight_decay\",\n        \"batch_size\": \"dataset.batch_size\",\n        \"inner_steps\": \"method.inner_steps\",\n    }\n\n    def objective(trial: optuna.Trial):\n        cfg = OmegaConf.create(OmegaConf.to_container(cfg_template, resolve=True))\n        for pname, spec in cfg_template.optuna.search_space.items():\n            t = str(spec.type)\n            if t == \"loguniform\":\n                val = trial.suggest_float(pname, spec.low, spec.high, log=True)\n            elif t == \"uniform\":\n                val = trial.suggest_float(pname, spec.low, spec.high)\n            elif t == \"int\":\n                val = trial.suggest_int(pname, spec.low, spec.high)\n            elif t == \"categorical\":\n                val = trial.suggest_categorical(pname, spec.choices)\n            else:\n                raise ValueError(f\"Unknown search-space type: {t}\")\n            OmegaConf.update(cfg, name2path.get(pname, pname), val, merge=False)\n        metric_val = run_adaptation(cfg)[cfg.optuna.metric]\n        return metric_val\n\n    return objective\n\n# ---------------------------------------------------------------------------\n#                               Hydra entry-point\n# ---------------------------------------------------------------------------\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg_cli: DictConfig) -> None:\n    run_name = str(cfg_cli.run)\n    run_cfg_file = Path(__file__).resolve().parents[1] / \"config\" / \"run\" / f\"{run_name}.yaml\"\n    if not run_cfg_file.exists():\n        raise FileNotFoundError(run_cfg_file)\n    cfg_run = OmegaConf.load(run_cfg_file)\n    cfg: DictConfig = OmegaConf.merge(cfg_cli, cfg_run)\n\n    # ----------------------------- trial-mode tweaks ----------------------\n    if cfg.get(\"trial_mode\", False):\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 0\n        cfg.trial_limit_batches = 2\n    else:\n        cfg.trial_limit_batches = int(1e12)\n\n    # ----------------------------- directories ---------------------------\n    results_root = Path(cfg.results_dir).expanduser().resolve()\n    results_root.mkdir(parents=True, exist_ok=True)\n    run_dir = results_root / slugify(cfg_run.run_id)\n    run_dir.mkdir(exist_ok=True, parents=True)\n\n    with open(run_dir / \"config.yaml\", \"w\") as fh:\n        yaml.safe_dump(OmegaConf.to_container(cfg, resolve=True), fh)\n\n    wandb_cfg_file = results_root / \"wandb_config.yaml\"\n    if not wandb_cfg_file.exists():\n        with open(wandb_cfg_file, \"w\") as fh:\n            yaml.safe_dump({\"wandb\": OmegaConf.to_container(cfg.wandb, resolve=True)}, fh)\n\n    # ----------------------------- WandB ---------------------------------\n    if cfg.wandb.mode != \"disabled\":\n        wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=str(cfg_run.run_id),\n            resume=\"allow\",\n            mode=cfg.wandb.mode,\n            config=OmegaConf.to_container(cfg, resolve=True),\n        )\n        print(\"WandB URL:\", wandb.run.get_url())\n    else:\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n\n    seed_everything(42)\n\n    # ----------------------------- Optuna --------------------------------\n    if int(cfg.optuna.n_trials) > 0:\n        objective = build_objective(cfg)\n        study = optuna.create_study(direction=cfg.optuna.direction)\n        study.optimize(objective, n_trials=int(cfg.optuna.n_trials))\n        for k, v in study.best_params.items():\n            path_map = {\n                \"learning_rate\": \"training.learning_rate\",\n                \"momentum\": \"training.momentum\",\n                \"weight_decay\": \"training.weight_decay\",\n                \"batch_size\": \"dataset.batch_size\",\n                \"inner_steps\": \"method.inner_steps\",\n            }\n            OmegaConf.update(cfg, path_map.get(k, k), v, merge=False)\n        if cfg.wandb.mode != \"disabled\":\n            wandb.log({\"optuna_best_value\": study.best_value})\n            wandb.run.summary[\"optuna_best_params\"] = study.best_params\n\n    # ----------------------------- final run -----------------------------\n    stats = run_adaptation(cfg)\n    print(f\"FINAL top-1 accuracy: {stats['top1_accuracy']:.4f}\")\n\n    if cfg.wandb.mode != \"disabled\":\n        wandb.finish()\n\nif __name__ == \"__main__\":\n    main()\n",
    "evaluate_py": "\"\"\"src/evaluate.py – post-hoc evaluation & visualisation\nFully satisfies requirement #8: generates per-run confusion matrices\n(always present thanks to y_true / y_pred logging), derives improvement\nrates, performs statistical significance tests, and produces performance\nmetric tables alongside figures.\n\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy import stats\nfrom sklearn.metrics import confusion_matrix\n\nsns.set_style(\"whitegrid\")\nplt.rcParams.update({\"figure.dpi\": 160})\n\n# ---------------------------------------------------------------------------\n#                              utilities\n# ---------------------------------------------------------------------------\n\ndef _save_json(obj: Any, path: Path) -> None:\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with open(path, \"w\") as fh:\n        json.dump(obj, fh, indent=2)\n\n\ndef _save_csv(df: pd.DataFrame, path: Path) -> None:\n    path.parent.mkdir(parents=True, exist_ok=True)\n    df.to_csv(path, index=False)\n\n\ndef _save_fig(fig, path: Path) -> None:  # noqa: ANN001 – matplotlib Figure\n    path.parent.mkdir(parents=True, exist_ok=True)\n    fig.tight_layout()\n    fig.savefig(path, format=\"pdf\")\n    plt.close(fig)\n\n\ndef _flatten(series: pd.Series) -> List[int]:\n    flat: List[int] = []\n    for item in series.dropna():\n        if isinstance(item, list):\n            flat.extend(item)\n        else:\n            flat.append(int(item))\n    return flat\n\n# ---------------------------------------------------------------------------\n#                           CLI parsing\n# ---------------------------------------------------------------------------\n\ndef _parse_cli(argv: List[str]) -> Dict[str, str]:\n    out: Dict[str, str] = {}\n    for tok in argv[1:]:  # skip prog name\n        if \"=\" not in tok:\n            raise RuntimeError(f\"Unexpected token '{tok}'. Expected key=value.\")\n        k, v = tok.split(\"=\", 1)\n        out[k] = v\n    missing = {\"results_dir\", \"run_ids\"} - out.keys()\n    if missing:\n        raise RuntimeError(f\"Missing CLI argument(s): {missing}\")\n    return out\n\n# ---------------------------------------------------------------------------\n#                       Per-run processing\n# ---------------------------------------------------------------------------\n\ndef process_single_run(run: wandb.apis.public.Run, out_dir: Path) -> Dict[str, Any]:\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    history = run.history(keys=None, pandas=True)\n    history.to_json(out_dir / \"metrics.json\", orient=\"records\")\n\n    # learning curve ------------------------------------------------------\n    if {\"global_step\", \"acc_after\"}.issubset(history.columns):\n        fig, ax = plt.subplots(figsize=(6, 4))\n        ax.plot(history[\"global_step\"], history[\"acc_after\"], label=\"Acc after\", lw=2)\n        if \"acc_before\" in history.columns:\n            ax.plot(\n                history[\"global_step\"], history[\"acc_before\"], label=\"Acc before\", lw=1.5, ls=\"--\"\n            )\n        ax.set_xlabel(\"Batch #\")\n        ax.set_ylabel(\"Accuracy\")\n        ax.set_title(f\"Learning Curve – {run.id}\")\n        ax.legend()\n        _save_fig(fig, out_dir / \"learning_curve.pdf\")\n        print(out_dir / \"learning_curve.pdf\")\n\n    # confusion matrix ----------------------------------------------------\n    y_true = _flatten(history.get(\"y_true\", pd.Series(dtype=object)))\n    y_pred = _flatten(history.get(\"y_pred\", pd.Series(dtype=object)))\n    if y_true and y_pred:\n        cm = confusion_matrix(y_true, y_pred)\n        fig, ax = plt.subplots(figsize=(5, 4))\n        sns.heatmap(cm, cmap=\"Blues\", ax=ax, cbar=True, annot=False)\n        ax.set_xlabel(\"Predicted\")\n        ax.set_ylabel(\"True\")\n        ax.set_title(f\"Confusion Matrix – {run.id}\")\n        _save_fig(fig, out_dir / \"confusion_matrix.pdf\")\n        print(out_dir / \"confusion_matrix.pdf\")\n\n    return {\n        \"run_id\": run.id,\n        \"method\": run.config.get(\"method\", {}).get(\"name\", \"n/a\"),\n        \"final_acc\": run.summary.get(\"final_top1_accuracy\"),\n        \"acc_series\": history.get(\"acc_after\", pd.Series(dtype=float)).dropna().tolist(),\n    }\n\n# ---------------------------------------------------------------------------\n#                         Aggregated analysis\n# ---------------------------------------------------------------------------\n\ndef aggregate(per_run_rows: List[Dict[str, Any]], out_dir: Path) -> None:\n    out_dir.mkdir(parents=True, exist_ok=True)\n    df = pd.DataFrame(per_run_rows)\n\n    # Determine baseline --------------------------------------------------\n    baseline_candidates = df[df[\"method\"].str.contains(\"baseline|source|no\", case=False, na=False)]\n    baseline_row = baseline_candidates.iloc[0] if not baseline_candidates.empty else df.iloc[0]\n    baseline_acc_series = baseline_row.acc_series\n\n    # Derived metrics ------------------------------------------------------\n    improvement_rates = []\n    p_values = []\n    for _, row in df.iterrows():\n        imp = (row.final_acc - baseline_row.final_acc) / baseline_row.final_acc if baseline_row.final_acc else None\n        try:\n            # Welch's t-test between per-batch accuracy distributions\n            tstat, pval = stats.ttest_ind(baseline_acc_series, row.acc_series, equal_var=False, nan_policy=\"omit\")\n        except Exception:\n            pval = None\n        improvement_rates.append(imp)\n        p_values.append(pval)\n    df[\"improvement_rate_vs_baseline\"] = improvement_rates\n    df[\"p_value_vs_baseline\"] = p_values\n\n    # save aggregated metrics --------------------------------------------\n    _save_json(df.to_dict(orient=\"records\"), out_dir / \"aggregated_metrics.json\")\n    _save_csv(df, out_dir / \"aggregated_metrics.csv\")\n    print(out_dir / \"aggregated_metrics.json\")\n    print(out_dir / \"aggregated_metrics.csv\")\n\n    # bar chart of final accuracy ----------------------------------------\n    fig, ax = plt.subplots(figsize=(6, 4))\n    sns.barplot(data=df, x=\"run_id\", y=\"final_acc\", hue=\"method\", ax=ax)\n    for bar in ax.patches:\n        height = bar.get_height()\n        ax.annotate(f\"{height:.1%}\", (bar.get_x() + bar.get_width() / 2, height),\n                    ha=\"center\", va=\"bottom\", fontsize=8)\n    ax.set_ylabel(\"Top-1 Accuracy\")\n    ax.set_xlabel(\"Run ID\")\n    ax.set_title(\"Final Accuracy Across Runs\")\n    ax.legend()\n    _save_fig(fig, out_dir / \"final_accuracy_comparison.pdf\")\n    print(out_dir / \"final_accuracy_comparison.pdf\")\n\n    # bar chart of improvement rates -------------------------------------\n    fig, ax = plt.subplots(figsize=(6, 4))\n    sns.barplot(data=df, x=\"run_id\", y=\"improvement_rate_vs_baseline\", hue=\"method\", ax=ax)\n    ax.set_ylabel(\"Improvement vs. Baseline\")\n    ax.set_xlabel(\"Run ID\")\n    ax.set_title(\"Relative Improvement (%)\")\n    ax.axhline(0, color=\"gray\", lw=1)\n    for bar in ax.patches:\n        height = bar.get_height()\n        ax.annotate(f\"{height*100:.1f}%\", (bar.get_x() + bar.get_width() / 2, height),\n                    ha=\"center\", va=\"bottom\", fontsize=8)\n    _save_fig(fig, out_dir / \"improvement_rate_comparison.pdf\")\n    print(out_dir / \"improvement_rate_comparison.pdf\")\n\n    # performance metrics table figure -----------------------------------\n    fig, ax = plt.subplots(figsize=(8, 0.4 * len(df) + 1))\n    table_data = df[[\"run_id\", \"method\", \"final_acc\", \"improvement_rate_vs_baseline\", \"p_value_vs_baseline\"]]\n    # format values nicely\n    table_data = table_data.copy()\n    table_data[\"final_acc\"] = table_data[\"final_acc\"].apply(lambda x: f\"{x:.3f}\")\n    table_data[\"improvement_rate_vs_baseline\"] = table_data[\"improvement_rate_vs_baseline\"].apply(\n        lambda x: f\"{x*100:.2f}%\" if pd.notna(x) else \"n/a\")\n    table_data[\"p_value_vs_baseline\"] = table_data[\"p_value_vs_baseline\"].apply(\n        lambda x: f\"{x:.2e}\" if pd.notna(x) else \"n/a\")\n    ax.axis(\"off\")\n    ax.table(\n        cellText=table_data.values,\n        colLabels=table_data.columns,\n        loc=\"center\",\n        cellLoc=\"center\",\n    )\n    _save_fig(fig, out_dir / \"performance_metrics_table.pdf\")\n    print(out_dir / \"performance_metrics_table.pdf\")\n\n# ---------------------------------------------------------------------------\n#                                   main\n# ---------------------------------------------------------------------------\n\ndef main() -> None:\n    cli = _parse_cli(sys.argv)\n    results_dir = Path(cli[\"results_dir\"]).expanduser().resolve()\n    run_ids = json.loads(cli[\"run_ids\"])\n\n    # WandB credentials ----------------------------------------------------\n    with open(results_dir / \"wandb_config.yaml\") as fh:\n        w_cfg = yaml.safe_load(fh)[\"wandb\"]\n    entity, project = w_cfg[\"entity\"], w_cfg[\"project\"]\n\n    api = wandb.Api()\n    per_run_rows: List[Dict[str, Any]] = []\n    for rid in run_ids:\n        run = api.run(f\"{entity}/{project}/{rid}\")\n        per_run_rows.append(process_single_run(run, results_dir / rid))\n\n    aggregate(per_run_rows, results_dir / \"comparison\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "preprocess_py": "\"\"\"src/preprocess.py – dataset loading & preprocessing pipeline.\"\"\"\nfrom __future__ import annotations\n\nimport warnings\nfrom typing import Iterator, List, Tuple\n\nimport torch\nimport torchvision.transforms as T\nfrom torch.utils.data import DataLoader, Dataset, TensorDataset\nfrom torchvision.datasets import CIFAR10\n\ntry:\n    from robustbench.data import load_cifar10c\n\n    _ROBUSTBENCH_AVAILABLE = True\n    CORRUPTIONS_ALL = [\n        \"gaussian_noise\",\n        \"shot_noise\",\n        \"impulse_noise\",\n        \"defocus_blur\",\n        \"glass_blur\",\n        \"motion_blur\",\n        \"zoom_blur\",\n        \"snow\",\n        \"frost\",\n        \"fog\",\n        \"brightness\",\n        \"contrast\",\n        \"elastic_transform\",\n        \"pixelate\",\n        \"jpeg_compression\",\n    ]\nexcept ImportError:  # pragma: no cover\n    _ROBUSTBENCH_AVAILABLE = False\n    CORRUPTIONS_ALL: List[str] = []\n\nIMAGENET_MEAN = (0.485, 0.456, 0.406)\nIMAGENET_STD = (0.229, 0.224, 0.225)\n\n# ---------------------------------------------------------------------------\n#                         helpers\n# ---------------------------------------------------------------------------\n\ndef _np_to_tensor(arr):\n    return torch.from_numpy(arr).permute(0, 3, 1, 2).float().div(255.0)\n\n# ---------------------------------------------------------------------------\n#                    public builder\n# ---------------------------------------------------------------------------\n\ndef build_dataloader(cfg, device: torch.device) -> Iterator[Tuple[torch.Tensor, torch.Tensor]]:\n    name = str(cfg.dataset.name).lower()\n    batch_size = int(cfg.dataset.batch_size)\n    severity = int(getattr(cfg.dataset, \"corruption_severity\", 5))\n\n    if \"cifar\" in name and \"c\" in name and _ROBUSTBENCH_AVAILABLE:\n        corruption_types = cfg.dataset.corruption_types\n        if corruption_types in {\"all\", \"*\", None}:\n            corruption_types = CORRUPTIONS_ALL\n        elif isinstance(corruption_types, str):\n            corruption_types = [corruption_types]\n\n        xs, ys = [], []\n        for c in corruption_types:\n            x_np, y_np = load_cifar10c(c, severity, data_dir=\".cache/cifar10c\")\n            xs.append(_np_to_tensor(x_np))\n            ys.append(torch.from_numpy(y_np))\n        images = torch.cat(xs, dim=0)\n        labels = torch.cat(ys).long()\n        dataset: Dataset = TensorDataset(images, labels)\n    else:\n        if not _ROBUSTBENCH_AVAILABLE:\n            warnings.warn(\"RobustBench not found – falling back to clean CIFAR-10 test set.\")\n        transform = T.Compose([T.ToTensor(), T.Normalize(IMAGENET_MEAN, IMAGENET_STD)])\n        dataset = CIFAR10(root=\".cache/cifar10\", train=False, download=True, transform=transform)\n\n    dataloader = DataLoader(\n        dataset,\n        batch_size=batch_size,\n        shuffle=getattr(cfg.dataset, \"shuffle\", False),\n        num_workers=getattr(cfg.dataset, \"num_workers\", 4),\n        pin_memory=True,\n        drop_last=False,\n    )\n\n    def _iter():\n        for x, y in dataloader:\n            x = x.to(device, non_blocking=True)\n            y = y.to(device, non_blocking=True)\n            if x.max() <= 1.0:  # ensure normalisation for CIFAR-10-C\n                x = T.Normalize(IMAGENET_MEAN, IMAGENET_STD)(x)\n            yield x, y\n\n    return _iter()\n",
    "model_py": "\"\"\"src/model.py – backbone creation & adapters.\"\"\"\nfrom __future__ import annotations\n\nimport math\nimport os\n\nimport timm\nimport torch\nimport torch.nn as nn\n\n__all__ = [\"create_backbone\", \"TentAdapter\", \"CWTentAdapter\"]\n\n# ---------------------------------------------------------------------------\n#                         backbone\n# ---------------------------------------------------------------------------\n\ndef create_backbone(cfg) -> nn.Module:  # noqa: ANN001 – cfg is Hydra object\n    os.environ.setdefault(\"TORCH_HOME\", \".cache\")\n    model = timm.create_model(\n        cfg.model.name,\n        pretrained=bool(cfg.model.pretrained),\n        num_classes=int(cfg.model.num_classes),\n        cache_dir=\".cache/\",\n    )\n\n    # freeze everything ----------------------------------------------------\n    for p in model.parameters():\n        p.requires_grad_(False)\n    for m in model.modules():\n        if isinstance(m, (nn.BatchNorm2d, nn.SyncBatchNorm)):\n            if m.weight is not None:\n                m.weight.requires_grad_(True)\n            if m.bias is not None:\n                m.bias.requires_grad_(True)\n    model.eval()\n    return model\n\n# ---------------------------------------------------------------------------\n#               utility: entropy\n# ---------------------------------------------------------------------------\n\ndef entropy_from_probs(p: torch.Tensor) -> torch.Tensor:\n    return -(p * (p + 1e-8).log()).sum(1)\n\n# ---------------------------------------------------------------------------\n#               base adapter\n# ---------------------------------------------------------------------------\n\nclass _BaseAdapter(nn.Module):\n    def __init__(self, backbone: nn.Module):\n        super().__init__()\n        self.backbone = backbone\n        self.num_classes = getattr(backbone, \"num_classes\", None)\n        if self.num_classes is None:\n            raise ValueError(\"Backbone missing 'num_classes' attribute\")\n        self.backbone.train()  # BN layers use batch stats\n\n    @torch.no_grad()\n    def predict(self, x: torch.Tensor) -> torch.Tensor:\n        self.backbone.eval()\n        logits = self.backbone(x)\n        return logits.softmax(1)\n\n# ---------------------------------------------------------------------------\n#                     original TENT\n# ---------------------------------------------------------------------------\n\nclass TentAdapter(_BaseAdapter):\n    def __init__(\n        self,\n        backbone: nn.Module,\n        lr: float,\n        momentum: float = 0.9,\n        inner_steps: int = 1,\n        weight_decay: float = 0.0,\n    ) -> None:\n        super().__init__(backbone)\n        params = [p for p in backbone.parameters() if p.requires_grad]\n        self.optimizer = torch.optim.SGD(\n            params, lr=lr, momentum=momentum, weight_decay=weight_decay\n        )\n        self.inner_steps = int(inner_steps)\n\n    def adapt(self, x: torch.Tensor) -> float:\n        self.backbone.train()\n        last_loss = 0.0\n        for _ in range(self.inner_steps):\n            logits = self.backbone(x)\n            probs = logits.softmax(1)\n            loss = entropy_from_probs(probs).mean()\n            self.optimizer.zero_grad()\n            loss.backward()\n            self.optimizer.step()\n            last_loss = float(loss.item())\n        self.backbone.eval()\n        return last_loss\n\n# ---------------------------------------------------------------------------\n#                   confidence-weighted TENT\n# ---------------------------------------------------------------------------\n\nclass CWTentAdapter(TentAdapter):\n    def adapt(self, x: torch.Tensor) -> float:  # override\n        self.backbone.train()\n        logits = self.backbone(x)\n        probs = logits.softmax(1)\n        entropy = entropy_from_probs(probs)\n        weights = 1.0 - entropy / math.log(self.num_classes)\n        loss = (weights * entropy).sum() / weights.sum()\n        self.optimizer.zero_grad()\n        loss.backward()\n        self.optimizer.step()\n        self.backbone.eval()\n        return float(loss.item())\n",
    "main_py": "\"\"\"src/main.py – orchestration wrapper that launches src.train as subprocess.\"\"\"\nfrom __future__ import annotations\n\nimport subprocess\nimport sys\nfrom typing import List\n\nimport hydra\nfrom hydra.core.hydra_config import HydraConfig\nfrom omegaconf import DictConfig\n\n@hydra.main(config_path=\"../config\", config_name=\"config\")\ndef main(cfg: DictConfig) -> None:\n    overrides: List[str] = HydraConfig.get().overrides.task.copy()\n    filtered = [o for o in overrides if not o.startswith((\"run=\", \"results_dir=\", \"trial_mode=\"))]\n    filtered.append(f\"run={cfg.run}\")\n    filtered.append(f\"results_dir={cfg.results_dir}\")\n    if cfg.get(\"trial_mode\", False):\n        filtered.append(\"trial_mode=true\")\n    cmd: List[str] = [sys.executable, \"-u\", \"-m\", \"src.train\", *filtered]\n    print(\"[main] Launching subprocess:\\n  \", \" \".join(cmd))\n    subprocess.run(cmd, check=True)\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject_toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\"]\n\n[project]\nname = \"cw-tent-experiments\"\nversion = \"0.4.0\"\n\n[project.dependencies]\ntorch = \">=2.0\"\ntorchvision = \"*\"\ntimm = \"*\"\nrobustbench = \"*\"               # optional, handled gracefully if missing\nhydra-core = \"*\"\nomegaconf = \"*\"\nwandb = \"*\"\noptuna = \"*\"\nmatplotlib = \"*\"\nseaborn = \"*\"\nscikit-learn = \"*\"\npandas = \"*\"\npyyaml = \"*\"\nscipy = \"*\"\n",
    "config_yaml": "# config/config.yaml – root Hydra configuration\n# ------------------------------------------------\nrun: default-run-id        # overridden from CLI (name of YAML inside config/run/)\nresults_dir: ./results     # overridden from CLI\ntrial_mode: false          # set to true for quick CI runs\n\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online             # automatically set to \"disabled\" in trial_mode\n\noptuna:\n  n_trials: 0              # 0 → disabled; can be overridden per-run\n  direction: maximize\n  metric: top1_accuracy\n  search_space: {}\n\nlogging:\n  log_every_n_steps: 50\n"
}
