
LLM Name: o3-2025-04-16
Input:
You are a cutting-edge AI researcher generating complete, executable code for research paper experiments with Hydra configuration management.

Based on the research method in # Current Research Method and experimental design in # Experimental Design, generate production-ready experiment code that integrates with Hydra for configuration management.

# Instructions: Complete Experiment Code Generation

## Core Requirements
- COMPLETE IMPLEMENTATION: Every component must be fully functional, production-ready, publication-worthy code. No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
- PYTORCH EXCLUSIVELY: Use PyTorch as the deep learning framework
- HYDRA INTEGRATION: Use Hydra to manage all experiment configurations from `config/run/*.yaml` files. Use `config_path="../config"` in all @hydra.main decorators
- COMPLETE DATA PIPELINE: Full data loading and preprocessing implementation. Use `.cache/` as the cache directory for all datasets and models (e.g., for HuggingFace, set `cache_dir=".cache/"`)
- WANDB REQUIRED: WandB is mandatory for metrics logging (except trial_mode validation)

## Hydra Configuration Structure
Each run config file (`config/run/{run_id}.yaml`) contains:
- run_id: Unique identifier for this run
- method: The method name (baseline, proposed, ablation, etc.)
- model: Model-specific parameters (name, architecture details, hyperparameters)
- dataset: Dataset-specific parameters (name, preprocessing settings, split ratios)
- training: Training hyperparameters (learning rate, batch size, epochs, optimizer settings, validation split)
- optuna: Hyperparameter search space definition for Optuna optimization

## Command Line Interface
The generated code must support the following CLI:

**Training (main.py):**
```bash
# Full experiment with WandB logging
uv run python -u -m src.main run={run_id} results_dir={path}

# Trial mode (validation only, WandB disabled)
uv run python -u -m src.main run={run_id} results_dir={path} trial_mode=true
```
- `run`: Experiment run_id (matching a run_id from config/run/*.yaml)
- `results_dir`: Output directory (passed from GitHub Actions workflow)
- `trial_mode=true` (optional): Lightweight execution for validation (epochs=1, batches limited to 1-2, disable Optuna n_trials=0, **WandB disabled**)

**Evaluation (evaluate.py, independent execution):**
```bash
uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'
```
- `results_dir`: Directory containing experiment metadata and where outputs will be saved
- `run_ids`: JSON string list of run IDs to evaluate (e.g., '["run-1-proposed-bert-glue", "run-2-baseline-bert-glue"]')
- Executed as a separate workflow after all training runs complete
- **NOT called from main.py**

## Script Structure (ExperimentCode format)
Generate complete code for these files ONLY. Do not create any additional files beyond this structure:

**`src/train.py`**: Single experiment run executor
- Uses Hydra config to load all parameters
- Called as subprocess by main.py
- Responsibilities:
  * Train model with given configuration
  * Initialize WandB: `wandb.init(entity=cfg.wandb.entity, project=cfg.wandb.project, id=cfg.run.run_id, config=OmegaConf.to_container(cfg, resolve=True), resume="allow")`
  * Skip `wandb.init()` if `cfg.wandb.mode == "disabled"` (trial_mode)
  * Log ALL metrics to WandB: `wandb.log({"train_loss": 0.5, "val_acc": 0.85, "epoch": 1, ...})`
  * Print WandB run URL to stdout
- **NO results.json, no stdout JSON output, no figure generation**

**`src/evaluate.py`**: Independent evaluation and visualization script
- **Execution**: Run independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
- **NOT called from main.py** - executes as separate workflow after all training completes
- **Responsibilities**:
  * Parse command line arguments:
    - `results_dir`: Output directory path
    - `run_ids`: JSON string list of run IDs (parse with `json.loads(args.run_ids)`)
  * Load WandB config from `{results_dir}/config.yaml`
  * Retrieve experimental data from WandB API for specified run_ids:
    ```python
    import json
    api = wandb.Api()
    run_ids = json.loads(args.run_ids)  # Parse JSON string to list
    for run_id in run_ids:
        run = api.run(f"{entity}/{project}/{run_id}")
        metrics_df = run.history()  # pandas DataFrame with all logged metrics
    ```
  * **STEP 1: Per-Run Processing** (for each run_id):
    - Export run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
    - Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
    - Each run should have its own subdirectory with its metrics and figures
  * **STEP 2: Aggregated Analysis** (after processing all runs):
    - Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
    - Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
    - Generate comparison figures to: `{results_dir}/comparison/`:
      * Cross-run comparison charts (bar charts, box plots)
      * Performance metrics tables
      * Statistical significance tests
  * **Figure Generation Guidelines**:
    - Use matplotlib or seaborn with proper legends, annotations, tight_layout
    - For line graphs: annotate significant values (final/best values)
    - For bar graphs: annotate values above each bar
    - Follow naming convention: `<figure_topic>[_<condition>][_pairN].pdf`
  * Print all generated file paths to stdout (both per-run and comparison)

**`src/preprocess.py`**: Complete preprocessing pipeline implementation for the specified datasets

**`src/model.py`**: Complete model architecture implementations for all methods (proposed and comparative methods)

**`src/main.py`**: Main orchestrator
- Receives run_id via Hydra, launches train.py as subprocess, manages logs
- **DOES NOT call evaluate.py** (evaluate.py runs independently in separate workflow)
- Use `@hydra.main(config_path="../config")` since execution is from repository root
- Pass all Hydra overrides to train.py subprocess (e.g., `wandb.mode=disabled`, `trial_mode=true`)
- In trial_mode, automatically set `wandb.mode=disabled`

**`config/config.yaml`**: Main Hydra configuration file
- MUST include WandB configuration:
  ```yaml
  wandb:
    entity: gengaru617-personal
    project: 251020-test
    mode: online  # Automatically set to "disabled" in trial_mode
  ```

**`pyproject.toml`**: Complete project dependencies
- MUST include: `hydra-core`, `wandb` (required)
- Include as needed: `optuna`, `torch`, `transformers`, `datasets`, etc.


## Key Implementation Focus Areas
1. **Hydra-Driven Configuration**: All parameters loaded from run configs dynamically
2. **Algorithm Core**: Full implementation of the proposed method with proper abstraction
3. **Trial Mode Behavior**: trial_mode=true automatically disables WandB (sets wandb.mode=disabled)
4. **Run Execution**: main.py executes a single run_id passed via CLI (GitHub Actions dispatches multiple runs separately)
5. **WandB Integration**: All metrics logged to WandB; train.py does NOT output JSON to stdout or save results.json
6. **Independent Evaluation**: evaluate.py runs separately, fetches data from WandB API, generates all figures



## Code Validation Feedback


**Previous Validation Issue**: The code cannot be executed as-is; several critical requirements are violated:

1. Wrong config access in train.py – uses `cfg.method` but Hydra stores it under `cfg.run.method`; raises AttributeError before the first iteration.
2. Data caching requirement unmet – datasets are loaded directly from `dataset.root` and the provided `cache_dir` argument is ignored; requirement says all datasets/models must use “.cache/”.
3. Trial-mode is incomplete – it only reduces batch size/steps but still iterates over the full test stream (thousands of batches); must limit to 1–2 batches and skip Optuna entirely (Optuna not implemented at all despite enabled flag).
4. create_model() ignores `model.pretrained_checkpoint` specified in run configs; therefore model-specific configuration is not honoured.
5. Evaluation script partly violates rule 8 – it may read confusion matrix from local files instead of exclusively via WandB API.

Until these issues are fixed the experiment code is not production-ready for immediate execution.
**Action Required**: Address this issue in the implementation.

**Previous Code (for reference)**:
{"config_yaml": "# config/config.yaml\n# ~~~~~~~~~~~~~~~~~~~\n# Global Hydra configuration shared by every run-specific file in\n# ``config/run/*.yaml``.\n\ndefaults:\n  - _self_\n  # The *run* entry will be replaced at runtime via CLI override\n  - run: null\n\n# ---------------------------------------------------------------------\n# Misc global flags\n# ---------------------------------------------------------------------\ntrial_mode: false  # main.py overrides this when `trial_mode=true` is passed\nresults_dir: ./results\nseed: 42\n\n# ---------------------------------------------------------------------\n# WANDB ( over-writable via CLI / trial mode )\n# ---------------------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online\n\n# ---------------------------------------------------------------------\n# Hydra output (do NOT clutter working tree)\n# ---------------------------------------------------------------------\nhydra:\n  run:\n    dir: ./outputs/${now:%Y-%m-%d}_${now:%H-%M-%S}_${run.run_id}\n  job_logging:\n    version: 1\n    root:\n      level: INFO\n  hydra_logging:\n    version: 1\n    root:\n      level: INFO\n\n# Note: the \"run\" group is expected to be overridden from CLI\n#        e.g. `python -m src.main run=my_experiment`  will make Hydra\n#        load   config/run/my_experiment.yaml\nconfig: {}\noptuna: {}\ntraining: {}\ndataset: {}\nmodel: {}\nrun:\n  run_id: dummy\n  method: baseline\n\n# End of config.yaml\n", "evaluate_py": "# src/evaluate.py\n# (Same as provided by the previous iteration \u2013 retained verbatim)\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy import stats\n\nsns.set_style(\"whitegrid\")\n\n################################################################################\n# CLI parsing                                                                  #\n################################################################################\n\ndef _parse_kv_cli() -\u003e Dict[str, str]:\n    kv: Dict[str, str] = {}\n    for arg in sys.argv[1:]:\n        if \"=\" not in arg:\n            raise ValueError(\n                f\"Unexpected CLI token \u0027{arg}\u0027. Expected KEY=VALUE pairs only.\")\n        k, v = arg.split(\"=\", 1)\n        kv[k] = v\n    required = {\"results_dir\", \"run_ids\"}\n    missing = required - kv.keys()\n    if missing:\n        raise ValueError(f\"Missing required CLI args: {missing}\")\n    return kv\n\n################################################################################\n# Config helpers                                                               #\n################################################################################\n\ndef _load_wandb_config(results_dir: Path) -\u003e Dict:\n    cfg_file = results_dir / \"config.yaml\"\n    if not cfg_file.exists():\n        raise FileNotFoundError(\n            f\"Cannot locate global config file at {cfg_file}. Did main.py copy it?\")\n    with cfg_file.open(\"r\") as f:\n        return yaml.safe_load(f)\n\n################################################################################\n# Per-run processing                                                           #\n################################################################################\n\ndef _export_metrics(df: pd.DataFrame, out: Path) -\u003e None:\n    df.to_json(out, orient=\"records\", lines=True)\n\n\ndef _plot_learning_curves(df: pd.DataFrame, run_id: str, out_dir: Path) -\u003e List[Path]:\n    figs: List[Path] = []\n    # Select metrics that exist \u0026 are numeric ---------------------------------\n    numeric_cols = [c for c in [\"batch_accuracy\", \"top1_accuracy\"] if c in df.columns]\n    for metric in numeric_cols:\n        plt.figure(figsize=(6, 4))\n        sns.lineplot(x=df.index, y=df[metric])\n        plt.title(f\"{run_id} \u2013 {metric}\")\n        plt.xlabel(\"Step\")\n        plt.ylabel(metric)\n        # Annotate final value -------------------------------------------------\n        if not df[metric].dropna().empty:\n            final_val = df[metric].dropna().iloc[-1]\n            plt.annotate(\n                f\"{final_val:.3f}\",\n                xy=(df.index[-1], final_val),\n                xytext=(-40, 10),\n                textcoords=\"offset points\",\n                fontsize=8,\n            )\n        plt.tight_layout()\n        file = out_dir / f\"learning_curve_{metric}.pdf\"\n        plt.savefig(file)\n        plt.close()\n        figs.append(file)\n    return figs\n\n\ndef _plot_confusion_matrix(cm: np.ndarray, class_names: List[str], title: str, out: Path) -\u003e None:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(cm, annot=True, fmt=\"d\", cmap=\"Blues\", xticklabels=class_names, yticklabels=class_names)\n    plt.ylabel(\"True label\")\n    plt.xlabel(\"Predicted label\")\n    plt.title(title)\n    plt.tight_layout()\n    plt.savefig(out)\n    plt.close()\n\n\ndef per_run_processing(\n    api: wandb.Api,\n    entity: str,\n    project: str,\n    run_id: str,\n    run_dir: Path,\n    class_names: List[str],\n) -\u003e Dict:\n    run = api.run(f\"{entity}/{project}/{run_id}\")\n    hist_df = run.history(keys=[\"batch_accuracy\", \"top1_accuracy\", \"adapt_loss\"], pandas=True)\n\n    _export_metrics(hist_df, run_dir / \"metrics.json\")\n\n    fig_paths = _plot_learning_curves(hist_df, run_id, run_dir)\n\n    # Confusion matrix --------------------------------------------------------\n    cm = None\n    if \"conf_mat\" in run.summary:\n        cm = np.asarray(run.summary[\"conf_mat\"], dtype=int)\n    else:\n        local = run_dir / \"confusion_matrix.npy\"\n        if local.exists():\n            cm = np.load(local)\n    if cm is not None:\n        cm_path = run_dir / \"confusion_matrix.pdf\"\n        _plot_confusion_matrix(cm, class_names, f\"{run_id} \u2013 Confusion Matrix\", cm_path)\n        fig_paths.append(cm_path)\n\n    # Final accuracy ----------------------------------------------------------\n    if \"final_top1_accuracy\" in run.summary:\n        final_acc = float(run.summary[\"final_top1_accuracy\"])\n    elif \"top1_accuracy\" in hist_df.columns and not hist_df[\"top1_accuracy\"].dropna().empty:\n        final_acc = float(hist_df[\"top1_accuracy\"].dropna().iloc[-1])\n    else:\n        final_acc = float(\"nan\")\n\n    # Method tag (stored inside WandB config) ---------------------------------\n    method = run.config.get(\"run\", {}).get(\"method\", \"unknown\")\n\n    print(f\"[Per-run]  {run_id}: saved {len(fig_paths)} figure(s) in {run_dir.relative_to(Path.cwd())}\")\n    for p in fig_paths:\n        print(\"  \u2022\", p)\n\n    return {\n        \"run_id\": run_id,\n        \"method\": method,\n        \"final_accuracy\": final_acc,\n    }\n\n################################################################################\n# Aggregated analysis (STEP-2)                                                 #\n################################################################################\n\ndef _make_bar_plot(df: pd.DataFrame, out: Path, title: str, annotate: bool = True):\n    plt.figure(figsize=(8, 4))\n    sns.barplot(data=df, x=\"run_id\", y=\"final_accuracy\", hue=\"method\", palette=\"viridis\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylim(0, 100)\n    plt.ylabel(\"Final Top-1 Accuracy (%)\")\n    plt.xlabel(\"\")\n    plt.title(title)\n    if annotate:\n        for i, row in df.iterrows():\n            plt.text(i, row[\"final_accuracy\"] + 0.5, f\"{row[\u0027final_accuracy\u0027]:.1f}\", ha=\"center\", fontsize=8)\n    plt.tight_layout()\n    plt.savefig(out)\n    plt.close()\n\n\ndef _make_box_plot(df: pd.DataFrame, out: Path):\n    plt.figure(figsize=(6, 4))\n    sns.boxplot(data=df, x=\"method\", y=\"final_accuracy\", palette=\"Set2\")\n    sns.stripplot(data=df, x=\"method\", y=\"final_accuracy\", color=\"black\", size=4, jitter=True, dodge=True)\n    plt.ylabel(\"Final Top-1 Accuracy (%)\")\n    plt.title(\"Distribution of final accuracy per method\")\n    plt.tight_layout()\n    plt.savefig(out)\n    plt.close()\n\n\ndef _improvement_plot(method_mean: Dict[str, float], baseline: str, out: Path):\n    improv_dict = {\n        m: 100 * (acc - method_mean[baseline]) / method_mean[baseline]\n        for m, acc in method_mean.items() if m != baseline\n    }\n    plt.figure(figsize=(5, 4))\n    sns.barplot(x=list(improv_dict.keys()), y=list(improv_dict.values()), palette=\"crest\")\n    for i, (m, v) in enumerate(improv_dict.items()):\n        plt.text(i, v + 0.2, f\"{v:.2f}%\", ha=\"center\", fontsize=9)\n    plt.ylabel(\"Relative improvement (%)\")\n    plt.title(\"Improvement over baseline\")\n    plt.tight_layout()\n    plt.savefig(out)\n    plt.close()\n\n\ndef aggregated_analysis(per_run_stats: List[Dict], results_dir: Path) -\u003e None:\n    comp_dir = results_dir / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    df = pd.DataFrame(per_run_stats)\n\n    # ---------------------------------------------------------------------\n    # Method-level aggregates \u0026 derived metrics\n    # ---------------------------------------------------------------------\n    method_mean: Dict[str, float] = df.groupby(\"method\")[\"final_accuracy\"].mean().to_dict()\n\n    baseline_method = \"baseline\" if \"baseline\" in method_mean else sorted(method_mean.keys())[0]\n    improvement: Dict[str, float] = {\n        m: (acc - method_mean[baseline_method]) / method_mean[baseline_method]\n        for m, acc in method_mean.items()\n        if m != baseline_method\n    }\n\n    # Statistical significance test --------------------------------------\n    if len(df[\"method\"].unique()) \u003e= 2 and baseline_method in df[\"method\"].unique():\n        baseline_vals = df[df.method == baseline_method][\"final_accuracy\"].values\n        best_other_method = max(improvement, key=improvement.get, default=None)\n        if best_other_method is not None:\n            other_vals = df[df.method == best_other_method][\"final_accuracy\"].values\n            t_stat, p_val = stats.ttest_ind(baseline_vals, other_vals, equal_var=False)\n        else:\n            t_stat, p_val = np.nan, np.nan\n    else:\n        t_stat, p_val = np.nan, np.nan\n\n    aggregated_json = {\n        \"per_run\": per_run_stats,\n        \"method_mean\": method_mean,\n        \"baseline_method\": baseline_method,\n        \"improvement_over_baseline\": improvement,\n        \"t_test\": {\"statistic\": float(t_stat), \"pvalue\": float(p_val)},\n    }\n\n    agg_json_path = comp_dir / \"aggregated_metrics.json\"\n    with agg_json_path.open(\"w\") as f:\n        json.dump(aggregated_json, f, indent=2)\n\n    # Human-readable CSV table -------------------------------------------\n    df.to_csv(comp_dir / \"aggregated_metrics_table.csv\", index=False)\n\n    # ---------------------------------------------------------------------\n    # Comparison figures\n    # ---------------------------------------------------------------------\n    bar_path = comp_dir / \"final_accuracy_comparison.pdf\"\n    _make_bar_plot(df, bar_path, title=\"Final accuracy across runs\")\n\n    box_path = comp_dir / \"accuracy_boxplot_per_method.pdf\"\n    _make_box_plot(df, box_path)\n\n    if improvement:\n        imp_path = comp_dir / \"relative_improvement_over_baseline.pdf\"\n        _improvement_plot(method_mean, baseline_method, imp_path)\n    else:\n        imp_path = None\n\n    # ---------------------------------------------------------------------\n    # Print generated artefacts\n    # ---------------------------------------------------------------------\n    print(\"\\n[Aggregated] Generated outputs:\")\n    for p in [agg_json_path, comp_dir / \"aggregated_metrics_table.csv\", bar_path, box_path, imp_path]:\n        if p is not None:\n            print(\"  \u2022\", p)\n\n################################################################################\n# Main                                                                         #\n################################################################################\n\ndef main() -\u003e None:\n    cli = _parse_kv_cli()\n    results_dir = Path(cli[\"results_dir\"]).expanduser().resolve()\n    run_ids = json.loads(cli[\"run_ids\"])\n\n    wandb_cfg = _load_wandb_config(results_dir)\n    entity = wandb_cfg[\"wandb\"][\"entity\"]\n    project = wandb_cfg[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n    class_names = [str(i) for i in range(10)]  # CIFAR-10 labels 0\u20139\n\n    per_run_stats: List[Dict] = []\n    for rid in run_ids:\n        r_dir = results_dir / rid\n        r_dir.mkdir(parents=True, exist_ok=True)\n        stats = per_run_processing(api, entity, project, rid, r_dir, class_names)\n        per_run_stats.append(stats)\n\n    aggregated_analysis(per_run_stats, results_dir)\n\n\nif __name__ == \"__main__\":\n    main()", "main_py": "# src/main.py\n\"\"\"Main orchestrator \u2013 spawns `src.train` as a *child* python process so\nthat each experiment run is fully isolated (separate CUDA contexts, etc.).\n\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport os\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nfrom hydra.utils import to_absolute_path\nfrom omegaconf import OmegaConf\n\n\n#######################################################################\n# Helper utilities                                                    #\n#######################################################################\n\ndef _serialize_cfg(cfg, results_dir: Path) -\u003e None:\n    \"\"\"Persist full Hydra config so that evaluate.py can retrieve W\u0026B params.\"\"\"\n    out = results_dir / \"config.yaml\"\n    with out.open(\"w\") as f:\n        OmegaConf.save(config=cfg, f=f.name)\n\n\ndef _build_overrides(cfg) -\u003e List[str]:\n    \"\"\"Return list of `key=value` overrides to forward to *child* Hydra run.\"\"\"\n    overrides = [f\"run={cfg.run.run_id}\"]  # ensure identical run file\n    overrides.append(f\"results_dir={cfg.results_dir}\")\n\n    # Propagate trial_mode \u0026 wandb overrides\n    if cfg.trial_mode:\n        overrides.append(\"wandb.mode=disabled\")\n        overrides.append(\"optuna.n_trials=0\")\n        overrides.append(\"training.epochs=1\")\n        overrides.append(\"dataset.batch_size=8\")\n        overrides.append(\"training.inner_steps=1\")\n    return overrides\n\n\n#######################################################################\n# Hydra entry-point                                                   #\n#######################################################################\n\n@hydra.main(version_base=None, config_path=\"../config\", config_name=\"config\")\ndef main(cfg):\n    # ------------------------------------------------------------------\n    # Make sure results directory exists *in original working dir*\n    # ( Hydra changes cwd to an output folder )\n    # ------------------------------------------------------------------\n    results_dir = Path(to_absolute_path(cfg.results_dir)).expanduser().resolve()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    # Save full config for evaluation stage\n    _serialize_cfg(cfg, results_dir)\n\n    # ------------------------------------------------------------------\n    # Spawn training subprocess\n    # ------------------------------------------------------------------\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\"] + _build_overrides(cfg)\n    print(\"[Main] Launching training subprocess:\\n  \", \" \".join(cmd))\n\n    env = os.environ.copy()\n    # Better reproducibility \u2013 disable multi-thread nondeterminism\n    env.setdefault(\"CUBLAS_WORKSPACE_CONFIG\", \":4096:8\")\n\n    ret = subprocess.call(cmd, env=env)\n    if ret != 0:\n        raise RuntimeError(f\"Training subprocess exited with code {ret}\")\n\n    print(\"[Main] Training finished successfully \u2013 results stored in\", results_dir)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "# src/model.py\n\"\"\"Model utilities \u2013 wrapper around `timm` for ResNet-18 with hooks to\n*freeze* everything except BatchNorm affine parameters so that TENT / CW-TENT\ncan adapt them.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Any\n\nimport timm\nimport torch\nimport torch.nn as nn\n\n\ndef create_model(model_cfg, n_classes: int) -\u003e nn.Module:\n    \"\"\"Factory for classification models.\n\n    Currently supports only **ResNet-18** but is easily extensible.\n    The function returns a *pre-trained* model with the classifier layer\n    resized to `n_classes`.\n    \"\"\"\n    name: str = model_cfg.name.lower()\n    if name == \"resnet18\":\n        model = timm.create_model(\n            \"resnet18.a1_in1k\",\n            pretrained=True,\n            num_classes=n_classes,\n            cache_dir=\".cache/\",\n        )\n    else:\n        raise ValueError(f\"Unsupported model name: {model_cfg.name}\")\n\n    return model\n\n\n# -----------------------------------------------------------------------------\n# BN affine adaptation helpers\n# -----------------------------------------------------------------------------\n\ndef enable_bn_adaptation_params(model: nn.Module) -\u003e None:\n    \"\"\"Set `requires_grad=True` only for BatchNorm affine parameters.\"\"\"\n    for p in model.parameters():\n        p.requires_grad_(False)\n\n    for m in model.modules():\n        if isinstance(m, nn.BatchNorm2d):\n            if m.weight is not None:\n                m.weight.requires_grad_(True)\n            if m.bias is not None:\n                m.bias.requires_grad_(True)\n", "preprocess_py": "# src/preprocess.py\n\"\"\"Data-pipeline utilities (loading CIFAR-10-C + transforms).\nAll datasets are cached under ``.cache/`` for reproducibility and to avoid\nre-downloads.  The loader returns a **single stream DataLoader** because\nTTA operates in sequential (online) mode.\n\"\"\"\nfrom __future__ import annotations\n\nimport json\nfrom pathlib import Path\nfrom typing import List, Tuple\n\nimport numpy as np\nimport torch\nimport torchvision.transforms as T\nfrom torch.utils.data import DataLoader, Dataset\n\n\nclass CIFAR10CDataset(Dataset):\n    \"\"\"Minimal PyTorch Dataset for CIFAR-10-C.\n\n    Parameters\n    ----------\n    root : Path\n        Directory that contains corruption .npy files and ``labels.npy``.\n    severity : int\n        Corruption severity level (1-5, default 5).\n    corruption_types : List[str]\n        Which corruptions to include.  If the list contains string ``\"all\"``\n        the 15 standard corruptions are used.\n    transform : callable\n        Torchvision\u2010style transform applied to **PIL image**.\n    \"\"\"\n\n    _STANDARD_TYPES: List[str] = [\n        \"gaussian_noise\",\n        \"shot_noise\",\n        \"impulse_noise\",\n        \"defocus_blur\",\n        \"glass_blur\",\n        \"motion_blur\",\n        \"zoom_blur\",\n        \"snow\",\n        \"frost\",\n        \"fog\",\n        \"brightness\",\n        \"contrast\",\n        \"elastic_transform\",\n        \"pixelate\",\n        \"jpeg_compression\",\n    ]\n\n    def __init__(\n        self,\n        root: Path,\n        severity: int = 5,\n        corruption_types: List[str] | str = \"all\",\n        transform=None,\n    ) -\u003e None:\n        super().__init__()\n        root = Path(root)\n        assert root.exists(), f\"CIFAR-10-C root not found: {root}\"\n        self.transform = transform\n        self.severity = severity\n\n        if corruption_types == \"all\" or (isinstance(corruption_types, list) and \"all\" in corruption_types):\n            self.types: List[str] = self._STANDARD_TYPES\n        else:\n            self.types = list(corruption_types)\n\n        # Load label array once ( shared across corruptions )\n        labels_path = root / \"labels.npy\"\n        self.labels = np.load(labels_path)\n\n        # Build index mapping ( global_idx -\u003e (corr_type, local_idx) )\n        self._images: List[np.ndarray] = []  # each element holds np.ndarray slice view\n        self._type_for_img: List[int] = []\n\n        start = (severity - 1) * 10000\n        end = severity * 10000\n        for t_idx, c in enumerate(self.types):\n            imgs = np.load(root / f\"{c}.npy\", mmap_mode=\"r\")[start:end]\n            self._images.append(imgs)\n            self._type_for_img.extend([t_idx] * imgs.shape[0])\n\n        self._cum_counts = np.cumsum([arr.shape[0] for arr in self._images])\n        self.length = int(self._cum_counts[-1])\n\n    # ------------------------------------------------------------------\n    def __len__(self):\n        return self.length\n\n    # ------------------------------------------------------------------\n    def _get_img(self, idx: int) -\u003e Tuple[np.ndarray, int]:\n        # Binary search cum counts to locate corruption bucket\n        bucket = int(np.searchsorted(self._cum_counts, idx, side=\"right\"))\n        if bucket == 0:\n            local_idx = idx\n        else:\n            local_idx = idx - int(self._cum_counts[bucket - 1])\n        img = self._images[bucket][local_idx]  # (32,32,3) uint8\n        label = int(self.labels[local_idx])  # labels repeat across corruption types\n        return img, label\n\n    def __getitem__(self, idx):\n        img_np, label = self._get_img(idx)\n        img = T.ToPILImage()(img_np)\n        if self.transform is not None:\n            img = self.transform(img)\n        return img, label\n\n\n# -----------------------------------------------------------------------------\n# Public factory (consumed by train.py)\n# -----------------------------------------------------------------------------\n\ndef build_dataloader(dataset_cfg, cache_dir: Path) -\u003e Tuple[DataLoader, int]:\n    \"\"\"Factory that instantiates the dataset \u0026 DataLoader from Hydra cfg.\"\"\"\n    root = Path(dataset_cfg.root)\n    transform = T.Compose(\n        [\n            T.ToTensor(),\n            T.Normalize(mean=dataset_cfg.preprocessing.normalize.mean, std=dataset_cfg.preprocessing.normalize.std),\n        ]\n    )\n\n    ds = CIFAR10CDataset(\n        root=root,\n        severity=int(dataset_cfg.corruption_severity),\n        corruption_types=dataset_cfg.corruption_types,\n        transform=transform,\n    )\n\n    loader = DataLoader(\n        ds,\n        batch_size=int(dataset_cfg.batch_size),\n        shuffle=False,  # sequential stream \u2013 *do not* shuffle!\n        num_workers=int(dataset_cfg.num_workers),\n        pin_memory=True,\n        drop_last=False,\n    )\n    return loader, 10  # CIFAR-10\n", "pyproject_toml": "[build-system]\nrequires = [\"setuptools\u003e=42\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"tta-cwtent\"\nversion = \"0.1.0\"\ndescription = \"Confidence Weighted Test-Time Adaptation experiments with Hydra\"\nauthors = [{name=\"Researcher\"}]\n\n# ---------------------------------------------------------------------\n# Dependencies ( runtime )\n# ---------------------------------------------------------------------\ndependencies = [\n    \"torch\u003e=2.0\",\n    \"torchvision\u003e=0.15\",\n    \"hydra-core\u003e=1.3\",\n    \"wandb\u003e=0.15\",\n    \"timm\u003e=0.9\",\n    \"datasets\u003e=2.14\",\n    \"optuna\u003e=3.3\",\n    \"numpy\",\n    \"pandas\",\n    \"scikit-learn\",\n    \"matplotlib\",\n    \"seaborn\",\n    \"scipy\"\n]\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]", "train_py": "# src/train.py\n\"\"\"Single experiment run executor\n==================================\nThis script is *never* invoked directly by users. It is executed as a\nsub-process from ``src.main`` so that the main process can stay minimal and\nonly orchestrate runs.  All heavy lifting (data-loading, model creation,\ntraining / adaptation, logging) happens here.\n\nKey features\n------------\n*   Pure-PyTorch implementation (no lightning, no keras, \u2026)\n*   Hydra-driven config (@hydra.main)  \u2013 config lives in ``config/``\n*   WANDB logging with graceful fallback to disabled-mode for trial runs\n*   Supports three methods out-of-the-box\n    \u2013 \u201cbaseline\u201d  : inference\u2010only (no adaptation)\n    \u2013 \u201ctent\u201d      : original Test-Time Entropy Minimisation (multiple steps)\n    \u2013 \u201ccw-tent\u201d   : confidence-weighted variant proposed in the paper\n*   Integrated Optuna hyper-parameter search ( honours cfg.optuna.* )\n*   Deterministic seeding for exact reproducibility\n\"\"\"\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport hydra\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom hydra.utils import to_absolute_path\nfrom omegaconf import OmegaConf\nfrom sklearn.metrics import accuracy_score, confusion_matrix\n\n# Local imports --------------------------------------------------------------\nfrom .model import create_model, enable_bn_adaptation_params\nfrom .preprocess import build_dataloader\n\ntry:\n    import wandb\nexcept ImportError:  # pragma: no cover \u2013 Hydra ensures deps are present\n    wandb = None  # type: ignore\n\n\n###############################################################################\n# Helper functions                                                            #\n###############################################################################\n\ndef set_deterministic(seed: int) -\u003e None:\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    np.random.seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef entropy_from_logits(logits: torch.Tensor) -\u003e torch.Tensor:\n    probs = logits.softmax(dim=1).clamp_min(1e-12)\n    return -(probs * probs.log()).sum(1)\n\n\ndef adapt_step(\n    model: torch.nn.Module,\n    x: torch.Tensor,\n    objective: str,\n    inner_steps: int,\n    optimizer: torch.optim.Optimizer,\n) -\u003e None:\n    \"\"\"Per-batch adaptation that tweaks **BatchNorm affine** parameters only.\"\"\"\n    model.train()  # needed so BN layers use batch statistics\n    for _ in range(inner_steps):\n        optimizer.zero_grad(set_to_none=True)\n        logits = model(x)\n        probs = logits.softmax(1)\n        H = entropy_from_logits(logits)\n        if objective == \"entropy\":  # original TENT\n            loss = H.mean()\n        elif objective == \"confidence_weighted_entropy\":  # CW-TENT\n            C = probs.size(1)\n            with torch.no_grad():\n                w = 1.0 - H / np.log(C)\n            loss = (w * H).sum() / w.sum()\n        else:\n            raise ValueError(f\"Unsupported adaptation objective: {objective}\")\n        loss.backward()\n        optimizer.step()\n    model.eval()\n\n\n###############################################################################\n# Main training loop                                                          #\n###############################################################################\n\n@hydra.main(version_base=None, config_path=\"../config\", config_name=\"config\")\ndef main(cfg):  # noqa: C901 \u2013 complex but fine for main loop\n    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    # Re-create absolute paths ( Hydra makes them relative to temp dir )\n    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    results_dir = Path(to_absolute_path(cfg.results_dir)).expanduser().resolve()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    # ------------------------------------------------------------------\n    # Deterministic RNG \u0026 CUDA setup\n    # ------------------------------------------------------------------\n    set_deterministic(int(cfg.seed))\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ------------------------------------------------------------------\n    # Build data loaders\n    # ------------------------------------------------------------------\n    train_loader, n_classes = build_dataloader(cfg.dataset, cache_dir=Path(\".cache\"))\n\n    # ------------------------------------------------------------------\n    # Build model (+ freeze except BN affine as requested)\n    # ------------------------------------------------------------------\n    model = create_model(cfg.model, n_classes=n_classes)\n    enable_bn_adaptation_params(model)\n    model.to(device)\n\n    # ------------------------------------------------------------------\n    # Optimiser (only BN affine params)\n    # ------------------------------------------------------------------\n    bn_params = [p for p in model.parameters() if p.requires_grad]\n    if cfg.training.optimizer.lower() == \"sgd\":\n        optimizer = torch.optim.SGD(\n            bn_params,\n            lr=float(cfg.training.learning_rate),\n            momentum=float(cfg.training.momentum),\n            weight_decay=float(cfg.training.weight_decay),\n        )\n    else:\n        raise ValueError(\"Unsupported optimiser \u2013 only SGD is implemented for now.\")\n\n    # ------------------------------------------------------------------\n    # WANDB initialisation (skip if disabled)\n    # ------------------------------------------------------------------\n    if cfg.wandb.mode != \"disabled\":\n        assert wandb is not None, \"wandb must be installed \u2013 check pyproject.toml\"\n        run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            resume=\"allow\",\n            mode=cfg.wandb.mode,\n            config=OmegaConf.to_container(cfg, resolve=True),\n        )\n        print(f\"[WandB] Run URL: {run.get_url()}\")\n    else:\n        run = None  # type: ignore\n\n    #####################################################################\n    # Streaming evaluation / adaptation loop\n    #####################################################################\n    model.eval()\n    all_preds: List[int] = []\n    all_targets: List[int] = []\n\n    for step, (imgs, targets) in enumerate(train_loader, start=1):\n        imgs = imgs.to(device, non_blocking=True)\n        targets = targets.to(device, non_blocking=True)\n\n        # Forward pass (before adaptation) --------------------------------\n        with torch.no_grad():\n            logits = model(imgs)\n            preds = logits.argmax(1)\n\n        all_preds.extend(preds.cpu().tolist())\n        all_targets.extend(targets.cpu().tolist())\n\n        # Adaptation step --------------------------------------------------\n        if cfg.training.adaptation and cfg.method in {\"tent\", \"cw-tent\"}:\n            adapt_step(\n                model,\n                imgs,\n                objective=cfg.training.objective,\n                inner_steps=int(cfg.training.inner_steps),\n                optimizer=optimizer,\n            )\n\n        # Logging ----------------------------------------------------------\n        if step % int(cfg.training.log_interval) == 0 or step == len(train_loader):\n            acc = accuracy_score(all_targets, all_preds) * 100.0\n            if run is not None:\n                wandb.log({\"top1_accuracy\": acc, \"step\": step})\n            print(f\"[step {step:5d}] running-stream accuracy = {acc:6.2f}%\")\n\n    # ------------------------------------------------------------------\n    # Final metrics \u0026 confusion matrix\n    # ------------------------------------------------------------------\n    final_acc = accuracy_score(all_targets, all_preds) * 100.0\n    cm = confusion_matrix(all_targets, all_preds)\n\n    if run is not None:\n        wandb.log({\"final_top1_accuracy\": final_acc, \"conf_mat\": cm.tolist()})\n        run.finish()\n\n    # Save confusion matrix locally so evaluate.py can still work offline\n    np.save(results_dir / \"confusion_matrix.npy\", cm)\n\n\nif __name__ == \"__main__\":\n    # Hydra will call main()\n    sys.argv[0] = \"train.py\"  # nicer error stack traces\n    main()\n"}

Fix the issues identified above while preserving the correct parts of the implementation.



# Experimental Environment
NVIDIA H200×8
VRAM: 144GB×8
RAM： 2048 GB or more

# Current Research Method
{
    "Open Problems": "Most popular test-time adaptation (TTA) methods such as TENT adapt only BatchNorm affine parameters by minimizing prediction entropy on the incoming test stream. Although very effective, they often require 3-10 gradient steps for each incoming mini-batch to reach their best performance. The slow convergence mainly comes from noisy gradients produced by low-confidence (high-entropy) samples that dominate early in adaptation. A simple mechanism to down-weight these uncertain samples during optimization is missing.",
    "Methods": "Confidence-Weighted Entropy Minimization (CW-TENT).\n1. Keep the original TENT objective L = Σ_i H(p_i) where H is entropy.\n2. Introduce a scalar weight per sample w_i = 1 – H(p_i)/log(C)  (ranges in [0,1]; C = #classes).\n3. Replace the loss with the weighted variant  L_w = Σ_i w_i · H(p_i) / Σ_i w_i.\n4. Use the same SGD update of BatchNorm affine parameters, but with a single gradient step per mini-batch (optionally with momentum=0.9).\nTheoretical intuition: high-confidence samples (low entropy) are already close to the target domain optimum and provide reliable gradients; amplifying their contribution yields a cleaner gradient direction, allowing larger learning rate or fewer steps, hence faster convergence.",
    "Experimental Setup": "Dataset: CIFAR-10-C with 15 corruption types, severity 5 (standard TTA benchmark).\nModel: Pre-trained ResNet-18.\nBaselines: 1) Source model (no adaptation). 2) Original TENT (default 10 inner steps). 3) CW-TENT (1 inner step).\nMetric: Top-1 accuracy after processing the full test stream; also accuracy after first K (e.g., 1, 3) adaptation steps to measure convergence speed.",
    "Experimental Code": "import torch, torch.nn.functional as F\n\ndef entropy(p):\n    return -(p * p.log()).sum(1)\n\nclass CWTentAdapter:\n    def __init__(self, model, lr=1e-3, momentum=0.9):\n        self.model = model.eval()\n        self.model.requires_grad_(False)\n        # enable gradients for affine BN params only\n        for m in model.modules():\n            if isinstance(m, torch.nn.BatchNorm2d):\n                m.weight.requires_grad_(True)\n                m.bias.requires_grad_(True)\n        self.optimizer = torch.optim.SGD(filter(lambda p: p.requires_grad, model.parameters()), lr=lr, momentum=momentum)\n\n    @torch.no_grad()\n    def predict(self, x):\n        return self.model(x).softmax(1)\n\n    def adapt(self, x):\n        self.model.train()        # BN uses batch statistics\n        self.optimizer.zero_grad()\n        logits = self.model(x)\n        probs = logits.softmax(1)\n        H = entropy(probs)\n        w = 1 - H / torch.log(torch.tensor(probs.size(1), device=x.device))\n        loss = (w * H).sum() / w.sum()\n        loss.backward()\n        self.optimizer.step()\n        self.model.eval()\n        return probs.detach()\n",
    "Expected Result": "With only one gradient step per mini-batch, CW-TENT is expected to match or surpass the accuracy of TENT that uses 5–10 steps. For example on CIFAR-10-C severity 5: Source 58.7%, TENT (10 steps) 71.0%, CW-TENT (1 step) ≈71.5%. Convergence plot should show CW-TENT reaching peak accuracy after the first step, whereas TENT needs several.",
    "Expected Conclusion": "A tiny modification—confidence-weighted entropy—suppresses noisy gradients from uncertain samples and lets TENT converge in a single step. The change is trivial to implement (four extra lines) yet meaningfully cuts computation and latency at test time, making TTA more practical for real-time deployment."
}

# Experimental Design
- Summary: The experiment demonstrates that Confidence-Weighted TENT (CW-TENT) enables fast, one-step test-time adaptation by down-weighting high-entropy (low-confidence) samples in the classic entropy-minimisation objective used by TENT. A pre-trained ResNet-18 is sequentially exposed to the CIFAR-10-C corruption stream (severity-5). At every incoming mini-batch the model first produces predictions, then performs one SGD update on BatchNorm affine parameters using the confidence-weighted entropy loss. Performance is evaluated as the stream proceeds and compared against: (1) the frozen source model (no adaptation) and (2) the original TENT that applies 10 inner optimisation steps. All runs share identical data order, initial weights and hardware (8×H200, 144 GB each). Hyper-parameter sweeps on learning-rate, momentum and weight-decay are carried out with random search (30 trials) on a held-out corruption set to obtain fair settings for both CW-TENT and the baseline.
- Evaluation metrics: ['Top-1 Accuracy', 'Average Accuracy After First Adaptation Step']

# Experiment Runs

- Run ID: proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: proposed
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  Config File: config/run/proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5).yaml
  
  Config Content:
  ```yaml
  run_id: 'proposed-ResNet-18 (11M)-CIFAR-10-C (severity 5)'
method: cw-tent
model:
  name: resnet18
  pretrained_checkpoint: timm/resnet18.a1_in1k
  num_parameters_m: 11.7
  num_classes: 10
  freeze_except:
    - BatchNorm.weight
    - BatchNorm.bias
dataset:
  name: cifar10c
  root: /datasets/CIFAR-10-C
  corruption_severity: 5
  corruption_types: all
  split: test
  batch_size: 64
  num_workers: 8
  preprocessing:
    normalize:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2023, 0.1994, 0.2010]
training:
  adaptation: true
  objective: confidence_weighted_entropy
  inner_steps: 1
  learning_rate: 0.001
  momentum: 0.9
  weight_decay: 0.0
  optimizer: sgd
  epochs: 1
  scheduler: none
  gradient_clip: null
  stream_mode: sequential
  log_interval: 50
optuna:
  enabled: true
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
hardware:
  gpus: 8
  gpu_type: NVIDIA H200
  vram_per_gpu_gb: 144
  mixed_precision: true
seed: 42

  ```
  

- Run ID: comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)
  Method: comparative-1
  Model: ResNet-18 (11M)
  Dataset: CIFAR-10-C (severity 5)
  Config File: config/run/comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5).yaml
  
  Config Content:
  ```yaml
  run_id: 'comparative-1-ResNet-18 (11M)-CIFAR-10-C (severity 5)'
method: tent
model:
  name: resnet18
  pretrained_checkpoint: timm/resnet18.a1_in1k
  num_parameters_m: 11.7
  num_classes: 10
  freeze_except:
    - BatchNorm.weight
    - BatchNorm.bias
dataset:
  name: cifar10c
  root: /datasets/CIFAR-10-C
  corruption_severity: 5
  corruption_types: all
  split: test
  batch_size: 64
  num_workers: 8
  preprocessing:
    normalize:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2023, 0.1994, 0.2010]
training:
  adaptation: true
  objective: entropy
  inner_steps: 10
  learning_rate: 0.0005
  momentum: 0.9
  weight_decay: 0.0
  optimizer: sgd
  epochs: 1
  scheduler: none
  gradient_clip: null
  stream_mode: sequential
  log_interval: 50
optuna:
  enabled: true
  n_trials: 30
  direction: maximize
  metric: top1_accuracy
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-2
    momentum:
      type: uniform
      low: 0.0
      high: 0.99
    weight_decay:
      type: loguniform
      low: 1e-6
      high: 1e-3
    inner_steps:
      type: categorical
      choices: [1, 3, 5, 10]
hardware:
  gpus: 8
  gpu_type: NVIDIA H200
  vram_per_gpu_gb: 144
  mixed_precision: true
seed: 42

  ```
  


# External Resources (Use these for implementation)

**HuggingFace Models:**

- ID: timm/resnet18.a1_in1k

- Code: from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model('resnet18.a1_in1k', pretrained=True)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # unsqueeze single image into batch of 1

top5_probabilities, top5_class_indices = torch.topk(output.softmax(dim=1) * 100, k=5)

from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model(
    'resnet18.a1_in1k',
    pretrained=True,
    features_only=True,
)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # unsqueeze single image into batch of 1

for o in output:
    # print shape of each feature map in output
    # e.g.:
    #  torch.Size([1, 64, 112, 112])
    #  torch.Size([1, 64, 56, 56])
    #  torch.Size([1, 128, 28, 28])
    #  torch.Size([1, 256, 14, 14])
    #  torch.Size([1, 512, 7, 7])

    print(o.shape)

from urllib.request import urlopen
from PIL import Image
import timm

img = Image.open(urlopen(
    'https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png'
))

model = timm.create_model(
    'resnet18.a1_in1k',
    pretrained=True,
    num_classes=0,  # remove classifier nn.Linear
)
model = model.eval()

# get model specific transforms (normalization, resize)
data_config = timm.data.resolve_model_data_config(model)
transforms = timm.data.create_transform(**data_config, is_training=False)

output = model(transforms(img).unsqueeze(0))  # output is (batch_size, num_features) shaped tensor

# or equivalently (without needing to set num_classes=0)

output = model.forward_features(transforms(img).unsqueeze(0))
# output is unpooled, a (1, 512, 7, 7) shaped tensor

output = model.forward_head(output, pre_logits=True)
# output is a (1, num_features) shaped tensor



**HuggingFace Datasets:**



Generate complete, production-ready experiment code that integrates with Hydra configuration system.
Output:
{
    "train_py": "# src/train.py\n\"\"\"Single experiment run executor (Hydra entry-point)\n====================================================\nThis file is executed *only* from ``src.main``.  It receives the full Hydra\nconfig and performs one experiment run: data loading, (optional) adaptation\nand metric logging to WandB.\n\nMajor fixes compared to the previous iteration\n----------------------------------------------\n1. Correct config access (cfg.run.method rather than cfg.method).\n2. Honour `model.pretrained_checkpoint` from the run-config.\n3. Use `.cache/` for **all** external artefacts (datasets & models).\n4. Proper *trial-mode* handling – limit to two mini-batches and disable WandB.\n\"\"\"\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom hydra.utils import to_absolute_path\nfrom omegaconf import OmegaConf\nfrom sklearn.metrics import accuracy_score, confusion_matrix\n\nfrom .model import create_model, enable_bn_adaptation_params\nfrom .preprocess import build_dataloader\n\ntry:\n    import wandb\nexcept ImportError:  # pragma: no cover\n    wandb = None  # type: ignore\n\n###############################################################################\n# Utility functions                                                            #\n###############################################################################\n\ndef set_deterministic(seed: int) -> None:\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    np.random.seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef entropy_from_logits(logits: torch.Tensor) -> torch.Tensor:\n    probs = logits.softmax(1).clamp_min(1e-12)\n    return -(probs * probs.log()).sum(1)\n\n\ndef adapt_step(\n    model: torch.nn.Module,\n    x: torch.Tensor,\n    objective: str,\n    inner_steps: int,\n    optimizer: torch.optim.Optimizer,\n) -> None:\n    \"\"\"Gradient-based BN-affine adaptation for one mini-batch.\"\"\"\n    model.train()  # BN layers use batch statistics\n    for _ in range(inner_steps):\n        optimizer.zero_grad(set_to_none=True)\n        logits = model(x)\n        H = entropy_from_logits(logits)\n        if objective == \"entropy\":\n            loss = H.mean()\n        elif objective == \"confidence_weighted_entropy\":\n            C = logits.size(1)\n            with torch.no_grad():\n                w = 1.0 - H / np.log(C)\n            loss = (w * H).sum() / w.sum()\n        else:\n            raise ValueError(f\"Unsupported objective: {objective}\")\n        loss.backward()\n        optimizer.step()\n    model.eval()\n\n###############################################################################\n# Main loop                                                                    #\n###############################################################################\n\n@hydra.main(version_base=None, config_path=\"../config\", config_name=\"config\")\ndef main(cfg):  # noqa: C901\n    # ------------------------------------------------------------------\n    # Re-establish absolute paths (Hydra changes CWD)\n    # ------------------------------------------------------------------\n    results_dir = Path(to_absolute_path(cfg.results_dir)).expanduser().resolve()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    # Determinism -------------------------------------------------------\n    set_deterministic(int(cfg.seed))\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    # ------------------------------------------------------------------\n    # Data\n    # ------------------------------------------------------------------\n    loader, n_classes = build_dataloader(cfg.dataset, cache_dir=Path(\".cache\"))\n\n    # ------------------------------------------------------------------\n    # Model\n    # ------------------------------------------------------------------\n    model = create_model(cfg.model, n_classes=n_classes)\n    enable_bn_adaptation_params(model)\n    model.to(device)\n\n    # Optimiser (only BN-affine params) --------------------------------\n    bn_params = [p for p in model.parameters() if p.requires_grad]\n    optimizer = torch.optim.SGD(\n        bn_params,\n        lr=float(cfg.training.learning_rate),\n        momentum=float(cfg.training.momentum),\n        weight_decay=float(cfg.training.weight_decay),\n    )\n\n    # ------------------------------------------------------------------\n    # WandB initialisation\n    # ------------------------------------------------------------------\n    if cfg.wandb.mode != \"disabled\":\n        assert wandb is not None, \"wandb must be installed\"\n        run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            resume=\"allow\",\n            mode=cfg.wandb.mode,\n            config=OmegaConf.to_container(cfg, resolve=True),\n        )\n        print(f\"[WandB] Run URL: {run.get_url()}\")\n    else:\n        run = None  # type: ignore\n\n    #####################################################################\n    # Streaming evaluation / adaptation                                 #\n    #####################################################################\n    model.eval()\n    all_preds: List[int] = []\n    all_targets: List[int] = []\n\n    max_steps = 2 if cfg.trial_mode else len(loader)\n    for step, (imgs, targets) in enumerate(loader, 1):\n        if step > max_steps:  # trial-mode early break\n            break\n\n        imgs = imgs.to(device, non_blocking=True)\n        targets = targets.to(device, non_blocking=True)\n\n        # 1. Forward BEFORE adaptation ----------------------------------\n        with torch.no_grad():\n            logits = model(imgs)\n            preds = logits.argmax(1)\n\n        all_preds.extend(preds.cpu().tolist())\n        all_targets.extend(targets.cpu().tolist())\n\n        # 2. Adaptation --------------------------------------------------\n        if cfg.training.adaptation and cfg.run.method in {\"tent\", \"cw-tent\"}:\n            adapt_step(\n                model,\n                imgs,\n                objective=cfg.training.objective,\n                inner_steps=int(cfg.training.inner_steps),\n                optimizer=optimizer,\n            )\n\n        # 3. Logging -----------------------------------------------------\n        if (step % int(cfg.training.log_interval) == 0 or step == max_steps) and run is not None:\n            acc = accuracy_score(all_targets, all_preds) * 100.0\n            wandb.log({\"top1_accuracy\": acc, \"step\": step})\n        if step % int(cfg.training.log_interval) == 0 or step == max_steps:\n            acc = accuracy_score(all_targets, all_preds) * 100.0\n            print(f\"[step {step:5d}] running-stream accuracy = {acc:6.2f}%\")\n\n    # ------------------------------------------------------------------\n    # Final metrics\n    # ------------------------------------------------------------------\n    final_acc = accuracy_score(all_targets, all_preds) * 100.0\n    cm = confusion_matrix(all_targets, all_preds)\n\n    if run is not None:\n        wandb.log({\"final_top1_accuracy\": final_acc, \"conf_mat\": cm.tolist()})\n        run.finish()\n\n    # Save CM locally so that *offline* evaluation is still possible\n    np.save(results_dir / \"confusion_matrix.npy\", cm)\n\n\nif __name__ == \"__main__\":\n    sys.argv[0] = \"train.py\"\n    main()",
    "evaluate_py": "# src/evaluate.py\n\"\"\"Independent evaluation & visualisation script (runs after training).\n\nFixed to fully comply with Rule-8: *all* artefacts are now fetched directly\nfrom the WandB public API – no local fall-backs are used anymore.\n\"\"\"\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nimport yaml\nfrom scipy import stats\n\nsns.set_style(\"whitegrid\")\n\n################################################################################\n# CLI                                                                           \n################################################################################\n\ndef _parse_cli() -> argparse.Namespace:\n    p = argparse.ArgumentParser()\n    p.add_argument(\"results_dir\", type=str)\n    p.add_argument(\"run_ids\", type=str, help=\"JSON list, e.g. '[\\\"run1\\\",\\\"run2\\\"]'\")\n    return p.parse_args()\n\n################################################################################\n# Config                                                                        \n################################################################################\n\ndef _load_wandb_config(results_dir: Path) -> Dict:\n    cfg_file = results_dir / \"config.yaml\"\n    if not cfg_file.exists():\n        raise FileNotFoundError(f\"Global config.yaml not found at {cfg_file}\")\n    with cfg_file.open() as f:\n        return yaml.safe_load(f)\n\n################################################################################\n# Per-run processing                                                            \n################################################################################\n\ndef _export_metrics(df: pd.DataFrame, out: Path):\n    df.to_json(out, orient=\"records\", lines=True)\n\n\ndef _plot_learning_curve(df: pd.DataFrame, run_id: str, metric: str, out: Path):\n    plt.figure(figsize=(6, 4))\n    sns.lineplot(x=df.index, y=df[metric])\n    plt.title(f\"{run_id} – {metric}\")\n    plt.xlabel(\"Step\")\n    plt.ylabel(metric)\n    if not df[metric].dropna().empty:\n        final_val = df[metric].dropna().iloc[-1]\n        plt.annotate(f\"{final_val:.2f}\", xy=(df.index[-1], final_val), xytext=(-40, 10),\n                     textcoords=\"offset points\", fontsize=8)\n    plt.tight_layout()\n    plt.savefig(out)\n    plt.close()\n\n\ndef per_run(api: wandb.Api, entity: str, project: str, run_id: str, out_dir: Path) -> Dict:\n    run = api.run(f\"{entity}/{project}/{run_id}\")\n    hist_df = run.history(pandas=True)\n\n    _export_metrics(hist_df, out_dir / \"metrics.json\")\n\n    figs: List[Path] = []\n    for metric in [\"top1_accuracy\", \"batch_accuracy\"]:\n        if metric in hist_df.columns:\n            fig_path = out_dir / f\"learning_curve_{metric}.pdf\"\n            _plot_learning_curve(hist_df, run_id, metric, fig_path)\n            figs.append(fig_path)\n\n    # Confusion matrix from WandB summary --------------------------------\n    cm = run.summary.get(\"conf_mat\")\n    if cm is not None:\n        cm = np.asarray(cm, dtype=int)\n        class_names = [str(i) for i in range(cm.shape[0])]\n        plt.figure(figsize=(6, 5))\n        sns.heatmap(cm, annot=True, fmt=\"d\", cmap=\"Blues\", xticklabels=class_names,\n                    yticklabels=class_names)\n        plt.title(f\"{run_id} – Confusion Matrix\")\n        plt.ylabel(\"True\")\n        plt.xlabel(\"Pred\")\n        plt.tight_layout()\n        cm_path = out_dir / \"confusion_matrix.pdf\"\n        plt.savefig(cm_path)\n        plt.close()\n        figs.append(cm_path)\n\n    final_acc = run.summary.get(\"final_top1_accuracy\", float(\"nan\"))\n    method = run.config.get(\"run\", {}).get(\"method\", \"unknown\")\n\n    print(f\"[Per-run] {run_id}: saved {len(figs)} figure(s)\")\n    for f in figs:\n        print(\"  •\", f)\n\n    return {\"run_id\": run_id, \"method\": method, \"final_accuracy\": final_acc}\n\n################################################################################\n# Aggregated analysis                                                           \n################################################################################\n\ndef _bar_plot(df: pd.DataFrame, out: Path):\n    plt.figure(figsize=(8, 4))\n    sns.barplot(data=df, x=\"run_id\", y=\"final_accuracy\", hue=\"method\", palette=\"viridis\")\n    plt.xticks(rotation=45, ha=\"right\")\n    for i, row in df.iterrows():\n        plt.text(i, row[\"final_accuracy\"] + 0.5, f\"{row['final_accuracy']:.1f}\", ha=\"center\", fontsize=8)\n    plt.ylabel(\"Final Top-1 Accuracy (%)\")\n    plt.tight_layout()\n    plt.savefig(out)\n    plt.close()\n\n\ndef _box_plot(df: pd.DataFrame, out: Path):\n    plt.figure(figsize=(6, 4))\n    sns.boxplot(data=df, x=\"method\", y=\"final_accuracy\", palette=\"Set2\")\n    sns.stripplot(data=df, x=\"method\", y=\"final_accuracy\", color=\"black\", size=4, jitter=True)\n    plt.ylabel(\"Final Top-1 Accuracy (%)\")\n    plt.tight_layout()\n    plt.savefig(out)\n    plt.close()\n\n\ndef aggregated(per_run_stats: List[Dict], results_dir: Path):\n    comp_dir = results_dir / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    df = pd.DataFrame(per_run_stats)\n    df.to_csv(comp_dir / \"aggregated_metrics_table.csv\", index=False)\n\n    agg_json_path = comp_dir / \"aggregated_metrics.json\"\n    with agg_json_path.open(\"w\") as f:\n        json.dump(per_run_stats, f, indent=2)\n\n    _bar_plot(df, comp_dir / \"final_accuracy_comparison.pdf\")\n    _box_plot(df, comp_dir / \"boxplot_accuracy.pdf\")\n\n    print(\"\\n[Aggregated] Generated artefacts:\")\n    for p in comp_dir.iterdir():\n        print(\"  •\", p)\n\n################################################################################\n# Main                                                                          \n################################################################################\n\ndef main():\n    args = _parse_cli()\n    results_dir = Path(args.results_dir).expanduser().resolve()\n    run_ids = json.loads(args.run_ids)\n\n    wandb_cfg = _load_wandb_config(results_dir)\n    entity = wandb_cfg[\"wandb\"][\"entity\"]\n    project = wandb_cfg[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n\n    per_stats: List[Dict] = []\n    for rid in run_ids:\n        rdir = results_dir / rid\n        rdir.mkdir(parents=True, exist_ok=True)\n        stats = per_run(api, entity, project, rid, rdir)\n        per_stats.append(stats)\n\n    aggregated(per_stats, results_dir)\n\n\nif __name__ == \"__main__\":\n    main()",
    "preprocess_py": "# src/preprocess.py\n\"\"\"Data loading utilities for CIFAR-10-C.\nAll artefacts are placed under the mandatory ``.cache/`` directory.\n\"\"\"\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import List, Tuple\n\nimport numpy as np\nimport torch\nimport torchvision.transforms as T\nfrom torch.utils.data import DataLoader, Dataset, Subset\n\n\nclass CIFAR10CDataset(Dataset):\n    _STANDARD_TYPES: List[str] = [\n        \"gaussian_noise\", \"shot_noise\", \"impulse_noise\", \"defocus_blur\",\n        \"glass_blur\", \"motion_blur\", \"zoom_blur\", \"snow\", \"frost\", \"fog\",\n        \"brightness\", \"contrast\", \"elastic_transform\", \"pixelate\", \"jpeg_compression\",\n    ]\n\n    def __init__(self, root: Path, severity: int, corruption_types, transform=None):\n        super().__init__()\n        self.transform = transform\n        self.severity = severity\n\n        if corruption_types == \"all\" or (isinstance(corruption_types, list) and \"all\" in corruption_types):\n            self.types = self._STANDARD_TYPES\n        else:\n            self.types = list(corruption_types)\n\n        labels_path = root / \"labels.npy\"\n        if not labels_path.exists():\n            raise FileNotFoundError(\n                \"CIFAR-10-C was not found. Please download it from \"\n                \"https://zenodo.org/record/2535967 and place it under .cache/\"\n            )\n        self.labels = np.load(labels_path)\n\n        self._images: List[np.ndarray] = []\n        self._cum_counts: List[int] = []\n        start, end = (severity - 1) * 10000, severity * 10000\n        for c in self.types:\n            arr = np.load(root / f\"{c}.npy\", mmap_mode=\"r\")[start:end]\n            self._images.append(arr)\n            self._cum_counts.append(arr.shape[0] if not self._cum_counts else self._cum_counts[-1] + arr.shape[0])\n        self.length = self._cum_counts[-1]\n\n    # ------------------------------------------------------------------\n    def __len__(self):\n        return self.length\n\n    # ------------------------------------------------------------------\n    def __getitem__(self, idx):\n        bucket = int(np.searchsorted(self._cum_counts, idx, side=\"right\"))\n        prev = 0 if bucket == 0 else self._cum_counts[bucket - 1]\n        local_idx = idx - prev\n        img_np = self._images[bucket][local_idx]\n        label = int(self.labels[local_idx])\n        img = T.ToPILImage()(img_np)\n        if self.transform:\n            img = self.transform(img)\n        return img, label\n\n\n# -----------------------------------------------------------------------------\n# Factory                                                                        \n# -----------------------------------------------------------------------------\n\ndef build_dataloader(dataset_cfg, cache_dir: Path) -> Tuple[DataLoader, int]:\n    # Resolve root inside .cache/ as required\n    root = Path(dataset_cfg.root)\n    if not root.is_absolute():\n        root = cache_dir / root\n    root = root.expanduser().resolve()\n\n    transform = T.Compose([\n        T.ToTensor(),\n        T.Normalize(mean=dataset_cfg.preprocessing.normalize.mean,\n                     std=dataset_cfg.preprocessing.normalize.std),\n    ])\n\n    ds = CIFAR10CDataset(\n        root=root,\n        severity=int(dataset_cfg.corruption_severity),\n        corruption_types=dataset_cfg.corruption_types,\n        transform=transform,\n    )\n\n    # In *trial-mode* (flag checked at call-site) we might want a subset, but\n    # easier to handle break-condition in training loop.\n    loader = DataLoader(\n        ds,\n        batch_size=int(dataset_cfg.batch_size),\n        shuffle=False,\n        num_workers=int(dataset_cfg.num_workers),\n        pin_memory=True,\n    )\n    return loader, 10  # CIFAR-10 has 10 classes",
    "model_py": "# src/model.py\n\"\"\"Model factory utilities.\n\nFixes:\n1. Honour `model.pretrained_checkpoint` from the config.\n2. Ensure `.cache/` is consistently used for model weights.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Any\n\nimport timm\nimport torch.nn as nn\n\n\ndef create_model(model_cfg, n_classes: int) -> nn.Module:\n    name = model_cfg.name.lower()\n    ckpt = getattr(model_cfg, \"pretrained_checkpoint\", None)\n    if name == \"resnet18\":\n        model = timm.create_model(\n            ckpt if ckpt is not None else \"resnet18.a1_in1k\",\n            pretrained=True,\n            num_classes=n_classes,\n            cache_dir=\".cache/\",\n        )\n    else:\n        raise ValueError(f\"Unsupported model name: {model_cfg.name}\")\n    return model\n\n\ndef enable_bn_adaptation_params(model: nn.Module) -> None:\n    for p in model.parameters():\n        p.requires_grad_(False)\n    for m in model.modules():\n        if isinstance(m, nn.BatchNorm2d):\n            if m.weight is not None:\n                m.weight.requires_grad_(True)\n            if m.bias is not None:\n                m.bias.requires_grad_(True)",
    "main_py": "# src/main.py\n\"\"\"Hydra top-level orchestrator that spawns a *separate* Python process for\n`src.train` so that each run has an isolated CUDA context.\n\"\"\"\nfrom __future__ import annotations\n\nimport os\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nfrom hydra.utils import to_absolute_path\nfrom omegaconf import OmegaConf\n\n#######################################################################\n# Helper                                                               \n#######################################################################\n\ndef _serialize_cfg(cfg, results_dir: Path):\n    out = results_dir / \"config.yaml\"\n    OmegaConf.save(config=cfg, f=str(out))\n\n\ndef _build_overrides(cfg) -> List[str]:\n    o: List[str] = [f\"run={cfg.run.run_id}\", f\"results_dir={cfg.results_dir}\"]\n    # propagate trial-mode flag *and* its consequential overrides\n    o.append(f\"trial_mode={str(cfg.trial_mode).lower()}\")\n    if cfg.trial_mode:\n        o += [\n            \"wandb.mode=disabled\",\n            \"optuna.n_trials=0\",\n            \"training.epochs=1\",\n            \"dataset.batch_size=8\",\n            \"training.inner_steps=1\",\n        ]\n    return o\n\n#######################################################################\n# Hydra entry-point                                                    \n#######################################################################\n\n@hydra.main(version_base=None, config_path=\"../config\", config_name=\"config\")\ndef main(cfg):\n    results_dir = Path(to_absolute_path(cfg.results_dir)).expanduser().resolve()\n    results_dir.mkdir(parents=True, exist_ok=True)\n\n    _serialize_cfg(cfg, results_dir)\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\"] + _build_overrides(cfg)\n    print(\"[Main] Launching subprocess:\\n  \", \" \".join(cmd))\n\n    env = os.environ.copy()\n    env.setdefault(\"CUBLAS_WORKSPACE_CONFIG\", \":4096:8\")\n\n    ret = subprocess.call(cmd, env=env)\n    if ret != 0:\n        raise RuntimeError(f\"Training failed with exit-code {ret}\")\n\n    print(\"[Main] Finished – outputs at\", results_dir)\n\n\nif __name__ == \"__main__\":\n    main()",
    "pyproject_toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cw-tent-experiments\"\nversion = \"0.2.0\"\ndescription = \"Confidence-Weighted Test-Time Adaptation experiments with Hydra\"\nauthors = [{name = \"Researcher\"}]\n\ndependencies = [\n    \"torch>=2.0\",\n    \"torchvision>=0.15\",\n    \"hydra-core>=1.3\",\n    \"wandb>=0.15\",\n    \"timm>=0.9\",\n    \"numpy\",\n    \"pandas\",\n    \"scikit-learn\",\n    \"matplotlib\",\n    \"seaborn\",\n    \"scipy\",\n]\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]",
    "config_yaml": "# config/config.yaml\n# ~~~~~~~~~~~~~~~~~~~\n# Global Hydra configuration shared by all runs.\n\ndefaults:\n  - _self_\n  - run: null     # will be provided via CLI (config/run/<ID>.yaml)\n\ntrial_mode: false\nresults_dir: ./results\nseed: 42\n\nwandb:\n  entity: gengaru617-personal\n  project: 251020-test\n  mode: online  # auto-overridden to \"disabled\" in trial-mode\n\nhydra:\n  run:\n    dir: ./outputs/${now:%Y-%m-%d}_${now:%H-%M-%S}_${run.run_id}\n  job_logging:\n    version: 1\n    root:\n      level: INFO\n  hydra_logging:\n    version: 1\n    root:\n      level: INFO\n\n# ---------------------------------------------------------------------\n# Default placeholders (populated by run-specific YAML)\n# ---------------------------------------------------------------------\nrun:\n  run_id: dummy\n  method: baseline\nmodel: {}\ndataset: {}\ntraining: {}\noptuna: {}\nconfig: {}  # arbitrary extras\n\n# End of config.yaml\n"
}
